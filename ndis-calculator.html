<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NDIS Budget Calculator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
    <!-- QR Code generation - using qrcodejs instead -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <!-- QR Code scanning -->
    <script src="https://cdn.jsdelivr.net/npm/html5-qrcode@2.3.8/minified/html5-qrcode.min.js"></script>
    <style>

.card-actions {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
    padding: 1rem;
    border-top: 1px solid var(--border);
    align-items: stretch; /* Make children full width */
}


.continue-btn {
    align-self: center; /* Center only this button */
    width: auto; /* Remove full width */
    max-width: 300px;
    margin: 0;
}

.card-actions-bottom {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%; /* Full width for the bottom row */
}

.actions-menu {
    position: relative;
}

.delete-btn {
    margin-left: auto;
}

.actions-dropdown {
    position: absolute;
    bottom: 100%;
    left: 0;
    margin-bottom: 4px;
    min-width: 180px;
    background: white;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    box-shadow: var(--shadow-lg);
    z-index: 100;
}
.group-title-row {
    display: flex;
    align-items: center;
    gap: 10px;
    flex: 1;
}

.item-count {
    font-size: 0.9em;
    color: var(--text-secondary);
    margin-left: auto;
}

.filtered-badge {
    display: inline-block;
    padding: 2px 8px;
    background: var(--primary-light, #e0e7ff);
    color: var(--primary);
    border-radius: 12px;
    font-size: 0.75em;
    font-weight: normal;
    margin-left: 8px;
}

.load-all-items {
    width: 100%;
    padding: 12px;
    margin-top: 10px;
    border-top: 1px dashed var(--border);
    color: var(--primary);
    text-align: center;
    background: transparent;
    transition: background-color 0.2s;
}

.load-all-items:hover {
    background: var(--bg-hover);
}

/* Hide checkboxes when unselected items are hidden */
.items-list.hiding-unselected .item-row:not(.selected) {
    display: none;
}

.items-list.hiding-unselected .item-row.selected .item-checkbox {
    visibility: hidden;
}
.search-result-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.search-result-title {
    font-weight: 500;
}

.search-result-count {
    font-size: 0.85em;
    color: var(--text-secondary);
}

.search-result-matches {
    margin-top: 6px;
    padding-left: 10px;
    font-size: 0.85em;
}

.match-count {
    color: var(--primary);
    font-weight: 500;
    margin-bottom: 3px;
}

.match-item {
    color: var(--text-secondary);
    padding: 2px 0;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.match-more {
    font-style: italic;
    color: var(--text-muted);
    padding: 2px 0;
}

.group-search-result.no-results {
    color: var(--text-muted);
    text-align: center;
    padding: 15px;
}
.notes-section {
    margin-bottom: 1.5rem;
    padding-right: 0; /* Remove any default padding */
}

.items-list.hiding-unselected .item-row.selected .item-checkbox {
    visibility: hidden;
}

.notes-section h3 {
    font-size: 1rem;
    font-weight: 600;
    margin-bottom: 0.5rem;
}

.notes-input {
    width: calc(100% - 1.5rem); /* Account for padding */
    padding: 0.75rem;
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    font-size: 0.875rem;
    font-family: inherit;
    resize: vertical;
    min-height: 80px;
    max-height: 300px;
    overflow-y: auto;
    line-height: 1.4;
    box-sizing: border-box; /* Include padding in width calculation */
    font: arial;
}

/* Mobile responsive */
@media (max-width: 640px) {
    .notes-input {
        width: 100%;
    }
}

/* Actions dropdown menu */
.actions-menu {
    position: relative;
}

.actions-dropdown {
    position: absolute;
    bottom: 100%;
    right: 0;
    margin-bottom: 0.5rem;
    background: var(--bg-primary);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    min-width: 160px;
    z-index: 10;
}

.dropdown-item {
    width: 100%;
    padding: 0.5rem 1rem;
    text-align: left;
    background: none;
    border: none;
    font-size: 0.875rem;
    cursor: pointer;
    transition: var(--transition);
}

.dropdown-item:hover {
    background: var(--bg-secondary);
}

.dropdown-item.danger {
    color: var(--danger);
}

.dropdown-divider {
    height: 1px;
    background: var(--border);
    margin: 0.25rem 0;
}


.group-search-primary:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
}


/* Settings Accordion */

.accordion-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1rem;
    cursor: pointer;
    background: var(--bg-secondary);
    transition: background 0.2s;
}

.accordion-header:hover {
    background: var(--gray-100);
}

.accordion-icon {
    font-size: 0.75rem;
    transition: transform 0.2s;
}

.settings-accordion.collapsed .accordion-icon {
    transform: rotate(-90deg);
}

.settings-accordion.collapsed .accordion-content {
    display: none;
}

.accordion-title {
    font-weight: 600;
    font-size: 0.875rem;
    color: var(--text-primary);
}


@media (max-width: 640px) {
    .toggle-group {
        width: 100%;
    }
    
    .uplift-percent {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        width: 100%;
    }
    
    .uplift-percent input {
        flex: 1;
        max-width: 100px;
    }
}



.toggle-label {
    display: inline-flex;
    align-items: center;
    white-space: nowrap; /* Prevent text from wrapping */
}


@media (max-width: 640px) {
    .group-header {
        flex-direction: column;
        gap: 0.5rem;
    }
    
    .group-header-main {
        width: 100%;
    }
    
    .group-actions {
        width: 100%;
        display: flex;
        justify-content: flex-start;
        gap: 0.5rem;
        flex-wrap: wrap;
    }
    
    .group-totals {
        margin-right: 0;
        margin-left: auto;
    }
}

.settings-accordion {
    background: var(--bg-secondary);
    border-radius: var(--radius);
    margin-bottom: 1.5rem;
    overflow: visible;
}


.accordion-content {
    padding: 1rem;
}

.settings-section {
    padding-top: 0.5rem;
}

.toggle-group {
    margin-bottom: 1rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--border);
}
.toggle-group:last-child {
    border-bottom: none;
    margin-bottom: 0;
    padding-bottom: 0;
}

.toggle-wrapper {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
    flex-wrap: nowrap;
    width: 100%;
}

.toggle {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
    flex: 0 1 auto;
}


/* Fix uplift info layout */
.uplift-info {
    width: 100%;
    padding-left: 0;
    margin-left: 0;
    margin-top: 0.75rem;
}

.uplift-percent {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
}

.uplift-help {
    font-size: 0.75rem;
    color: var(--text-muted);
    line-height: 1.4;
    margin: 0;
    word-wrap: break-word;
}


@media (max-width: 768px) {
    .toggle-wrapper {
        flex-wrap: wrap;
    }
    
    .toggle {
        width: 100%;
        margin-bottom: 0.5rem;
    }
    
    .view-ph-btn {
        width: auto;
        align-self: flex-start;
    }
    
    .uplift-info {
        margin-top: 0.5rem;
    }
    
    .uplift-help {
        font-size: 0.7rem;
        line-height: 1.3;
    }
}

@media (max-width: 640px) {
    .card-actions {
        /* Remove flex-direction: column; */
        gap: 0.5rem;
        padding: 0.75rem; /* Slightly less padding on mobile */
    }
    
    /* Only make the continue button responsive, not the icon buttons */
    .card-actions .continue-btn {
        flex: 1;
        min-width: 0; /* Allow it to shrink */
        padding: 0.75rem 1rem; /* Smaller padding on mobile */
    }
    
    /* Keep icon buttons their normal size */
    .card-actions .btn-icon-only {
        flex-shrink: 0; /* Prevent shrinking */
    }
    .action-help {
        margin: 0.5rem 0;
    }
}

/* Mobile responsive */
@media (max-width: 768px) {
    .toggle-wrapper {
        flex-direction: column;
        align-items: stretch;
        gap: 0.75rem;
    }
    
    .toggle {
        width: 100%;
    }
    
    .view-ph-btn {
        align-self: flex-start;
        margin-top: 0;
    }
}
/* Responsive toggle layout */
@media (max-width: 640px) {
    .toggle-label {
        font-size: 0.8rem;
    }
    
    .toggle-wrapper {
        flex-direction: column;
        align-items: flex-start;
    }
    
    .view-ph-btn {
        margin-top: 0.5rem;
    }
}

/* Global actions for groups */
.section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    flex-wrap: wrap;
    gap: 0.5rem;
}


.global-actions {
    display: flex;
    gap: 0.5rem;
    flex-shrink: 0;
}

.ph-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.75rem;
    background: var(--bg-secondary);
    border-radius: var(--radius-sm);
}

.ph-date {
    font-weight: 600;
    color: var(--text-primary);
}

.ph-note {
    margin-top: 1rem;
    padding: 0.75rem;
    background: var(--bg-secondary);
    border-radius: var(--radius-sm);
    font-size: 0.875rem;
    line-height: 1.5;
}

.ph-note strong {
    color: var(--primary);
}
.action-help {
    width: 100%;
    text-align: center;
    margin: 0;
    font-size: 0.75rem;
    color: var(--text-muted);
}

.group-totals {
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    margin-right: 1rem;
}

.group-total {
    font-weight: 600;
    color: var(--primary);
}

.group-weekly {
    font-size: 0.75rem;
    color: var(--text-secondary);
}


.group-header-main {
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex: 1;
}

.group-total {
    font-weight: 600;
    color: var(--primary);
    margin-right: 1rem;
}

.group-panel.collapsed .items-list {
    display: none;
}

.group-title-row {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
    flex: 1;
}

.group-collapse-icon {
    font-size: 0.75rem;
    transition: transform 0.2s;
}

.group-header.clickable:hover {
    background: var(--gray-50);
    border-radius: var(--radius-sm);
}
/* Daily checkboxes for E items */
.daily-checkboxes {
    display: flex;
    gap: 0.25rem;
    align-items: center;
}

.day-checkbox-group {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.125rem;
}

.day-checkbox {
    width: 16px;
    height: 16px;
    cursor: pointer;
}

.day-label {
    font-size: 0.625rem;
    font-weight: 500;
    color: var(--text-secondary);
}

.quantity-input-group {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.quantity-label {
    font-size: 0.75rem;
    font-weight: 500;
    color: var(--text-secondary);
    white-space: nowrap;
}

.quantity-input {
    width: 60px;
    padding: 0.375rem 0.5rem;
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    font-size: 0.875rem;
    text-align: center;
}

/* Fix item layout for better alignment */
.item-row {
    display: grid;
    grid-template-columns: auto 1fr auto;
    gap: 0.75rem;
    padding: 0.5rem;
    align-items: center;
}

.item-inputs {
    display: flex;
    justify-content: flex-end;
    align-items: center;
    gap: 0.5rem;
}

/* Hide checkbox and selection for hidden items */
.item-row.hidden:not(.selected) {
    display: none;
}

.items-list.hide-unselected .item-row:not(.selected) .item-checkbox {
    display: none;
}

.items-list.hide-unselected .item-row:not(.selected) .item-info {
    grid-column: 1 / -1; /* Expand to full width when checkbox hidden */
}


.item-row.hidden.selected {
    opacity: 0.6;
}

.group-search {
    flex: 1;
    padding: 0.625rem 0.75rem;
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    font-size: 0.875rem;
    background: var(--bg-primary);
}

.group-search-results {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    max-height: 200px; /* Reduce from 300px */
    overflow-y: auto;
    -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
    background: var(--bg-primary);
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    margin-top: 0.25rem;
    box-shadow: var(--shadow);
    z-index: 1000; /* Increase z-index */
}

@media (max-width: 640px) {
    .group-search-results {
        position: fixed;
        left: 1rem;
        right: 1rem;
        top: auto;
        bottom: 1rem;
        max-height: 50vh;
    }
}

.group-search-result {
    padding: 0.5rem 0.75rem;
    cursor: pointer;
    font-size: 0.875rem;
    border-bottom: 1px solid var(--border);
}

.group-search-result:hover {
    background: var(--bg-secondary);
}

.group-search-result:last-child {
    border-bottom: none;
}

.add-group-container {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
    position: relative;
}

:root {
    /* Harmonious Color Palette */
    --primary: rgb(0, 150, 205);          /* Clear blue */
    --primary-dark: #658bf3;     /* Deeper blue */
    --accent: rgb(5, 177, 120);           /* Emerald green */
    --accent-dark: #20785c;      /* Deeper emerald */
    --danger: #cf5a5a;           /* Keep the red as is */
    --danger-dark: #dc2626;
    --success: #10b956;          /* Match accent for harmony */
    --warning: #fcb233;          /* Keep the amber */
    
    /* Rest stays the same */
    --gray-50: #f9fafb;
    --gray-100: #f3f4f6;
    --gray-200: #e5e7eb;
    --gray-300: #d1d5db;
    --gray-400: #9ca3af;
    --gray-500: #6b7280;
    --gray-600: #4b5563;
    --gray-700: #374151;
    --gray-800: #1f2937;
    --gray-900: #111827;
    
    --bg-primary: #ffffff;
    --bg-secondary: #f9fafb;
    --bg-card: #ffffff;
    
    --text-primary: #111827;
    --text-secondary: #6b7280;
    --text-muted: #9ca3af;
    
    --border: #e5e7eb;
    --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
    --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
    --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
    
    --radius: 12px;
    --radius-sm: 8px;
    --radius-lg: 16px;
    
    --transition: all 0.2s ease;
}

.btn-link {
    background: transparent;
    color: var(--primary);
    font-size: 0.875rem;
    font-weight: 500;
    border: none;
    padding: 0;
    text-decoration: underline;
    cursor: pointer;
    transition: var(--transition);
}

.btn-link:hover {
    color: var(--primary-dark);
    text-decoration: none;
}


body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    font-size: 16px;
    line-height: 1.5;
    color: var(--text-primary);
    background: var(--bg-secondary);
    min-height: 100vh;
    -webkit-font-smoothing: antialiased;
}

.top-bar {
    position: sticky;
    top: 0;
    z-index: 100;
    background: var(--bg-primary);
    border-bottom: 1px solid var(--border);
    padding: 1rem;
    box-shadow: var(--shadow-sm);
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-wrap: wrap;
    gap: 1rem;
}

.header-brand {
    display: flex;
    align-items: center;
}

.logo {
    max-height: 50px;
    width: auto;
}

/* Settings styles */
.setting-group {
    margin-bottom: 1rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--border);
}

.setting-label {
    display: block;
    font-size: 0.875rem;
    font-weight: 600;
    color: var(--text-secondary);
    margin-bottom: 0.5rem;
}

.state-select {
    padding: 0.5rem 2rem 0.5rem 0.75rem;
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    font-size: 0.875rem;
    background: var(--bg-primary);
    color: var(--text-primary);
    width: auto;
    min-width: 120px;
}

.setting-help {
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-top: 0.25rem;
    margin-bottom: 0;
}

/* Mobile responsive */
@media (max-width: 640px) {
    .top-bar {
        flex-direction: column;
        align-items: stretch;
    }
    
    .header-brand {
        margin-bottom: 0.5rem;
    }
    
    .top-actions {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.5rem;
    }
    
    .top-actions .btn {
        padding: 0.5rem;
        font-size: 0.8rem;
    }
    
    .top-actions .btn svg {
        width: 16px;
        height: 16px;
    }
}

.top-bar h1 {
    font-size: 1.25rem;
    font-weight: 600;
    margin-bottom: 0.75rem;
    color: var(--text-primary);
}

.top-actions {
    display: flex;
    gap: 0.75rem;
    margin-bottom: 0.75rem;
}

.state-selector {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    font-size: 0.875rem;
}

.state-selector label {
    color: var(--text-secondary);
    font-weight: 500;
}

.state-selector select {
    padding: 0.375rem 2rem 0.375rem 0.75rem;
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    font-size: 0.875rem;
    background: var(--bg-primary);
    color: var(--text-primary);
}

/* Buttons */
.btn {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1.75rem; /* slightly taller and wider for better spacing */
    font-size: 0.875rem;
    font-weight: 500;
    border: none;
    border-radius: 9999px; /* fully rounded edges for pill shape */
    cursor: pointer;
    transition: var(--transition);
    white-space: nowrap;
    margin: 0.5rem 0; /* adds space above and below the button */
}

.btn-primary {
    background: var(--primary);
    color: white;
}

.btn-primary:hover {
    background: var(--primary-dark);
}

.btn-accent {
    background: var(--accent);
    color: white;
}

.btn-accent:hover {
    background: var(--accent-dark);
}

.btn-secondary {
    background: var(--gray-100);
    color: var(--text-primary);
}

.btn-secondary:hover {
    background: var(--gray-200);
}

.btn-success {
    background: var(--success);
    color: white;
}

.btn-success:hover {
    background: #16a34a;
}

.btn-danger {
    background: var(--danger);
    color: white;
}

.btn-danger:hover {
    background: var(--danger-dark);
}

.btn-text {
    background: transparent;
    color: var(--primary);
    font-size: 0.875rem;
    font-weight: 500;
    border: none;
    padding: 0.25rem 0.5rem;
    cursor: pointer;
}

.btn-text:hover {
    text-decoration: underline;
}
/* Base icon button styles */
.btn-icon-only {
    width: 40px;    /* Increased from 32px */
    height: 40px;   /* Increased from 32px */
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
    border: none;
    border-radius: var(--radius-sm);
    cursor: pointer;
    transition: var(--transition);
    color: var(--text-secondary);
}

.btn-icon-only:hover {
    background: var(--gray-100);
    color: var(--text-primary);
}

/* Variant for info button next to text */
.btn-icon-only.info-icon {
    display: inline-flex; /* Changed from flex to inline-flex */
    width: 20px;
    height: 20px;
    background: var(--primary);
    color: white;
    border-radius: 50%;
    font-size: 12px;
    font-weight: bold;
    margin-left: 0.5rem;
    vertical-align: middle;
}


.btn-icon-only.info-icon:hover {
    background: var(--primary-dark);
    transform: scale(1.1);
}

/* Cards Container */
.cards-container {
    padding: 1rem 0.5rem; /* Reduced from 1rem all around */
    max-width: 900px; /* Increased from 800px to use more screen width */
    margin: 0 auto 2rem;
}
@media (max-width: 640px) {
    .cards-container {
        padding: 0.5rem 0.25rem; /* Very minimal side padding on mobile */
    }
}

/* Budget Card */
.budget-card {
    background: var(--bg-card);
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow);
    margin-bottom: 1rem;
    overflow: hidden;
    transition: var(--transition);
}

.budget-card.collapsed .card-body {
    display: none;
}

.budget-card.collapsed .collapse-btn svg {
    transform: rotate(-90deg);
}

.card-header {
    padding: 1rem;
    border-bottom: 1px solid var(--border);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.card-title {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    flex: 1;
}

.card-title input {
    border: 1px solid var(--border);
    padding: 0.5rem 0.75rem;
    border-radius: var(--radius-sm);
    font-size: 0.875rem;
    transition: var(--transition);
}

.card-title input:focus {
    outline: none;
    border-color: var(--primary);
}

.participant-name {
    font-weight: 500;
}

/* Card Body */
.card-body {
    padding: 1rem;
}

.card-section {
    margin-bottom: 1rem;
}

.date-range,
.budget-inputs {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0.75rem;
    margin-bottom: 0.75rem;
}

.form-group {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
}

.form-group label {
    font-size: 0.75rem;
    font-weight: 500;
    color: var(--text-secondary);
    text-transform: uppercase;
    letter-spacing: 0.025em;
}

.form-group input {
    padding: 0.625rem 0.75rem;
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    font-size: 0.875rem;
    transition: var(--transition);
}

.form-group input:focus {
    outline: none;
    border-color: var(--primary);
}

.form-group input.error {
    border-color: var(--danger);
}

/* Totals Section */
.totals-section {
    background: var(--bg-secondary);
    border-radius: var(--radius);
    padding: 1rem;
    margin-bottom: 1.5rem;
    display: flex;
    justify-content: space-around;
    gap: 0.5rem;
}


.total-item {
    text-align: center;
    position: relative;
}

/* Style for the dash when no budget */
.remaining-amount:not(.negative) {
    color: var(--text-muted);
}

.total-label {
    display: block;
    font-size: 0.75rem;
    font-weight: 500;
    color: var(--text-secondary);
    text-transform: uppercase;
    margin-bottom: 0.25rem;
}

.total-value {
    display: block;
    font-size: 1.25rem;
    font-weight: 600;
}

.used-amount {
    color: var(--warning);
}

.remaining-amount {
    color: var(--success);
}

.remaining-amount.negative {
    color: var(--danger);
}

.weekly-amount {
    color: var(--primary);
}



.toggle input {
    position: absolute;
    opacity: 0;
}

.toggle-slider {
    position: relative;
    width: 44px;
    height: 24px;
    background: var(--gray-300);
    border-radius: 24px;
    transition: var(--transition);
}

.toggle-slider::before {
    content: '';
    position: absolute;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: white;
    top: 2px;
    left: 2px;
    transition: var(--transition);
    box-shadow: var(--shadow-sm);
}

.toggle input:checked + .toggle-slider {
    background: var(--primary);
}

.toggle input:checked + .toggle-slider::before {
    transform: translateX(20px);
}


.uplift-percent input {
    width: 60px;
    padding: 0.375rem 0.5rem;
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    font-size: 0.875rem;
    text-align: center;
}

/* Groups Section */
.groups-section h3 {
    font-size: 1rem;
    font-weight: 600;
    margin-bottom: 0.75rem;
}

.add-group-container {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
}

.group-selector {
    flex: 1;
    padding: 0.625rem 0.75rem;
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    font-size: 0.875rem;
    background: var(--bg-primary);
}

/* Group Panel */
.group-panel {
    background: var(--bg-secondary);
    border-radius: var(--radius);
    padding: 0.75rem;
    margin-bottom: 0.75rem;
}

/* Group Budget Controls */
.group-budget-section {
    background: var(--bg-primary);
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    padding: 0.75rem;
    margin-bottom: 0.75rem;
    display: none; /* Hidden by default, shown when calculate by group is on */
}

.group-budget-inputs {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 0.5rem;
}

.group-budget-inputs .form-group {
    margin: 0;
}

.group-budget-inputs label {
    font-size: 0.7rem;
}

.group-budget-inputs input {
    padding: 0.375rem 0.5rem;
    font-size: 0.875rem;
}

/* Collapsed Card Styling */
.budget-card.collapsed .card-header {
    border-bottom: none;
}

.card-collapsed-info {
    display: none;
    padding: 0.75rem 1rem;
    background: var(--bg-secondary);
    border-bottom: 1px solid var(--border);
}

.budget-card.collapsed .card-collapsed-info {
    display: block;
}

.collapsed-info-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
}

.collapsed-dates {
    font-size: 0.875rem;
    color: var(--text-secondary);
}

.collapsed-amounts {
    display: flex;
    gap: 1.5rem;
    font-size: 0.875rem;
}

.collapsed-amount-item {
    text-align: center;
}

.collapsed-amount-label {
    font-size: 0.7rem;
    color: var(--text-secondary);
    text-transform: uppercase;
}

.collapsed-amount-value {
    font-weight: 600;
    color: var(--text-primary);
}

/* Card footer always visible */
.card-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.5rem 1rem;
    background: var(--bg-primary);
    border-top: 1px solid var(--border);
}

.budget-card.collapsed .card-body,
.budget-card.collapsed .card-actions {
    display: none;
}

/* Mobile responsive for dates */
@media (max-width: 640px) {
    .collapsed-dates {
        white-space: nowrap;
    }
    
    .collapsed-amounts {
        flex-direction: column;
        gap: 0.5rem;
        text-align: right;
    }
}

.group-panel {
    background: var(--bg-secondary);
    border-radius: var(--radius);
    padding: 0.75rem;
    margin-bottom: 0.75rem;
}

.group-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
}

.group-title {
    font-size: 0.875rem;
    font-weight: 600;
    color: var(--text-primary);
}

.group-actions {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

/* Items List */
.items-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.item-row {
    display: grid;
    grid-template-columns: auto 1fr auto;
    gap: 0.75rem;
    padding: 0.5rem;
    background: var(--bg-card);
    border-radius: var(--radius-sm);
    border: 1px solid var(--border);
    transition: var(--transition);
}

.item-row.selected {
    border-color: var(--primary);
    background: rgba(37, 99, 235, 0.05);
}

.item-row.hidden {
    display: none;
}

.item-checkbox {
    display: flex;
    align-items: center;
}

.item-checkbox input[type="checkbox"] {
    width: 20px;
    height: 20px;
    cursor: pointer;
}

.item-info {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
}

.item-name {
    font-size: 0.875rem;
    font-weight: 500;
    color: var(--text-primary);
    line-height: 1.3;
}

.item-details {
    display: flex;
    gap: 0.5rem;
    font-size: 0.75rem;
    color: var(--text-muted);
}

.item-price {
    font-weight: 500;
    color: var(--primary);
}

/* Item Inputs */
.item-inputs {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.hours-input-group {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
}

.hours-label {
    font-size: 0.625rem;
    font-weight: 500;
    color: var(--text-secondary);
    text-transform: uppercase;
}

.hours-input {
    width: 70px;
    padding: 0.375rem 0.5rem;
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    font-size: 0.875rem;
    text-align: center;
}

.hours-input:focus {
    outline: none;
    border-color: var(--primary);
}

.hours-input.error {
    border-color: var(--danger);
}

.per-day-toggle {
    font-size: 0.625rem;
    color: var(--primary);
    text-decoration: underline;
    cursor: pointer;
    margin-top: 0.125rem;
}

.per-day-inputs {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 0.25rem;
    margin-top: 0.5rem;
}

.per-day-inputs .hours-input-group {
    text-align: center;
}

.per-day-inputs .hours-label {
    font-size: 0.5rem;
}

.per-day-inputs .hours-input {
    width: 100%;
}

/* Modal */
@media (max-width: 640px) {
    .modal {
        padding: 1rem; /* Smaller padding on mobile */
    }
    
    .modal-content {
        max-width: calc(100% - 2rem); /* Match the padding */
        max-height: calc(100vh - 2rem);
    }
}

/* QR Scanner Modal */
#qr-scanner-modal .modal-content {
    max-width: 600px;
}

.qr-scanner-container {
    width: 100%;
    max-width: 500px;
    margin: 0 auto;
    position: relative;
}

#qr-reader {
    width: 100%;
}

.qr-scanner-info {
    text-align: center;
    margin: 1rem 0;
    color: var(--text-secondary);
}

.qr-action-buttons {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 0.75rem;
    margin-top: 1rem;
}

.qr-action-btn {
    padding: 1rem;
    text-align: center;
    background: var(--bg-secondary);
    border: 2px solid var(--border);
    border-radius: var(--radius);
    cursor: pointer;
    transition: var(--transition);
}

.qr-action-btn:hover {
    border-color: var(--primary);
    background: var(--bg-primary);
}

.qr-action-btn.selected {
    border-color: var(--primary);
    background: rgba(37, 99, 235, 0.1);
}

.qr-action-title {
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 0.25rem;
}

.qr-action-desc {
    font-size: 0.75rem;
    color: var(--text-secondary);
}

/* Modal */
@media (max-width: 640px) {
    .modal {
        padding: 1rem; /* Smaller padding on mobile */
    }
    
    .modal-content {
        max-width: calc(100% - 2rem); /* Match the padding */
        max-height: calc(100vh - 2rem);
    }
}

.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    z-index: 1000;
    padding: 1rem; /* Increase padding */
    overflow-y: auto;
    box-sizing: border-box; /* Important: include padding in width calculation */
}

.modal.show {
    display: flex;
    align-items: center;
    justify-content: center;
}

.modal-content {
    background: var(--bg-card);
    border-radius: var(--radius-lg);
    width: 100%;
    max-width: min(500px, calc(100% - 2rem)); /* Ensure it's never wider than viewport minus padding */
    max-height: calc(100vh - 4rem); /* Account for modal padding */
    overflow: hidden;
    display: flex;
    flex-direction: column;
    box-shadow: var(--shadow-lg);
    margin: 0 auto;
}

.modal-header {
    padding: 1rem;
    border-bottom: 1px solid var(--border);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.modal-header h3 {
    font-size: 1.125rem;
    font-weight: 600;
}

.modal-body {
    padding: 1rem;
    overflow-y: auto;
    flex: 1;
}

/* Public Holiday List */
.ph-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.ph-item {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.5rem;
    background: var(--bg-secondary);
    border-radius: var(--radius-sm);
}

.ph-checkbox {
    width: 20px;
    height: 20px;
}

.ph-checkbox:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.ph-date {
    font-weight: 500;
    font-size: 0.875rem;
}

.ph-name {
    font-size: 0.875rem;
    color: var(--text-secondary);
}

/* Error List */
.error-list {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.error-item {
    background: var(--bg-secondary);
    border-left: 4px solid var(--danger);
    border-radius: var(--radius-sm);
    padding: 0.75rem;
}

.error-message {
    font-size: 0.875rem;
    color: var(--text-primary);
    margin-bottom: 0.25rem;
}

.error-action {
    font-size: 0.75rem;
    color: var(--primary);
    text-decoration: underline;
    cursor: pointer;
}

/* Loading Overlay */
.loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.9);
    z-index: 2000;
    display: flex;
    align-items: center;
    justify-content: center;
}

.loading-content {
    text-align: center;
    padding: 2rem;
}

.loading-spinner {
    width: 48px;
    height: 48px;
    border: 4px solid var(--gray-200);
    border-top-color: var(--primary);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 1rem;
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}

.loading-text {
    font-size: 1rem;
    font-weight: 500;
    color: var(--text-primary);
    margin-bottom: 1rem;
}

.loading-progress {
    width: 200px;
    height: 6px;
    background: var(--gray-200);
    border-radius: 3px;
    overflow: hidden;
    margin: 0 auto 0.5rem;
}

.loading-progress-bar {
    height: 100%;
    background: var(--primary);
    border-radius: 3px;
    transition: width 0.3s ease;
}

.loading-percent {
    font-size: 0.875rem;
    color: var(--text-secondary);
}

/* Responsive */
@media (max-width: 640px) {
    .top-bar h1 {
        font-size: 1.125rem;
    }
    
    .date-range,
    .budget-inputs {
        grid-template-columns: 1fr;
    }
    
    .totals-section {
        flex-wrap: wrap;
    }
    @media (max-width: 640px) {
    .card-actions {
        /* Remove flex-direction: column; */
        gap: 0.5rem;
        padding: 0.75rem; /* Slightly less padding on mobile */
    }
    
    /* Only make the continue button responsive, not the icon buttons */
    .card-actions .continue-btn {
        flex: 1;
        min-width: 0; /* Allow it to shrink */
        padding: 0.75rem 1rem; /* Smaller padding on mobile */
    }
    
    /* Keep icon buttons their normal size */
    .card-actions .btn-icon-only {
        flex-shrink: 0; /* Prevent shrinking */
    }
}
    
    .card-actions .btn {
        flex: 1;
        justify-content: center;
        margin: 0.25rem 0;

    }
    
    .item-row {
        grid-template-columns: auto 1fr;
    }
    
    .item-inputs {
        grid-column: 1 / -1;
        margin-top: 0.5rem;
    }
}

/* Utility Classes */
.text-center {
    text-align: center;
}

.mt-1 {
    margin-top: 0.5rem;
}

.mt-2 {
    margin-top: 1rem;
}

.hidden {
    display: none !important;
}
</style>
</head>
<body>
    <header class="top-bar">
        <div class="header-brand">
            <img src="https://gqchhsayqxttewthcsah.supabase.co/storage/v1/object/public/Branding/LOGO%20No%20Background.png" 
                 alt="My Carers Logo" 
                 class="logo"
                 width="200">
        </div>
        <div class="top-actions">
            <div class="actions-menu">
                <button class="btn btn-secondary upload-menu-toggle">
                    <svg xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M11 16V7.85l-2.6 2.6L7 9l5-5 5 5-1.4 1.45L13 7.85V16h-2Zm-5 4q-.825 0-1.412-.587Q4 18.825 4 18v-3h2v3h12v-3h2v3q0 .825-.587 1.413Q18.825 20 18 20H6Z"/>
                    </svg>
                    Upload
                </button>
                <div class="actions-dropdown hidden upload-dropdown">
                    <button class="dropdown-item" id="qr-scan-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M3 11h8V3H3v8zm2-6h4v4H5V5zm8-2v8h8V3h-8zm6 6h-4V5h4v4zM3 21h8v-8H3v8zm2-6h4v4H5v-4zm13 6h1v-3h-1v3zm-3 0h1v-5h-1v5zm2-5h3v-3h-3v3zm0 2h1v-1h-1v1zm2-2h1v-1h-1v1z"/>
                        </svg>
                        Scan QR Code
                    </button>
                    <button class="dropdown-item" id="csv-import-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M14 2H6c-1.11 0-2 .9-2 2v16c0 1.1.89 2 2 2h12c1.1 0 2-.9 2-2V8l-6-6zM6 20V4h7v5h5v11H6z"/>
                        </svg>
                        Import CSV
                    </button>
                </div>
            </div>
            <input type="file" id="csv-import" accept=".csv" style="display: none;">
            <button id="multi-period-report-btn" class="btn btn-accent">
                <svg xmlns="http://www.w3.org/2000/svg" height="20" width="20" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 9H9V9h10v2zm-4 4H9v-2h6v2zm4-8H9V5h10v2z"/>
                </svg>
                Multi-Period Report
            </button>
            <button id="new-card-btn" class="btn btn-accent">
                + New Funding Period
            </button>            
        </div>
    </header>

    <!-- Cards Container -->
    <main class="cards-container" id="cards-container">
        <!-- Cards will be dynamically inserted here -->
    </main>

    <!-- Card Template -->
    <template id="card-template">
        <article class="budget-card" data-card-id="">
            <div class="card-header">
                <div class="card-title">
                    <input type="text" class="participant-name" placeholder="Participant Name">
                    <input type="text" class="ndis-number" placeholder="NDIS Number">
                </div>
                <button class="btn-icon-only collapse-btn" aria-label="Collapse card">
                    <svg width="20" height="20" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"/>
                    </svg>
                </button>
            </div>
            
            <!-- Collapsed info section -->
            <div class="card-collapsed-info">
                <div class="collapsed-info-row">
                    <div class="collapsed-dates">
                        <span class="collapsed-start-date">--</span> - <span class="collapsed-end-date">--</span>
                    </div>
                    <div class="collapsed-amounts">
                        <div class="collapsed-amount-item">
                            <div class="collapsed-amount-label">Used</div>
                            <div class="collapsed-amount-value collapsed-used">$0.00</div>
                        </div>
                        <div class="collapsed-amount-item">
                            <div class="collapsed-amount-label">Remaining</div>
                            <div class="collapsed-amount-value collapsed-remaining">$0.00</div>
                        </div>
                        <div class="collapsed-amount-item">
                            <div class="collapsed-amount-label">Budget</div>
                            <div class="collapsed-amount-value collapsed-budget">$0.00</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="card-body">
                <!-- Date and Budget Section -->
                <div class="card-section">
                    <div class="date-range">
                        <div class="form-group">
                            <label>Start Date</label>
                            <input type="date" class="start-date">
                        </div>
                        <div class="form-group">
                            <label>End Date</label>
                            <input type="date" class="end-date">
                        </div>
                    </div>
                    <div class="budget-inputs">
                        <div class="form-group">
                            <label>Total Budget</label>
                            <input type="number" class="budget-amount" placeholder="0.00" inputmode="decimal" step="0.01">
                        </div>
                        <div class="form-group">
                            <label>Excluded Amount</label>
                            <input type="number" class="excluded-amount" placeholder="0.00" inputmode="decimal" step="0.01">
                        </div>
                    </div>
                    <!-- Carry-over input field -->
                    <div class="form-group">
                        <label>Carry Over from Previous Period</label>
                        <input type="number" class="carry-in-amount" placeholder="0.00" inputmode="decimal" step="0.01">
                        <p class="setting-help">Amount remaining from previous funding period</p>
                    </div>
                    
                </div>

                <!-- Totals Section -->
                <div class="totals-section">
                    <div class="total-item">
                        <span class="total-label">Used</span>
                        <span class="total-value used-amount">$0.00</span>
                    </div>
                    <div class="total-item">
                        <span class="total-label">Remaining</span>
                        <span class="total-value remaining-amount">—</span>
                    </div>
                    <div class="total-item">
                        <span class="total-label">Weekly</span>
                        <span class="total-value weekly-amount">$0.00</span>
                    </div>
                </div>
                
                
                <!-- Settings Accordion -->
                <div class="settings-accordion">
                    <div class="accordion-header">
                        <span class="accordion-icon">▼</span>
                        <span class="accordion-title">Settings</span>
                    </div>
                    
                    <div class="accordion-content">
                        <div class="settings-section">
                            <!-- Calculate by Group Toggle -->
                            <div class="toggle-group">
                                <div class="toggle-wrapper">
                                    <label class="toggle">
                                        <input type="checkbox" class="calculate-by-group">
                                        <span class="toggle-slider"></span>
                                        <span class="toggle-label">Calculate by support group</span>
                                    </label>
                                </div>
                                <p class="setting-help">Enable to set individual budgets for each support group</p>
                            </div>
                            
                            <!-- Public Holidays Toggle -->
                            <div class="toggle-group">
                                <div class="toggle-wrapper">
    <label class="toggle">
        <input type="checkbox" class="include-ph" checked>
        <span class="toggle-slider"></span>
        <span class="toggle-label">
            Include Public Holidays
            <button class="btn-icon-only info-icon view-ph-btn" title="View holidays" type="button">ℹ</button>
        </span>
    </label>
</div>
</div>
                            
                            <!-- Price Uplift Toggle (THIS WAS MISSING) -->
                            <div class="toggle-group">
                                <div class="toggle-wrapper">
                                    <label class="toggle">
                                        <input type="checkbox" class="july-uplift" checked>
                                        <span class="toggle-slider"></span>
                                        <span class="toggle-label">Account for unreleased pricing</span>
                                    </label>
                                </div>
                                <div class="uplift-info">
                                    <div class="uplift-percent">
                                        <input type="number" class="uplift-rate" inputmode="decimal" step="0.1" value="3.2" min="0" max="100">
                                        <span>% annual increase</span>
                                    </div>
                                    <p class="uplift-help">Estimates future pricing with compounding increases</p>
                                </div>
                            </div>
                            
                            <!-- State Selection -->
                            <div class="setting-group">
                                <label class="setting-label">State:</label>
                                <select class="card-state state-select">
                                    <option value="NSW">NSW</option>
                                    <option value="VIC">VIC</option>
                                    <option value="QLD">QLD</option>
                                    <option value="WA">WA</option>
                                    <option value="SA">SA</option>
                                    <option value="TAS">TAS</option>
                                    <option value="ACT">ACT</option>
                                    <option value="NT">NT</option>
                                </select>
                                <p class="setting-help">Prices are based on the selected state</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Notes Section -->
                <div class="notes-section">
                    <h3>Notes & Assumptions</h3>
                    <textarea class="notes-input" 
                              placeholder="Enter any notes or assumptions for this funding period..." 
                              rows="4"></textarea>
                </div>
                
                <!-- Groups Section -->
                <div class="groups-section">
                    <div class="section-header">
                        <h3>Support Items</h3>
                        <div class="global-actions">
                            <button class="btn-text global-hide-unselected"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#1f1f1f"><path d="M480.09-336.92q67.99 0 115.49-47.59t47.5-115.58q0-67.99-47.59-115.49t-115.58-47.5q-67.99 0-115.49 47.59t-47.5 115.58q0 67.99 47.59 115.49t115.58 47.5ZM480-392q-45 0-76.5-31.5T372-500q0-45 31.5-76.5T480-608q45 0 76.5 31.5T588-500q0 45-31.5 76.5T480-392Zm.05 172q-137.97 0-251.43-76.12Q115.16-372.23 61.54-500q53.62-127.77 167.02-203.88Q341.97-780 479.95-780q137.97 0 251.43 76.12Q844.84-627.77 898.46-500q-53.62 127.77-167.02 203.88Q618.03-220 480.05-220ZM480-500Zm0 220q113 0 207.5-59.5T832-500q-50-101-144.5-160.5T480-720q-113 0-207.5 59.5T128-500q50 101 144.5 160.5T480-280Z"/></svg></button>
                            <button class="btn-text global-show-all" style="display:none;"><svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#1f1f1f"><path d="M630.92-441.08 586-486q9-49.69-28.35-89.35Q520.31-615 466-606l-44.92-44.92q13.54-6.08 27.77-9.12 14.23-3.04 31.15-3.04 68.08 0 115.58 47.5T643.08-500q0 16.92-3.04 31.54-3.04 14.61-9.12 27.38Zm127.23 124.46L714-358q38-29 67.5-63.5T832-500q-50-101-143.5-160.5T480-720q-29 0-57 4t-55 12l-46.61-46.61q37.92-15.08 77.46-22.23Q438.39-780 480-780q140.61 0 253.61 77.54T898.46-500q-22.23 53.61-57.42 100.08-35.2 46.46-82.89 83.3Zm32.31 231.39L628.62-245.85q-30.77 11.39-68.2 18.62Q523-220 480-220q-141 0-253.61-77.54Q113.77-375.08 61.54-500q22.15-53 57.23-98.88 35.08-45.89 77.23-79.58l-110.77-112 42.16-42.15 705.22 705.22-42.15 42.16Zm-552.3-551.08q-31.7 25.23-61.66 60.66Q146.54-540.23 128-500q50 101 143.5 160.5T480-280q27.31 0 54.39-4.62 27.07-4.61 45.92-9.53L529.69-346q-10.23 4.15-23.69 6.61-13.46 2.47-26 2.47-68.08 0-115.58-47.5T316.92-500q0-12.15 2.47-25.42 2.46-13.27 6.61-24.27l-87.84-86.62ZM541-531Zm-131.77 65.77Z"/></svg></button>
                        </div>
                    </div>
                    
                    <div class="add-group-container">
                        <input type="text" 
                               class="group-search" 
                               placeholder="Add support items - search by name or code..."
                               autocomplete="off">
                        <div class="group-search-results hidden"></div>
                    </div>
                    
                    
                    <div class="groups-list">
                        <!-- Groups will be dynamically added here -->
                    </div>
                </div>
                
                <!-- Continue button remains in body -->
                <div class="card-continue">
                    <button class="btn btn-primary continue-btn">+ Next Funding Period</button>
                </div>
            </div>
            
            <!-- Card Footer - always visible -->
            <div class="card-footer">
                <div class="actions-menu">
                    <button class="btn-icon-only actions-toggle" aria-label="Download options">
                        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#1f1f1f">
                            <path d="M480-320 280-520l56-58 104 104v-326h80v326l104-104 56 58-200 200ZM240-160q-33 0-56.5-23.5T160-240v-120h80v120h480v-120h80v120q0 33-23.5 56.5T720-160H240Z"/>
                        </svg>
                    </button>
                    <div class="actions-dropdown hidden">
                        <button class="dropdown-item generate-report-btn">Generate PDF Report</button>
                        <button class="dropdown-item export-btn">Export to CSV</button>
                    </div>
                </div>
                
                <button class="btn-icon-only delete-btn danger" aria-label="Delete period">
                    <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#1f1f1f">
                        <path d="M292.31-140q-29.92 0-51.12-21.19Q220-182.39 220-212.31V-720h-40v-60h180v-35.38h240V-780h180v60h-40v507.69Q740-182 719-161q-21 21-51.31 21H292.31ZM680-720H280v507.69q0 5.39 3.46 8.85t8.85 3.46h375.38q4.62 0 8.46-3.85 3.85-3.84 3.85-8.46V-720ZM376.16-280h59.99v-360h-59.99v360Zm147.69 0h59.99v-360h-59.99v360ZM280-720v520-520Z"/>
                    </svg>
                </button>
            </div>
        </article>
    </template>
    
    <!-- Group Template -->
    <template id="group-template">
        <div class="group-panel" data-group-number="">
            <div class="group-header">
                <h4 class="group-title"></h4>
                <div class="group-actions">
                    <button class="btn-text hide-unselected-btn">− Hide unselected</button>
                    <button class="btn-text show-all-btn" style="display:none;">+ Show all</button>
                    <button class="btn-icon-only remove-group-btn" aria-label="Remove group">✕</button>
                </div>
            </div>
            <div class="items-list">
                <!-- Items will be dynamically added here -->
            </div>
        </div>
    </template>

    <!-- Item Template -->
    <template id="item-template">
        <div class="item-row" data-item-number="">
            <div class="item-checkbox">
                <input type="checkbox" class="item-select">
            </div>
            <div class="item-info">
                <div class="item-name"></div>
                <div class="item-details">
                    <span class="item-number"></span>
                    <span class="item-unit"></span>
                    <span class="item-price"></span>
                </div>
            </div>
            <div class="item-inputs">
                <!-- Hours inputs will be dynamically added based on item type -->
            </div>
        </div>
    </template>

    <!-- Public Holiday Modal -->
    <div class="modal" id="ph-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Public Holidays in Range</h3>
                <button class="btn-icon-only close-modal" aria-label="Close modal">✕</button>
            </div>
            <div class="modal-body">
                <div class="ph-list" id="ph-list">
                    <!-- PH items will be dynamically added -->
                </div>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loading-overlay" style="display: none;">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <p class="loading-text">Importing catalogue...</p>
            <div class="loading-progress">
                <div class="loading-progress-bar" style="width: 0%"></div>
            </div>
            <p class="loading-percent">0%</p>
        </div>
    </div>

    <!-- Error Modal -->
    <div class="modal" id="error-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Validation Errors</h3>
                <button class="btn-icon-only close-modal" aria-label="Close modal">✕</button>
            </div>
            <div class="modal-body">
                <div class="error-list" id="error-list">
                    <!-- Errors will be dynamically added -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- QR Scanner Modal -->
    <div class="modal" id="qr-scanner-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Scan NDIS Report QR Code</h3>
                <button class="btn-icon-only close-modal" aria-label="Close modal">✕</button>
            </div>
            <div class="modal-body">
                <div class="qr-scanner-container">
                    <div id="qr-reader"></div>
                    <div class="qr-scanner-info">
                        Position the QR code from an NDIS report within the frame
                    </div>
                </div>
                <div class="qr-action-buttons hidden" id="qr-actions">
                    <button class="qr-action-btn" data-action="import">
                        <div class="qr-action-title">Import & Modify</div>
                        <div class="qr-action-desc">Load data for editing</div>
                    </button>
                    <button class="qr-action-btn" data-action="continue">
                        <div class="qr-action-title">Continue Period</div>
                        <div class="qr-action-desc">Create next funding period</div>
                    </button>
                    <button class="qr-action-btn" data-action="invoice">
                        <div class="qr-action-title">Generate Invoice</div>
                        <div class="qr-action-desc">Create invoice from data</div>
                    </button>
                    <button class="qr-action-btn" data-action="view">
                        <div class="qr-action-title">View Only</div>
                        <div class="qr-action-desc">Display report read-only</div>
                    </button>
                </div>
            </div>
        </div>
    </div>


    <!-- Supabase library -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

<script>
    // Now you can use createClient
    const supabaseUrl = 'https://gqchhsayqxttewthcsah.supabase.co';
    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdxY2hoc2F5cXh0dGV3dGhjc2FoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY2OTA0ODksImV4cCI6MjA3MjI2NjQ4OX0.iAGhrDZaHkpLwjJY07o-73l2OiePB2x1ZnnTEfUBd_M';
    const { createClient } = supabase;
    const supabaseClient = createClient(supabaseUrl, supabaseKey);


// ===== State Management =====
const state = {
    catalogue: null,
    cards: [],
    publicHolidays: [],
    preferences: {
        state: 'NSW',  // This is already set as default
        upliftPercent: 3.2,
        continueInterval: 'month'
    }
};
let isSaving = false;


//REPORT START

// Add this function to your code
function getItemUsageDescription(item) {
    if (item.unit === 'H') {
        const hours = [];
        if (item.hours.weekday !== undefined) {
            hours.push(`Weekdays: ${item.hours.weekday}h`);
        } else if (item.hours.Mon || item.hours.Tue || item.hours.Wed || item.hours.Thu || item.hours.Fri) {
            const dayHours = [];
            ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].forEach(day => {
                if (item.hours[day] !== undefined) dayHours.push(`${day}: ${item.hours[day]}h`);
            });
            hours.push(dayHours.join(', '));
        }
        if (item.hours.saturday !== undefined) hours.push(`Sat: ${item.hours.saturday}h`);
        if (item.hours.sunday !== undefined) hours.push(`Sun: ${item.hours.sunday}h`);
        if (item.hours.publicHoliday !== undefined) hours.push(`PH: ${item.hours.publicHoliday}h`);
        return hours.join(' | ') || 'No hours set';
    } else if (item.unit === 'E') {
        if (item.days) {
            const selectedDays = Object.entries(item.days)
                .filter(([day, selected]) => selected)
                .map(([day]) => day);
            return selectedDays.length ? `Days: ${selectedDays.join(', ')}` : 'No days selected';
        }
        return item.quantity ? `Quantity: ${item.quantity}` : 'No quantity set';
    }
    return '';
}


// Add this function to convert image URL to base64
async function createSupportGroupTable(doc, card, x, y, width) {
    const totals = computeCardTotals(card);
    const data = [];
    
    // Prepare data for each group
    card.groups.forEach(group => {
        const groupTotal = (totals.perGroupCents[group.regGroupNumber] || 0) / 100;
        let groupHasItems = false;
        
        group.items.forEach(item => {
            if (!item.selected) return;
            
            // Calculate item usage
            let quantity = 0;
            let usage = '';
            
            if (item.unit === 'H') {
                // Calculate total hours across the period
                let totalHours = 0;
                
                // Count days and calculate hours
                eachDateInclusive(card.period.start, card.period.end, (date) => {
                    const dayOfWeek = getDayOfWeek(date);
                    const isPH = isPublicHoliday(date, card.state);
                    const dayQty = resolveQuantityForDate(item, date, dayOfWeek, { isPH, isSleepover: isSleepoverItem(item) });
                    totalHours += dayQty;
                });
                
                quantity = totalHours;
                usage = getItemUsageDescription(item);
            } else {
                // For E items, show quantity or days
                if (getEItemType(item.supportItemName) === 'daily' && item.days) {
                    const selectedDays = Object.entries(item.days)
                        .filter(([day, selected]) => selected)
                        .map(([day]) => day);
                    usage = selectedDays.length ? `Days: ${selectedDays.join(', ')}` : '';
                } else if (item.quantity) {
                    quantity = item.quantity;
                    usage = `Quantity: ${item.quantity}`;
                }
            }
            
            const unitPrice = item.statePrice || 0;
            const lineTotal = quantity * unitPrice;
            
            if (quantity > 0 || (item.days && Object.values(item.days).some(v => v))) {
                data.push([
                    item.supportItemName,
                    item.supportItemNumber,
                    usage,
                    quantity > 0 ? quantity.toString() : '',
                    formatCurrency(unitPrice),
                    formatCurrency(lineTotal)
                ]);
                groupHasItems = true;
            }
        });
        
        // Add group total row if group has items
        if (groupHasItems && groupTotal > 0) {
            data.push([
                `${group.regGroupName} Total`,
                '',
                '',
                '',
                '',
                formatCurrency(groupTotal)
            ]);
        }
    });
    
    if (data.length === 0) {
        doc.setFontSize(10);
        doc.text('No support items with quantities entered', x, y);
        return;
    }
    
    // Create the table
    doc.autoTable({
        startY: y,
        head: [['Support Item', 'Code', 'Usage', 'Qty', 'Rate', 'Total']],
        body: data,
        margin: { left: x, right: 20 },
        columnStyles: {
            0: { cellWidth: 45 },
            1: { cellWidth: 20 },
            2: { cellWidth: 30 },
            3: { cellWidth: 16 },
            4: { cellWidth: 16, halign: 'right' },
            5: { cellWidth: 20, halign: 'right' }
        },
        styles: {
            fontSize: 8,
            cellPadding: 2
        },
        headStyles: {
            fillColor: [37, 99, 235],
            textColor: [255, 255, 255]
        },
        didDrawCell: (data) => {
            // Bold group total rows
            if (data.cell.raw && data.cell.raw.includes('Total') && data.column.index === 0) {
                doc.setFont(undefined, 'bold');
                doc.setFillColor(248, 249, 250);
            }
        }
    });
}

// Helper function to generate individual period sections in multi-period report
async function generatePeriodSection(doc, card, periodNumber) {
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const margin = 20;
    const contentWidth = pageWidth - (margin * 2);
    
    let y = margin;
    
    // Period header
    doc.setFontSize(20);
    doc.setFont(undefined, 'bold');
    doc.text(`Period ${periodNumber}`, margin, y);
    
    doc.setFontSize(12);
    doc.setFont(undefined, 'normal');
    const startDate = new Date(card.period.start);
    const endDate = new Date(card.period.end);
    doc.text(`${startDate.toLocaleDateString('en-AU')} to ${endDate.toLocaleDateString('en-AU')}`, margin, y + 8);
    
    y += 25;
    
    // Budget summary
    doc.setFontSize(14);
    doc.setFont(undefined, 'bold');
    doc.text('Budget Summary', margin, y);
    y += 10;
    
    if (card.settings.calculateByGroup) {
        await createGroupBudgetSummaryTable(doc, card, margin, y, contentWidth);
    } else {
        await createBudgetTable(doc, card, margin, y, contentWidth);
    }
    
    y = doc.lastAutoTable.finalY + 20;
    
    // Support groups
    if (y > pageHeight - 100) {
        doc.addPage();
        y = margin;
    }
    
    doc.setFontSize(14);
    doc.setFont(undefined, 'bold');
    doc.text('Support Groups', margin, y);
    y += 10;
    
    await createSupportGroupTable(doc, card, margin, y, contentWidth);
}

async function getBase64FromUrl(url) {
    const response = await fetch(url);
    const blob = await response.blob();
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
}


function categorizeItems(items) {
    const categories = {
        'SDA': [],
        'Respite': [],
        'Daily Activities - Standard': [],
        'Daily Activities - High': [],
        'Community Access': [],
        'Other': []
    };
    
    items.forEach(item => {
        const name = item.supportItemName.toLowerCase();
        if (name.includes('sda')) {
            categories['SDA'].push(item);
        } else if (name.includes('respite')) {
            categories['Respite'].push(item);
        } else if (name.includes('daily') && name.includes('high')) {
            categories['Daily Activities - High'].push(item);
        } else if (name.includes('daily') && name.includes('standard')) {
            categories['Daily Activities - Standard'].push(item);
        } else if (name.includes('community')) {
            categories['Community Access'].push(item);
        } else {
            categories['Other'].push(item);
        }
    });
    
    // Remove empty categories
    Object.keys(categories).forEach(key => {
        if (categories[key].length === 0) delete categories[key];
    });
    
    return categories;
}



// ===== QR Code Functions =====
function buildQRData(card) {
    // Create a compact representation of the card data
    const qrData = {
        v: 1, // Version for future compatibility
        id: card.id,
        p: { // participant
            n: card.participant.name,
            ndis: card.participant.ndisNumber
        },
        d: { // dates
            s: card.period.start,
            e: card.period.end
        },
        b: { // budget
            t: card.budget.total,
            ex: card.budget.excluded,
            co: card.budget.carryOver
        },
        st: card.state,
        set: { // settings
            ph: card.settings.includePH,
            u: card.settings.uplift.enabled,
            up: card.settings.uplift.percent,
            cbg: card.settings.calculateByGroup || false
        },
        n: card.notes || '',
        g: [] // groups
    };
    
    // Compress groups data - only include selected items
    card.groups.forEach(group => {
        const selectedItems = group.items.filter(item => item.selected);
        if (selectedItems.length > 0) {
            const groupData = {
                n: group.regGroupNumber,
                i: [] // items
            };
            
            // Add group budget if calculate by group is enabled
            if (card.settings.calculateByGroup && group.budget) {
                groupData.b = {
                    t: group.budget.total || 0,
                    e: group.budget.excluded || 0,
                    c: group.budget.carryOver || 0
                };
            }
            
            selectedItems.forEach(item => {
                const itemData = {
                    n: item.supportItemNumber,
                    op: item.overridePrice
                };
                
                if (item.unit === 'H' && item.hours) {
                    itemData.h = item.hours;
                } else if (item.unit === 'E') {
                    if (item.days && Object.keys(item.days).length > 0) {
                        itemData.d = item.days;
                    }
                    if (item.quantity > 0) {
                        itemData.q = item.quantity;
                    }
                }
                
                groupData.i.push(itemData);
            });
            
            qrData.g.push(groupData);
        }
    });
    
    // Convert to JSON and compress
    return JSON.stringify(qrData);
}

async function generateQRCode(data) {
    return new Promise((resolve, reject) => {
        try {
            // Create a temporary div for QR code generation
            const tempDiv = document.createElement('div');
            tempDiv.style.position = 'absolute';
            tempDiv.style.left = '-9999px';
            document.body.appendChild(tempDiv);
            
            // Generate QR code
            const qrCode = new QRCode(tempDiv, {
                text: data,
                width: 200,
                height: 200,
                colorDark: "#000000",
                colorLight: "#ffffff",
                correctLevel: QRCode.CorrectLevel.M
            });
            
            // Wait for QR code to be generated
            setTimeout(() => {
                const canvas = tempDiv.querySelector('canvas');
                if (canvas) {
                    const dataUrl = canvas.toDataURL('image/png');
                    document.body.removeChild(tempDiv);
                    resolve(dataUrl);
                } else {
                    document.body.removeChild(tempDiv);
                    reject(new Error('Failed to generate QR code'));
                }
            }, 100);
        } catch (error) {
            reject(error);
        }
    });
}

function parseQRData(qrString) {
    try {
        const data = JSON.parse(qrString);
        
        // Validate version
        if (data.v !== 1) {
            throw new Error('Unsupported QR code version');
        }
        
        // Reconstruct full card structure
        const card = {
            id: data.id || generateUUID(),
            participant: {
                name: data.p.n || '',
                ndisNumber: data.p.ndis || ''
            },
            period: {
                start: data.d.s || '',
                end: data.d.e || ''
            },
            state: data.st || state.preferences.state,
            budget: {
                total: data.b.t || 0,
                excluded: data.b.ex || 0,
                carryOver: data.b.co || 0
            },
            settings: {
                includePH: data.set.ph !== false,
                uplift: {
                    enabled: data.set.u !== false,
                    percent: data.set.up || 3.2
                },
                calculateByGroup: data.set.cbg || false
            },
            notes: data.n || '',
            groups: []
        };
        
        // Reconstruct groups with full catalogue data
        if (data.g && state.catalogue) {
            data.g.forEach(groupData => {
                const catalogueGroup = state.catalogue[groupData.n];
                if (!catalogueGroup) return;
                
                const group = {
                    regGroupNumber: groupData.n,
                    regGroupName: catalogueGroup.regGroupName,
                    items: []
                };
                
                // Add group budget if present
                if (groupData.b) {
                    group.budget = {
                        total: groupData.b.t || 0,
                        excluded: groupData.b.e || 0,
                        carryOver: groupData.b.c || 0
                    };
                }
                
                // Create a map of QR items for quick lookup
                const qrItemsMap = new Map();
                groupData.i.forEach(item => {
                    qrItemsMap.set(item.n, item);
                });
                
                // Add all items from catalogue, marking selected ones
                catalogueGroup.items.forEach(catalogueItem => {
                    const qrItem = qrItemsMap.get(catalogueItem.supportItemNumber);
                    const itemData = {
                        ...catalogueItem,
                        selected: !!qrItem,
                        overridePrice: qrItem?.op || null,
                        statePrice: catalogueItem.statePrices[card.state] || catalogueItem.statePrices['NSW'] || 0,
                        hours: qrItem?.h || {},
                        days: qrItem?.d || {},
                        quantity: qrItem?.q || 0
                    };
                    
                    group.items.push(itemData);
                });
                
                card.groups.push(group);
            });
        }
        
        return card;
    } catch (error) {
        console.error('Error parsing QR data:', error);
        throw new Error('Invalid QR code data');
    }
}

// ===== QR Scanner Functions =====
let html5QrCode = null;

function initQRScanner() {
    const modal = document.getElementById('qr-scanner-modal');
    const actionsDiv = document.getElementById('qr-actions');
    
    // Check if Html5Qrcode is available
    if (typeof Html5Qrcode === 'undefined') {
        console.error('Html5Qrcode library not loaded');
        showError('QR Scanner not available. Please check your internet connection.');
        return;
    }
    
    html5QrCode = new Html5Qrcode("qr-reader");
    
    const config = {
        fps: 10,
        qrbox: { width: 250, height: 250 }
    };
    
    let scannedData = null;
    
    const onScanSuccess = (decodedText, decodedResult) => {
        // Stop scanning
        html5QrCode.stop();
        
        // Store scanned data
        scannedData = decodedText;
        
        // Show action buttons
        actionsDiv.classList.remove('hidden');
        
        // Update scanner info
        document.querySelector('.qr-scanner-info').textContent = 'QR code scanned successfully! Choose an action:';
    };
    
    const onScanFailure = (error) => {
        // Handle scan failure silently
    };
    
    // Start scanning
    html5QrCode.start(
        { facingMode: "environment" },
        config,
        onScanSuccess,
        onScanFailure
    );
    
    // Action button handlers
    actionsDiv.querySelectorAll('.qr-action-btn').forEach(btn => {
        btn.onclick = async () => {
            const action = btn.dataset.action;
            
            try {
                const card = parseQRData(scannedData);
                
                switch (action) {
                    case 'import':
                        importCardFromQR(card);
                        break;
                    case 'continue':
                        continueFromQR(card);
                        break;
                    case 'invoice':
                        await generateInvoiceFromQR(card);
                        break;
                    case 'view':
                        viewReportFromQR(card);
                        break;
                }
                
                modal.classList.remove('show');
            } catch (error) {
                showError('Error processing QR code: ' + error.message);
            }
        };
    });
}

function importCardFromQR(card) {
    // Add card to state and render
    state.cards.push(card);
    const cardEl = renderCard(card);
    document.getElementById('cards-container').appendChild(cardEl);
    cardEl.scrollIntoView({ behavior: 'smooth' });
    saveState();
    showError('Funding period imported successfully!');
}

function continueFromQR(card) {
    // Create next period from the QR data
    const newCard = createCard(card);
    state.cards.push(newCard);
    const cardEl = renderCard(newCard);
    document.getElementById('cards-container').appendChild(cardEl);
    cardEl.scrollIntoView({ behavior: 'smooth' });
    saveState();
    showError('Next funding period created successfully!');
}

async function generateInvoiceFromQR(card) {
    // Show date range selector (simplified for now - uses full period)
    if (confirm('Generate invoice for the full period?')) {
        showLoading('Generating invoice...');
        try {
            await generateInvoiceReport(card);
            hideLoading();
        } catch (error) {
            hideLoading();
            showError('Error generating invoice: ' + error.message);
        }
    }
}

function viewReportFromQR(card) {
    // Generate and display a read-only PDF
    showLoading('Generating report...');
    generatePDFReport(card).then(() => {
        hideLoading();
    }).catch(error => {
        hideLoading();
        showError('Error generating report: ' + error.message);
    });
}

// ===== Multi-Period Report Functions =====
async function generateMultiPeriodReport() {
    if (state.cards.length === 0) {
        showError('No funding periods to report on');
        return;
    }
    
    if (state.cards.length === 1) {
        // Just generate single report
        await generatePDFReport(state.cards[0]);
        return;
    }
    
    showLoading('Generating multi-period report...');
    
    try {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        
        const pageWidth = doc.internal.pageSize.getWidth();
        const pageHeight = doc.internal.pageSize.getHeight();
        const margin = 20;
        const contentWidth = pageWidth - (margin * 2);
        
        let y = margin;
        
        // Helper functions (reuse from single report)
        const ensureSpace = (needed = 10) => {
            if (y + needed > pageHeight - 25) {
                doc.addPage();
                y = margin;
                return true;
            }
            return false;
        };
        
        // Colors
        const primaryColor = [37, 99, 235];
        const grayColor = [128, 128, 128];
        const errorColor = [239, 68, 68];
        const lightGray = [248, 249, 250];
        
        // Title page with header
        
        // Generate QR Code for multi-period data
        let qrCodeDataUrl = null;
        try {
            // Create combined data for QR
            const multiPeriodData = {
                v: 2, // Version 2 for multi-period
                periods: state.cards.map(card => buildQRData(card))
            };
            qrCodeDataUrl = await generateQRCode(JSON.stringify(multiPeriodData));
        } catch (error) {
            console.error('Error generating multi-period QR code:', error);
        }
        
        // Logo on left
        try {
            const logoBase64 = await getBase64FromUrl('https://gqchhsayqxttewthcsah.supabase.co/storage/v1/object/public/Branding/LOGO%20No%20Background.png');
            const logoHeight = 20;
            const logoWidth = logoHeight * 4;
            doc.addImage(logoBase64, 'PNG', margin, y, logoWidth, logoHeight, undefined, 'FAST');
            
            // Company details under logo
            doc.setFontSize(9);
            doc.setFont(undefined, 'normal');
            doc.setTextColor(...grayColor);
            doc.text('ABN: 34 787 739 579', margin, y + 25);
            doc.text('Email: admin@mycarers.com.au', margin, y + 30);
            doc.text('S2, Lvl 6, 12 Railway Pde, Burwood, NSW 2134', margin, y + 35);
            doc.setTextColor(0, 0, 0);
        } catch (e) {
            doc.setFontSize(20);
            doc.setFont(undefined, 'bold');
            doc.setTextColor(...primaryColor);
            doc.text('MY CARERS', margin, y + 10);
            doc.setTextColor(0, 0, 0);
        }
        
        // QR Code on right
        if (qrCodeDataUrl) {
            const qrSize = 40;
            doc.addImage(qrCodeDataUrl, 'PNG', pageWidth - margin - qrSize, y, qrSize, qrSize);
            
            // QR Code label
            doc.setFontSize(7);
            doc.setTextColor(...grayColor);
            doc.text('Scan for all periods', pageWidth - margin - qrSize/2, y + qrSize + 3, { align: 'center' });
            doc.setTextColor(0, 0, 0);
        }
        
        // Separator line
        y += 45;
        doc.setDrawColor(...grayColor);
        doc.setLineWidth(0.5);
        doc.line(margin, y, pageWidth - margin, y);
        y += 20;
        
        // Title
        doc.setFontSize(28);
        doc.setFont(undefined, 'bold');
        doc.text('Multi-Period Funding Report', pageWidth / 2, y, { align: 'center' });
        
        doc.setFontSize(14);
        doc.setFont(undefined, 'normal');
        doc.setTextColor(...grayColor);
        const participantName = state.cards[0].participant.name || 'Not specified';
        doc.text(`Participant: ${participantName}`, pageWidth / 2, y + 20, { align: 'center' });
        doc.text(`NDIS Number: ${state.cards[0].participant.ndisNumber || 'Not specified'}`, pageWidth / 2, y + 30, { align: 'center' });
        
        doc.setTextColor(0, 0, 0);
        
        // Executive Summary Table
        y = y + 60;
        doc.setFontSize(16);
        doc.setFont(undefined, 'bold');
        doc.text('Executive Summary', margin, y);
        y += 15;
        
        // Create summary table
        await createExecutiveSummaryTable(doc, margin, y, contentWidth);
        
        // Generate individual period reports
        doc.addPage();
        
        for (let i = 0; i < state.cards.length; i++) {
            if (i > 0) doc.addPage();
            
            // Generate period header
            y = margin;
            doc.setFontSize(18);
            doc.setFont(undefined, 'bold');
            doc.text(`Period ${i + 1} of ${state.cards.length}`, margin, y);
            y += 10;
            
            // Use modified single report generation
            await generatePeriodSection(doc, state.cards[i], i + 1);
        }
        
        // Save with appropriate filename
        const safeName = participantName.replace(/[^a-zA-Z0-9]/g, '_');
        doc.save(`Multi_Period_Report_${safeName}.pdf`);
        
        hideLoading();
    } catch (error) {
        hideLoading();
        showError('Error generating multi-period report: ' + error.message);
    }
}

async function createExecutiveSummaryTable(doc, x, y, width) {
    const headers = ['Period', 'Dates', 'Budget', 'Used', 'Remaining'];
    const colWidths = [10, 35, 20, 20, 15]; // Adjusted widths without status column
    
    const data = [];
    
    // Prepare data rows
    state.cards.forEach((card, index) => {
        const totals = computeCardTotals(card);
        const used = totals.usedCents / 100;
        
        let available, remaining;
        
        if (card.settings.calculateByGroup) {
            available = totals.totalAvailableCents / 100;
            remaining = totals.totalRemainingCents / 100;
        } else {
            const totalBudget = parseFloat(card.budget.total) || 0;
            const carryOver = parseFloat(card.budget.carryOver) || 0;
            const excluded = parseFloat(card.budget.excluded) || 0;
            available = totalBudget + carryOver - excluded;
            remaining = available - used;
        }
        
        data.push([
            `${index + 1}`,
            `${formatDateDDMMYYYY(card.period.start)} - ${formatDateDDMMYYYY(card.period.end)}`,
            formatCurrency(available),
            formatCurrency(used),
            formatCurrency(remaining)
        ]);
    });
    
    // Calculate grand totals
    let grandBudget = 0;
    let grandUsed = 0;
    
    state.cards.forEach(card => {
        const totals = computeCardTotals(card);
        const used = totals.usedCents / 100;
        
        let available;
        if (card.settings.calculateByGroup) {
            available = totals.totalAvailableCents / 100;
        } else {
            const totalBudget = parseFloat(card.budget.total) || 0;
            const carryOver = parseFloat(card.budget.carryOver) || 0;
            const excluded = parseFloat(card.budget.excluded) || 0;
            available = totalBudget + carryOver - excluded;
        }
        
        grandBudget += available;
        grandUsed += used;
    });
    
    // Add total row
    data.push([
        'TOTAL',
        '',
        formatCurrency(grandBudget),
        formatCurrency(grandUsed),
        formatCurrency(grandBudget - grandUsed)
    ]);
    
    // Use autoTable for clean formatting
    doc.autoTable({
        startY: y,
        head: [headers],
        body: data,
        margin: { left: x, right: 20 },
        columnStyles: {
            0: { cellWidth: (width * colWidths[0]) / 100, halign: 'center' },
            1: { cellWidth: (width * colWidths[1]) / 100 },
            2: { cellWidth: (width * colWidths[2]) / 100, halign: 'right' },
            3: { cellWidth: (width * colWidths[3]) / 100, halign: 'right' },
            4: { cellWidth: (width * colWidths[4]) / 100, halign: 'right' }
        },
        styles: {
            fontSize: 8,
            cellPadding: 3
        },
        headStyles: {
            fillColor: [37, 99, 235],
            textColor: [255, 255, 255],
            fontStyle: 'bold'
        },
        alternateRowStyles: {
            fillColor: [248, 249, 250]
        },
        didDrawCell: (data) => {
            // Bold and highlight total row
            if (data.row.index === state.cards.length) {
                doc.setFillColor(37, 99, 235);
                doc.setTextColor(255, 255, 255);
                doc.setFont(undefined, 'bold');
            }
            // Highlight negative remaining in red
            if (data.column.index === 4 && data.row.index < state.cards.length) {
                const value = parseFloat(data.cell.raw.replace(/[$,]/g, ''));
                if (value < 0) {
                    doc.setTextColor(239, 68, 68);
                }
            }
        }
    });
    
    return doc.lastAutoTable.finalY + 10;
}

async function generatePeriodSection(doc, card, periodNumber) {
    // This is a simplified version of the single report
    // Reuses much of the existing generatePDFReport logic but adapted for multi-period context
    
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const margin = 20;
    const contentWidth = pageWidth - (margin * 2);
    const yLimit = pageHeight - 25;
    
    let y = 40; // Start lower since we have the period header
    
    // Helper functions
    const ensureSpace = (needed = 10) => {
        if (y + needed > yLimit) {
            doc.addPage();
            y = margin;
            return true;
        }
        return false;
    };
    
    const totals = computeCardTotals(card);
    const used = totals.usedCents / 100;
    const totalBudget = parseFloat(card.budget.total) || 0;
    const carryOver = parseFloat(card.budget.carryOver) || 0;
    const excluded = parseFloat(card.budget.excluded) || 0;
    const available = totalBudget + carryOver - excluded;
    const remaining = available - used;
    
    // Colors
    const primaryColor = [37, 99, 235];
    const grayColor = [128, 128, 128];
    
    // Period dates
    doc.setFontSize(11);
    doc.setFont(undefined, 'normal');
    const startDate = new Date(card.period.start);
    const endDate = new Date(card.period.end);
    doc.text(`Period: ${startDate.toLocaleDateString('en-AU')} to ${endDate.toLocaleDateString('en-AU')}`, margin, y);
    y += 15;
    
    // Budget Summary
    doc.setFontSize(12);
    doc.setFont(undefined, 'bold');
    doc.text('Budget Summary', margin, y);
    y += 10;
    
    // Use the enhanced table format for budget
    await createBudgetTable(doc, card, margin, y, contentWidth);
    y += 60;
    
    // Support Groups with enhanced tables
    ensureSpace(30);
    doc.setFontSize(12);
    doc.setFont(undefined, 'bold');
    doc.text('Support Items', margin, y);
    y += 10;
    
    for (const group of card.groups) {
        const groupTotal = (totals.perGroupCents[group.regGroupNumber] || 0) / 100;
        if (groupTotal > 0) {
            ensureSpace(40);
            await createSupportGroupTable(doc, group, card, margin, y, contentWidth);
            y = doc.lastAutoTable.finalY + 10;
        }
    }
}

async function createBudgetTable(doc, card, x, y, width) {
    const totals = computeCardTotals(card);
    const used = totals.usedCents / 100;
    const totalBudget = parseFloat(card.budget.total) || 0;
    const carryOver = parseFloat(card.budget.carryOver) || 0;
    const excluded = parseFloat(card.budget.excluded) || 0;
    const available = totalBudget + carryOver - excluded;
    const remaining = available - used;
    
    const data = [
        ['Total Budget', formatCurrency(totalBudget)],
        ['Carry Over', formatCurrency(carryOver)],
        ['Excluded', formatCurrency(excluded)],
        ['Available', formatCurrency(available)],
        ['Used', formatCurrency(used)],
        ['Remaining', formatCurrency(remaining)]
    ];
    
    doc.autoTable({
        startY: y,
        head: [],
        body: data,
        margin: { left: x, right: 20 },
        tableWidth: 'auto',
        columnStyles: {
            0: { cellWidth: 80 },
            1: { cellWidth: 50, halign: 'right' }
        },
        styles: {
            fontSize: 10,
            cellPadding: 3
        },
        alternateRowStyles: {
            fillColor: [248, 249, 250]
        },
        didDrawCell: (data) => {
            // Highlight negative remaining in red
            if (data.row.index === 5 && remaining < 0) {
                doc.setTextColor(239, 68, 68);
            }
        }
    });
}

async function createGroupBudgetSummaryTable(doc, card, x, y, width) {
    const totals = computeCardTotals(card);
    const data = [];
    let grandTotal = 0;
    let grandUsed = 0;
    let grandRemaining = 0;
    
    // Add each group's budget info
    card.groups.forEach(group => {
        if (group.budget) {
            const groupTotal = parseFloat(group.budget.total) || 0;
            const groupCarryOver = parseFloat(group.budget.carryOver) || 0;
            const groupExcluded = parseFloat(group.budget.excluded) || 0;
            const groupAvailable = groupTotal + groupCarryOver - groupExcluded;
            const groupUsed = (totals.perGroupCents[group.regGroupNumber] || 0) / 100;
            const groupRemaining = groupAvailable - groupUsed;
            
            grandTotal += groupAvailable;
            grandUsed += groupUsed;
            grandRemaining += groupRemaining;
            
            data.push([
                group.regGroupName,
                formatCurrency(groupAvailable),
                formatCurrency(groupUsed),
                formatCurrency(groupRemaining)
            ]);
        }
    });
    
    // Add total row
    data.push([
        'TOTAL',
        formatCurrency(grandTotal),
        formatCurrency(grandUsed),
        formatCurrency(grandRemaining)
    ]);
    
    doc.autoTable({
        startY: y,
        head: [['Support Group', 'Budget', 'Used', 'Remaining']],
        body: data,
        margin: { left: x, right: 20 },
        columnStyles: {
            0: { cellWidth: 70 },
            1: { cellWidth: 35, halign: 'right' },
            2: { cellWidth: 35, halign: 'right' },
            3: { cellWidth: 35, halign: 'right' }
        },
        styles: {
            fontSize: 9,
            cellPadding: 3
        },
        headStyles: {
            fillColor: [37, 99, 235],
            textColor: [255, 255, 255]
        },
        didDrawCell: (data) => {
            // Highlight negative remaining in red
            if (data.column.index === 3) {
                const value = parseFloat(data.cell.raw.replace(/[$,]/g, ''));
                if (value < 0) {
                    doc.setTextColor(239, 68, 68);
                }
            }
            // Bold total row
            if (data.row.index === card.groups.filter(g => g.budget).length) {
                doc.setFont(undefined, 'bold');
            }
        }
    });
}

async function createSupportGroupTable(doc, group, card, x, y, width) {
    const groupTotal = computeGroupTotal(group, card);
    
    // Group header
    doc.setFontSize(11);
    doc.setFont(undefined, 'bold');
    doc.text(group.regGroupName, x, y);
    doc.setFont(undefined, 'normal');
    doc.setFontSize(9);
    doc.text(`(${group.regGroupNumber}) - Total: ${formatCurrency(groupTotal)}`, x, y + 5);
    y += 10;
    
    // Create table data
    const tableData = [];
    
    group.items.forEach(item => {
        if (!item.selected) return;
        
        const usage = getItemUsageDescription(item);
        if (usage === 'No hours set' || usage === 'No days selected' || usage === 'No quantity set') return;
        
        let quantity = 0;
        let rate = item.statePrice || 0;
        let total = 0;
        
        if (item.unit === 'H') {
            // Calculate total hours
            Object.values(item.hours || {}).forEach(h => quantity += h);
            // Multiply by weeks in period
            const weeks = Math.ceil((new Date(card.period.end) - new Date(card.period.start)) / (7 * 24 * 60 * 60 * 1000));
            quantity *= weeks;
            total = quantity * rate;
        } else if (item.unit === 'E') {
            quantity = item.quantity || 1;
            total = quantity * rate;
        }
        
        tableData.push([
            item.supportItemName,
            item.supportItemNumber,
            usage,
            `${quantity} ${item.unit === 'H' ? 'hrs' : 'ea'}`,
            formatCurrency(rate),
            formatCurrency(total)
        ]);
    });
    
    if (tableData.length > 0) {
        doc.autoTable({
            startY: y,
            head: [['Item', 'Code', 'Schedule', 'Quantity', 'Rate', 'Total']],
            body: tableData,
            margin: { left: x },
            columnStyles: {
                0: { cellWidth: 45 },
                1: { cellWidth: 20 },
                2: { cellWidth: 30 },
                3: { cellWidth: 16 },
                4: { cellWidth: 16, halign: 'right' },
                5: { cellWidth: 20, halign: 'right' }
            },
            styles: {
                fontSize: 8,
                cellPadding: 2
            },
            headStyles: {
                fillColor: [37, 99, 235],
                textColor: [255, 255, 255]
            }
        });
    }
}

function computeGroupTotal(group, card) {
    let total = 0;
    group.items.forEach(item => {
        if (!item.selected) return;
        
        const rate = item.statePrice || 0;
        
        if (item.unit === 'H' && item.hours) {
            let weeklyHours = 0;
            Object.values(item.hours).forEach(h => weeklyHours += h);
            const weeks = Math.ceil((new Date(card.period.end) - new Date(card.period.start)) / (7 * 24 * 60 * 60 * 1000));
            total += weeklyHours * weeks * rate;
        } else if (item.unit === 'E') {
            const quantity = item.quantity || 0;
            total += quantity * rate;
        }
    });
    return total;
}

// ===== Invoice Generation =====
async function generateInvoiceReport(card) {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();
    
    // Similar structure to PDF report but formatted as invoice
    // This is a simplified version - you can enhance with more invoice-specific formatting
    
    const pageWidth = doc.internal.pageSize.getWidth();
    const margin = 20;
    const contentWidth = pageWidth - (margin * 2);
    
    let y = margin;
    
    // Invoice header
    doc.setFontSize(24);
    doc.setFont(undefined, 'bold');
    doc.text('TAX INVOICE', margin, y);
    
    // Generate invoice number based on date
    const invoiceNum = `INV-${new Date().getFullYear()}-${String(Math.floor(Math.random() * 10000)).padStart(4, '0')}`;
    doc.setFontSize(12);
    doc.setFont(undefined, 'normal');
    doc.text(`Invoice #: ${invoiceNum}`, pageWidth - margin, y, { align: 'right' });
    
    y += 30;
    
    // Billing details
    doc.setFontSize(10);
    doc.text('Bill To:', margin, y);
    y += 5;
    doc.setFont(undefined, 'bold');
    doc.text(card.participant.name || 'Not specified', margin, y);
    y += 5;
    doc.setFont(undefined, 'normal');
    doc.text(`NDIS Number: ${card.participant.ndisNumber || 'Not specified'}`, margin, y);
    
    y += 20;
    
    // Invoice details table
    const headers = [['Description', 'Quantity', 'Rate', 'Amount']];
    const data = [];
    
    card.groups.forEach(group => {
        group.items.forEach(item => {
            if (!item.selected) return;
            
            let quantity = 0;
            let rate = item.statePrice || 0;
            
            if (item.unit === 'H' && item.hours) {
                Object.values(item.hours).forEach(h => quantity += h);
                const weeks = Math.ceil((new Date(card.period.end) - new Date(card.period.start)) / (7 * 24 * 60 * 60 * 1000));
                quantity *= weeks;
            } else if (item.unit === 'E') {
                quantity = item.quantity || 0;
            }
            
            if (quantity > 0) {
                data.push([
                    `${item.supportItemName}\n(${item.supportItemNumber})`,
                    `${quantity} ${item.unit === 'H' ? 'hours' : 'each'}`,
                    formatCurrency(rate),
                    formatCurrency(quantity * rate)
                ]);
            }
        });
    });
    
    doc.autoTable({
        startY: y,
        head: headers,
        body: data,
        margin: { left: margin },
        columnStyles: {
            0: { cellWidth: 80 },
            1: { cellWidth: 30 },
            2: { cellWidth: 30, halign: 'right' },
            3: { cellWidth: 30, halign: 'right' }
        },
        styles: {
            fontSize: 9
        },
        headStyles: {
            fillColor: [37, 99, 235]
        }
    });
    
    // Total
    const total = calculateUsedBudget(card);
    y = doc.lastAutoTable.finalY + 10;
    
    doc.setFont(undefined, 'bold');
    doc.text('Total:', pageWidth - margin - 40, y);
    doc.text(formatCurrency(total), pageWidth - margin, y, { align: 'right' });
    
    // Save
    const safeName = card.participant.name ? card.participant.name.replace(/[^a-zA-Z0-9]/g, '_') : 'Invoice';
    doc.save(`${safeName}_${invoiceNum}.pdf`);
}

// ===== Enhanced PDF Report with QR Code =====
// Update the existing generatePDFReport function
const originalGeneratePDFReport = generatePDFReport;

async function generatePDFReport(card) {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();
    
    // Page settings
    const pageWidth = doc.internal.pageSize.getWidth();
    const pageHeight = doc.internal.pageSize.getHeight();
    const margin = 20;
    const contentWidth = pageWidth - (margin * 2);
    const yLimit = pageHeight - 25; // Leave space for footer
    
    let y = margin; // Start at top margin
    
    // Helper functions
    const ensureSpace = (needed = 10) => {
        if (y + needed > yLimit) {
            addPageNumber();
            doc.addPage();
            y = margin;
            return true; // Indicates new page was created
        }
        return false;
    };
    
    const addPageNumber = () => {
        const pageNum = doc.internal.getCurrentPageInfo().pageNumber;
        doc.setFontSize(9);
        doc.setFont(undefined, 'normal');
        doc.setTextColor(128, 128, 128);
        doc.text(`Page ${pageNum}`, pageWidth / 2, pageHeight - 10, { align: 'center' });
        doc.setTextColor(0, 0, 0);
    };
    
    // Calculate data with safe numbers
    const totals = computeCardTotals(card);
    const used = totals.usedCents / 100;
    const totalBudget = parseFloat(card.budget.total) || 0;
    const carryOver = parseFloat(card.budget.carryOver) || 0;
    const excluded = parseFloat(card.budget.excluded) || 0;
    const available = totalBudget + carryOver - excluded;
    const remaining = available - used;
    const weeks = Math.max(1, totals.weeks);
    const weekly = used / weeks;
    
    // Colors
    const primaryColor = [37, 99, 235];
    const grayColor = [128, 128, 128];
    const errorColor = [239, 68, 68];
    const lightGray = [248, 249, 250];
    
    // Generate QR Code
    let qrCodeDataUrl = null;
    try {
        const qrData = buildQRData(card);
        qrCodeDataUrl = await generateQRCode(qrData);
    } catch (error) {
        console.error('Error generating QR code:', error);
    }
    
    // HEADER SECTION
    // Logo on left
    try {
        const logoBase64 = await getBase64FromUrl('https://gqchhsayqxttewthcsah.supabase.co/storage/v1/object/public/Branding/LOGO%20No%20Background.png');
        const logoHeight = 20;
        const logoWidth = logoHeight * 4; // Adjust ratio as needed
        doc.addImage(logoBase64, 'PNG', margin, y, logoWidth, logoHeight, undefined, 'FAST');
        
        // Company details under logo
        doc.setFontSize(9);
        doc.setFont(undefined, 'normal');
        doc.setTextColor(...grayColor);
        doc.text('ABN: 34 787 739 579', margin, y + 25);
        doc.text('Email: admin@mycarers.com.au', margin, y + 30);
        doc.text('S2, Lvl 6, 12 Railway Pde, Burwood, NSW 2134', margin, y + 35);
        doc.setTextColor(0, 0, 0);
    } catch (e) {
        doc.setFontSize(20);
        doc.setFont(undefined, 'bold');
        doc.setTextColor(...primaryColor);
        doc.text('MY CARERS', margin, y + 10);
        doc.setTextColor(0, 0, 0);
        
        // Company details under text logo
        doc.setFontSize(9);
        doc.setFont(undefined, 'normal');
        doc.setTextColor(...grayColor);
        doc.text('ABN: 34 787 739 579', margin, y + 25);
        doc.text('Email: admin@mycarers.com.au', margin, y + 30);
        doc.text('S2, Lvl 6, 12 Railway Pde, Burwood, NSW 2134', margin, y + 35);
        doc.setTextColor(0, 0, 0);
    }
    
    // QR Code on right
    if (qrCodeDataUrl) {
        const qrSize = 40;
        doc.addImage(qrCodeDataUrl, 'PNG', pageWidth - margin - qrSize, y, qrSize, qrSize);
        
        // QR Code label
        doc.setFontSize(7);
        doc.setTextColor(...grayColor);
        doc.text('Scan for quick import', pageWidth - margin - qrSize/2, y + qrSize + 3, { align: 'center' });
        doc.setTextColor(0, 0, 0);
    }
    
    // Move down past header elements
    y += 50;
    
    // Continue with the rest of the original report...
    // (The rest of the function continues as before, but support groups now use tables)
    
    // Separator line
    doc.setDrawColor(...grayColor);
    doc.setLineWidth(0.5);
    doc.line(margin, y, pageWidth - margin, y);
    
    y += 15; // Space after line
    
    // TITLE SECTION
    doc.setFontSize(24);
    doc.setFont(undefined, 'bold');
    doc.text('NDIS Funding Report', pageWidth / 2, y, { align: 'center' });
    y += 12;
    
    doc.setFontSize(11);
    doc.setFont(undefined, 'normal');
    doc.setTextColor(...grayColor);
    const dateStr = new Date().toLocaleDateString('en-AU', { 
        day: 'numeric', 
        month: 'long', 
        year: 'numeric' 
    });
    doc.text(`Created: ${dateStr}`, pageWidth / 2, y, { align: 'center' });
    doc.setTextColor(0, 0, 0);
    y += 20;
    
    // PARTICIPANT INFO SECTION
    ensureSpace(50);
    
    // Background box
    doc.setFillColor(...lightGray);
    doc.roundedRect(margin - 5, y - 5, contentWidth + 10, 45, 3, 3, 'F');
    
    doc.setFontSize(12);
    doc.setFont(undefined, 'bold');
    doc.text('PARTICIPANT INFORMATION', margin, y + 3);
    y += 12;
    
    doc.setFontSize(10);
    doc.setFont(undefined, 'normal');
    const participantName = card.participant.name || 'Not specified';
    
    // Handle long names
    const nameLines = doc.splitTextToSize(`Name: ${participantName}`, contentWidth - 10);
    nameLines.forEach(line => {
        doc.text(line, margin, y);
        y += 6;
    });
    
    doc.text(`NDIS Number: ${card.participant.ndisNumber || 'Not specified'}`, margin, y);
    y += 6;
    
    // Period dates
    const startDate = new Date(card.period.start);
    const endDate = new Date(card.period.end);
    const periodText = `Period: ${startDate.toLocaleDateString('en-AU', { 
        day: 'numeric', month: 'long', year: 'numeric' 
    })} to ${endDate.toLocaleDateString('en-AU', { 
        day: 'numeric', month: 'long', year: 'numeric' 
    })}`;
    
    doc.text(periodText, margin, y);
    y += 6;
    doc.text(`State: ${card.state}`, margin, y);
    y += 20; // Extra space after section
    
    // PERIOD BREAKDOWN SECTION
    ensureSpace(50);
    doc.setFontSize(12);
    doc.setFont(undefined, 'bold');
    doc.text('PERIOD BREAKDOWN', margin, y);
    y += 10;

    const dayCount = countDaysInPeriod(startDate, endDate);
    const phInPeriod = state.publicHolidays.filter(ph => {
        const phDate = new Date(ph.date);
        return phDate >= startDate && phDate <= endDate;
    });

    // Day grid with better spacing
    doc.setFontSize(10);
    const gridStartY = y;
    const colWidth = contentWidth / 4;
    const rowHeight = 15;

    const dayData = [
        ['Monday', dayCount.Mon], 
        ['Tuesday', dayCount.Tue], 
        ['Wednesday', dayCount.Wed], 
        ['Thursday', dayCount.Thu],
        ['Friday', dayCount.Fri], 
        ['Saturday', dayCount.Sat], 
        ['Sunday', dayCount.Sun], 
        ['Public Holidays', phInPeriod.length]
    ];

    dayData.forEach((item, index) => {
        const col = index % 4;
        const row = Math.floor(index / 4);
        const xPos = margin + (col * colWidth);
        const yPos = gridStartY + (row * rowHeight);
        
        // Draw the label
        doc.setFont(undefined, 'normal');
        doc.text(`${item[0]}:`, xPos, yPos);
        
        // Calculate where to place the number - use text width
        const labelWidth = doc.getTextWidth(`${item[0]}:`);
        const numberX = xPos + labelWidth + 3; // 3px spacing after colon
        
        doc.setFont(undefined, 'bold');
        doc.setTextColor(...primaryColor);
        doc.text(item[1].toString(), numberX, yPos);
        doc.setTextColor(0, 0, 0);
    });

    y = gridStartY + (2 * rowHeight) + 15; // Move past grid with spacing

    
    // BUDGET SUMMARY SECTION with Table
    ensureSpace(80);
    doc.setFontSize(12);
    doc.setFont(undefined, 'bold');
    doc.text('BUDGET SUMMARY', margin, y);
    y += 10;
    
    // Use table for budget summary
    if (card.settings.calculateByGroup) {
        // Show group budget summary
        await createGroupBudgetSummaryTable(doc, card, margin, y, contentWidth);
    } else {
        // Show overall budget summary
        await createBudgetTable(doc, card, margin, y, contentWidth);
    }
    y = doc.lastAutoTable.finalY + 30; // Increased spacing from 20 to 30
    
    // WEEKLY BREAKDOWN SECTION (Enhanced with table)
    ensureSpace(30);
    doc.setFontSize(12);
    doc.setFont(undefined, 'bold');
    doc.text('WEEKLY COST BREAKDOWN', margin, y);
    y += 10;
    
    const weeklyData = [];
    let weeklyTotal = 0;
    
    card.groups.forEach(group => {
        group.items.forEach(item => {
            if (!item.selected || item.unit !== 'H' || !item.hours) return;
            
            let itemWeeklyTotal = 0;
            let hoursDetail = [];
            
            // Collect hours
            if (item.hours.weekday > 0) {
                itemWeeklyTotal += item.hours.weekday * 5;
                hoursDetail.push(`Mon-Fri: ${item.hours.weekday}h each`);
            } else {
                ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].forEach(day => {
                    if (item.hours[day] > 0) {
                        itemWeeklyTotal += item.hours[day];
                        hoursDetail.push(`${day}: ${item.hours[day]}h`);
                    }
                });
            }
            
            if (item.hours.saturday > 0 && !item.hours.Mon) {
                itemWeeklyTotal += item.hours.saturday;
                hoursDetail.push(`Sat: ${item.hours.saturday}h`);
            }
            
            if (item.hours.sunday > 0 && !item.hours.Mon) {
                itemWeeklyTotal += item.hours.sunday;
                hoursDetail.push(`Sun: ${item.hours.sunday}h`);
            }
            
            if (itemWeeklyTotal > 0) {
                const rate = item.statePrice || 0;
                const weeklyItemCost = itemWeeklyTotal * rate;
                weeklyTotal += weeklyItemCost;
                
                weeklyData.push([
                    item.supportItemName,
                    item.supportItemNumber,
                    hoursDetail.join(', '),
                    `${itemWeeklyTotal}h`,
                    formatCurrency(rate),
                    formatCurrency(weeklyItemCost)
                ]);
            }
        });
    });
    
    if (weeklyData.length > 0) {
        doc.autoTable({
            startY: y,
            head: [['Service', 'Code', 'Schedule', 'Total Hrs', 'Rate', 'Weekly Cost']],
            body: weeklyData,
            foot: [['', '', '', 'Total:', '', formatCurrency(weeklyTotal)]],
            margin: { left: margin },
            columnStyles: {
                0: { cellWidth: 45 },
                1: { cellWidth: 20 },
                2: { cellWidth: 45 },
                3: { cellWidth: 18, halign: 'center' },
                4: { cellWidth: 18, halign: 'right' },
                5: { cellWidth: 22, halign: 'right' }
            },
            styles: {
                fontSize: 8,
                cellPadding: 2
            },
            headStyles: {
                fillColor: [...primaryColor],
                textColor: [255, 255, 255]
            },
            footStyles: {
                fillColor: [...lightGray],
                textColor: [0, 0, 0],
                fontStyle: 'bold'
            }
        });
        y = doc.lastAutoTable.finalY + 15;
    }
    
    // SUPPORT GROUPS SECTION (Enhanced with tables)
    ensureSpace(30);
    doc.setFontSize(12);
    doc.setFont(undefined, 'bold');
    doc.text('SUPPORT GROUPS BREAKDOWN', margin, y);
    y += 10;
    
    let hasGroups = false;
    
    for (const group of card.groups) {
        const groupTotal = (totals.perGroupCents[group.regGroupNumber] || 0) / 100;
        
        // Check if group has selected items with data
        const hasSelectedItems = group.items.some(item => {
            if (!item.selected) return false;
            
            if (item.unit === 'H' && item.hours) {
                return Object.values(item.hours).some(h => h > 0);
            } else if (item.unit === 'E') {
                return item.quantity > 0 || (item.days && Object.values(item.days).some(d => d));
            }
            return false;
        });
        
        if (hasSelectedItems) {
            hasGroups = true;
            ensureSpace(40);
            
            await createSupportGroupTable(doc, group, card, margin, y, contentWidth);
            y = doc.lastAutoTable ? doc.lastAutoTable.finalY + 15 : y + 15;
        }
    }
    
    if (!hasGroups) {
        doc.setFontSize(10);
        doc.setFont(undefined, 'normal');
        doc.text('No support items with hours/quantities entered', margin, y);
        y += 15;
    }
    
    // NOTES SECTION
    if (card.notes && card.notes.trim()) {
        ensureSpace(30);
        doc.setFontSize(12);
        doc.setFont(undefined, 'bold');
        doc.text('NOTES & ASSUMPTIONS', margin, y);
        y += 8;
        
        doc.setFontSize(10);
        doc.setFont(undefined, 'normal');
        const noteLines = doc.splitTextToSize(card.notes, contentWidth);
        noteLines.forEach(line => {
            ensureSpace(6);
            doc.text(line, margin, y);
            y += 5;
        });
        y += 10;
    }
    
    // PUBLIC HOLIDAYS SECTION
    ensureSpace(30);
    doc.setFontSize(12);
    doc.setFont(undefined, 'bold');
    doc.text(`PUBLIC HOLIDAYS ${card.settings.includePH ? 'INCLUDED' : 'EXCLUDED'}`, margin, y);
    y += 8;
    
    doc.setFontSize(10);
    doc.setFont(undefined, 'normal');
    
    if (phInPeriod.length > 0) {
        doc.text('Public holidays in this period:', margin, y);
        y += 6;
        
        phInPeriod.forEach(ph => {
            ensureSpace(6);
            const phDate = new Date(ph.date);
            const phDateStr = phDate.toLocaleDateString('en-AU', { 
                day: 'numeric', 
                month: 'long', 
                year: 'numeric' 
            });
            doc.text(`• ${phDateStr} - ${ph.name}`, margin + 5, y);
            y += 5;
        });
    } else {
        doc.text('No public holidays within this period', margin, y);
    }
    
    // SIGNATURE SECTION (NEW)
    ensureSpace(50);
    y += 20;
    doc.setLineWidth(0.5);
    doc.line(margin, y, margin + 60, y);
    doc.line(pageWidth - margin - 60, y, pageWidth - margin, y);
    
    doc.setFontSize(9);
    doc.text('Participant Signature', margin, y + 5);
    doc.text('Date', pageWidth - margin - 60, y + 5);
    
    // Add page number to final page
    addPageNumber();
    
    // Save PDF with sanitized filename
    const safeName = participantName.replace(/[^a-zA-Z0-9]/g, '_');
    doc.save(`NDIS_Report_${safeName}.pdf`);
}

// ===== Constants =====
const STORAGE_KEYS = {
    CARDS: 'ndisCalc.cards.v1',
    CATALOGUE: 'ndisCalc.catalogue.v1',
    PREFERENCES: 'ndisCalc.prefs.v1',
    PUBLIC_HOLIDAYS: 'ndisCalc.holidays.v1'
};

async function fetchPublicHolidays() {
    try {
        const { data, error } = await supabaseClient
            .from('public_holidays')
            .select('date, name')
            .order('date');
        
        if (error) throw error;
        return data || [];
    } catch (error) {
        console.error('Error fetching holidays:', error);
        return [];
    }
}
// ===== Utility Functions =====
function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

function formatDateDDMMYYYY(date) {
    const d = new Date(date);
    const day = String(d.getDate()).padStart(2, '0');
    const month = String(d.getMonth() + 1).padStart(2, '0');
    const year = d.getFullYear();
    return `${day}-${month}-${year}`;
}

function parseDate(dateStr) {
    // Handle both yyyy-mm-dd and dd-mm-yyyy formats
    if (dateStr.includes('-')) {
        const parts = dateStr.split('-');
        if (parts[0].length === 4) {
            // yyyy-mm-dd
            return new Date(dateStr);
        } else {
            // dd-mm-yyyy
            return new Date(`${parts[2]}-${parts[1]}-${parts[0]}`);
        }
    }
    return new Date(dateStr);
}



function getDayOfWeek(date) {
    const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    return days[date.getDay()];
}

function isWeekday(date) {
    const day = date.getDay();
    return day >= 1 && day <= 5;
}

function isSaturday(date) {
    return date.getDay() === 6;
}

function isSunday(date) {
    return date.getDay() === 0;
}



function validateHours(value) {
    const num = parseFloat(value);
    if (isNaN(num) || num < 0) return 0;
    // Round to nearest 0.5
    return Math.round(num * 2) / 2;
}

function sanitizeFilename(filename) {
    return filename.replace(/[^a-zA-Z0-9_\-]/g, '_');
}

async function fetchCatalogueFromSupabase() {
    try {
        showLoading('Loading NDIS Catalogue...');
        
        const { data, error } = await supabaseClient
            .from('ndis_support_catalogue')
            .select('*');
        
        if (error) {
            throw error;
        }
        
        if (!data || data.length === 0) {
            throw new Error('No data found in catalogue');
        }
        
        // Transform Supabase data into the catalogue format
        const catalogue = {};
        
        data.forEach(row => {
            const regGroupNumber = row['Registration Group Number'];
            const regGroupName = row['Registration Group Name'];
            
            if (!regGroupNumber) return;
            
            if (!catalogue[regGroupNumber]) {
                catalogue[regGroupNumber] = {
                    regGroupNumber: regGroupNumber.toString(),
                    regGroupName,
                    items: []
                };
            }
            
            // Parse prices
            const statePrices = {};
            ['ACT', 'NSW', 'NT', 'QLD', 'SA', 'TAS', 'VIC', 'WA'].forEach(state => {
                const price = parseFloat(row[state]);
                if (!isNaN(price)) {
                    statePrices[state] = price;
                }
            });
            
            // Get the current state's price for display
            const statePrice = statePrices[state.preferences.state] || statePrices['NSW'] || 0;
            
            const item = {
                supportItemNumber: row['Support Item Number'],
                supportItemName: row['Support Item Name'],
                unit: row['Unit'],
                statePrices,
                statePrice, // Add this for easier access
                remote: parseFloat(row['Remote']) || null,
                veryRemote: parseFloat(row['Very Remote']) || null,
                effectiveFrom: row['Start date'],
                effectiveTo: row['End Date'],
                flags: {
                    isPublicHoliday: row['Support Item Name'].toLowerCase().includes('public holiday'),
                    isSaturday: row['Support Item Name'].toLowerCase().includes('saturday'),
                    isSunday: row['Support Item Name'].toLowerCase().includes('sunday'),
                    isWeekday: row['Support Item Name'].toLowerCase().includes('weekday'),
                    isQuotable: (row['Quote'] || '').toLowerCase() === 'yes'
                }
            };
            
            catalogue[regGroupNumber].items.push(item);
        });
        
        hideLoading();
        return catalogue;
        
    } catch (error) {
        hideLoading();
        throw error;
    }
}

function parseCSVLine(line) {
    const values = [];
    let current = '';
    let inQuotes = false;
    
    for (let i = 0; i < line.length; i++) {
        const char = line[i];
        
        if (char === '"') {
            inQuotes = !inQuotes;
        } else if (char === ',' && !inQuotes) {
            values.push(current.trim());
            current = '';
        } else {
            current += char;
        }
    }
    
    values.push(current.trim());
    return values;
}

// ===== Catalogue Functions =====
function listRegistrationGroups(catalogue) {
    if (!catalogue) return [];
    
    return Object.keys(catalogue)
        .map(key => ({
            number: key,
            name: catalogue[key].regGroupName
        }))
        .sort((a, b) => a.name.localeCompare(b.name));
}

function getItemsByGroup(catalogue, regGroupNumber) {
    if (!catalogue || !catalogue[regGroupNumber]) return [];
    return catalogue[regGroupNumber].items;
}

// ===== Card Management =====
function createCard(previousCard = null) {
    const card = {
        id: generateUUID(),
        participant: {
            name: '',
            ndisNumber: ''
        },
        period: {
            start: '',
            end: ''
        },
        state: state.preferences.state,
        budget: {
            total: 0,
            excluded: 0,
            carryOver: 0  // This should be 0 for new cards
        },
        settings: {
            includePH: true,
            uplift: {
                enabled: true,
                percent: state.preferences.upliftPercent
            },
            calculateByGroup: false
        },
        notes: '',
        groups: []
    };
    
    if (previousCard) {

        // Continue from previous card
        const startDate = new Date(previousCard.period.end);
        startDate.setDate(startDate.getDate() + 1);
        
        const endDate = new Date(previousCard.period.end);
        const daysDiff = Math.ceil((new Date(previousCard.period.end) - new Date(previousCard.period.start)) / (1000 * 60 * 60 * 24)) + 1;
        endDate.setDate(endDate.getDate() + daysDiff);
        
        card.period.start = formatDateYYYYMMDD(startDate);
        card.period.end = formatDateYYYYMMDD(endDate);
        card.participant = { ...previousCard.participant };
        card.settings = JSON.parse(JSON.stringify(previousCard.settings));
        card.groups = JSON.parse(JSON.stringify(previousCard.groups));
        card.notes = previousCard.notes;
        
        // Handle carryover based on calculation mode
        if (previousCard.settings.calculateByGroup) {
            // Clear overall budget carryover
            card.budget.carryOver = 0;
            
            // Calculate carryover for each group
            const prevTotals = computeCardTotals(previousCard);
            card.groups.forEach(group => {
                if (group.budget) {
                    const prevGroup = previousCard.groups.find(g => g.regGroupNumber === group.regGroupNumber);
                    if (prevGroup && prevGroup.budget) {
                        const groupUsed = (prevTotals.perGroupCents[group.regGroupNumber] || 0) / 100;
                        const groupTotal = parseFloat(prevGroup.budget.total) || 0;
                        const groupCarryOver = parseFloat(prevGroup.budget.carryOver) || 0;
                        const groupExcluded = parseFloat(prevGroup.budget.excluded) || 0;
                        const groupAvailable = groupTotal + groupCarryOver - groupExcluded;
                        const groupRemaining = groupAvailable - groupUsed;
                        
                        // Set the carryover to the remaining amount
                        group.budget.carryOver = Math.round(groupRemaining * 100) / 100;
                    }
                }
            });
        } else {
            // Use overall budget carryover
            card.budget.carryOver = calculateRemainingBudget(previousCard);
        }
    }
    
    return card;
}

function formatDateYYYYMMDD(date) {
    return date.toISOString().split('T')[0];
}

function calculateUsedBudget(card) {
    const totals = computeCardTotals(card);
    return totals.usedCents / 100;
}

function calculateRemainingBudget(card) {
    const used = calculateUsedBudget(card);
    const available = card.budget.total + card.budget.carryOver - card.budget.excluded;
    return Math.round((available - used) * 100) / 100;
}

function calculateWeeklyEquivalent(card) {
    const totals = computeCardTotals(card);
    return (totals.usedCents / 100) / totals.weeks;
}

// ===== CSV Export =====
function buildCsvRows(card) {
    const rows = [];
    
    // Add metadata rows at the top
    rows.push('Metadata,Value');
    rows.push('ParticipantName,' + (card.participant.name || ''));
    rows.push('NDISNumber,' + (card.participant.ndisNumber || ''));
    rows.push('StartDate,' + card.period.start);
    rows.push('EndDate,' + card.period.end);
    rows.push('Budget,' + card.budget.total);
    rows.push('Excluded,' + card.budget.excluded);
    rows.push('CarryOver,' + card.budget.carryOver);
    rows.push('State,' + card.state);
    rows.push('IncludePublicHolidays,' + card.settings.includePH);
    rows.push('PriceUplift,' + card.settings.uplift.enabled);
    rows.push('UpliftPercent,' + card.settings.uplift.percent);
    rows.push('Notes,' + '"' + (card.notes || '').replace(/"/g, '""') + '"');
    rows.push('CalculateByGroup,' + card.settings.calculateByGroup);
    
    // Add group budget data if calculate by group is enabled
    if (card.settings.calculateByGroup) {
        rows.push(''); // Separator
        rows.push('GroupBudgets');
        rows.push('GroupNumber,GroupName,Budget,Excluded,CarryOver');
        card.groups.forEach(group => {
            if (group.budget) {
                rows.push([
                    group.regGroupNumber,
                    '"' + group.regGroupName.replace(/"/g, '""') + '"',
                    group.budget.total || 0,
                    group.budget.excluded || 0,
                    group.budget.carryOver || 0
                ].join(','));
            }
        });
    }
    
    rows.push(''); // Empty row separator
    
    // Original CSV headers
    rows.push('NDISNumber,SupportsDeliveredFrom,SupportsDeliveredTo,SupportNumber,Quantity,UnitPrice,GSTCode');
    
    // Keep all your existing logic for generating rows
    eachDateInclusive(card.period.start, card.period.end, (date) => {
        const isPH = isPublicHoliday(date, card.state);
        const dayOfWeek = getDayOfWeek(date);
        const dateStr = formatDateDDMMYYYY(date);
        
        card.groups.forEach(group => {
            group.items.forEach(item => {
                if (!item.selected) return;
                
                const isSleepover = isSleepoverItem(item);
                
                // Main gating logic with sleepover exception
                if (isPH) {
                    if (isSleepover) {
                        // Sleepover allowed on PH at standard rate
                    } else {
                        if (!card.settings.includePH) return;
                        if (!item.flags.isPublicHoliday) return;
                    }
                } else {
                    // Non-PH day
                    if (item.flags.isPublicHoliday) return;
                    if (item.flags.isWeekday && !isWeekday(date)) return;
                    if (item.flags.isSaturday && !isSaturday(date)) return;
                    if (item.flags.isSunday && !isSunday(date)) return;
                }
                
                const quantity = resolveQuantityForDate(item, date, dayOfWeek, { isPH, isSleepover });
                if (quantity <= 0) return;
                
                const unitPrice = getUnitPrice(item, card, date, { isPH, isSleepover });
                
                rows.push([
                    card.participant.ndisNumber || '',
                    dateStr,
                    dateStr,
                    item.supportItemNumber,
                    quantity.toFixed(2),
                    unitPrice.toFixed(2),
                    'P2'
                ].join(','));
            });
        });
    });
    
    return rows.join('\n');
}

function downloadCsv(filename, content) {
    const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    
    if (navigator.msSaveBlob) {
        navigator.msSaveBlob(blob, filename);
    } else {
        link.href = URL.createObjectURL(blob);
        link.download = filename;
        link.style.display = 'none';
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
}

// ===== Validation =====
function validateCard(card) {
    const errors = [];
    
    // Check dates
    if (!card.period.start || !card.period.end) {
        errors.push({
            message: 'Start and end dates are required',
            field: 'dates'
        });
    } else if (new Date(card.period.start) > new Date(card.period.end)) {
        errors.push({
            message: 'Start date must be before end date',
            field: 'dates'
        });
    }
    
    // Check items for missing prices
    card.groups.forEach((group, groupIndex) => {
        group.items.forEach((item, itemIndex) => {
            if (item.selected) {
                if (!item.overridePrice && !item.statePrice) {
                    errors.push({
                        message: `Missing price for: ${item.supportItemName}`,
                        field: 'price',
                        groupIndex,
                        itemIndex
                    });
                }
                
                // Check hours are valid
                if (item.hours) {
                    Object.entries(item.hours).forEach(([day, hours]) => {
                        if (hours % 0.5 !== 0) {
                            errors.push({
                                message: `Hours must be in 0.5 increments for: ${item.supportItemName}`,
                                field: 'hours',
                                groupIndex,
                                itemIndex
                            });
                        }
                    });
                }
            }
        });
    });
    
    return errors;
}

// ===== UI Functions =====
function showLoading(text = 'Loading...') {
    const overlay = document.getElementById('loading-overlay');
    const loadingText = overlay.querySelector('.loading-text');
    loadingText.textContent = text;
    overlay.style.display = 'flex';
}

function hideLoading() {
    document.getElementById('loading-overlay').style.display = 'none';
}

function updateLoadingProgress(percent) {
    const progressBar = document.querySelector('.loading-progress-bar');
    const percentText = document.querySelector('.loading-percent');
    progressBar.style.width = `${percent}%`;
    percentText.textContent = `${percent}%`;
}

function showError(message) {
    alert(message); // Simple alert for now
}

function showValidationErrors(errors) {
    const modal = document.getElementById('error-modal');
    const errorList = document.getElementById('error-list');
    
    errorList.innerHTML = '';
    
    errors.forEach(error => {
        const errorItem = document.createElement('div');
        errorItem.className = 'error-item';
        
        const errorMessage = document.createElement('div');
        errorMessage.className = 'error-message';
        errorMessage.textContent = error.message;
        errorItem.appendChild(errorMessage);
        
        if (error.field === 'price' || error.field === 'hours') {
            const errorAction = document.createElement('div');
            errorAction.className = 'error-action';
            errorAction.textContent = 'Jump to item';
            errorAction.onclick = () => {
                modal.classList.remove('show');
                // Scroll to the item
                const cards = document.querySelectorAll('.budget-card');
                const card = cards[0]; // For now, assume single card
                const groups = card.querySelectorAll('.group-panel');
                const group = groups[error.groupIndex];
                const items = group.querySelectorAll('.item-row');
                const item = items[error.itemIndex];
                item.scrollIntoView({ behavior: 'smooth', block: 'center' });
                item.classList.add('error');
                setTimeout(() => item.classList.remove('error'), 3000);
            };
            errorItem.appendChild(errorAction);
        }
        
        errorList.appendChild(errorItem);
    });
    
    modal.classList.add('show');
}

// ===== Card UI Rendering =====
function renderCard(card) {
    const template = document.getElementById('card-template');
    const cardEl = template.content.cloneNode(true).querySelector('.budget-card');
    
    cardEl.dataset.cardId = card.id;
    
    // Set initial values
    cardEl.querySelector('.participant-name').value = card.participant.name || '';
    cardEl.querySelector('.ndis-number').value = card.participant.ndisNumber || '';
    cardEl.querySelector('.start-date').value = card.period.start || '';
    cardEl.querySelector('.end-date').value = card.period.end || '';
    cardEl.querySelector('.budget-amount').value = card.budget.total || '';
    cardEl.querySelector('.excluded-amount').value = card.budget.excluded || '';
    cardEl.querySelector('.carry-in-amount').value = card.budget.carryOver || '';
    cardEl.querySelector('.include-ph').checked = card.settings.includePH;
    cardEl.querySelector('.july-uplift').checked = card.settings.uplift.enabled;
    cardEl.querySelector('.uplift-rate').value = card.settings.uplift.percent || 3.2;
    cardEl.querySelector('.calculate-by-group').checked = card.settings.calculateByGroup || false;
    
    // Apply calculate by group class if active
    if (card.settings.calculateByGroup) {
        cardEl.classList.add('calculate-by-group-active');
        // Ensure all group budget sections are visible
        setTimeout(() => {
            cardEl.querySelectorAll('.group-budget-section').forEach(section => {
                section.style.display = 'block';
            });
        }, 100);
    }
    cardEl.querySelector('.notes-input').value = card.notes || '';

    const stateSelect = cardEl.querySelector('.card-state');
    if (stateSelect) {
        stateSelect.value = card.state || state.preferences.state;
    }
    // Populate group selector
    const groupSelector = cardEl.querySelector('.group-selector');
    if (groupSelector) {
        const groups = listRegistrationGroups(state.catalogue);
        if (!groups || groups.length === 0) {
            const option = document.createElement('option');
            option.value = '';
            option.textContent = 'No groups available';
            groupSelector.appendChild(option);
        } else {
            groups.forEach(group => {
                const option = document.createElement('option');
                option.value = group.number;
                option.textContent = `${group.name} (${group.number})`;
                groupSelector.appendChild(option);
            });
        }
    }
    
    // Render existing groups
    card.groups.forEach(group => {
        renderGroup(cardEl, group);
    });
    
    // Update totals
    updateCardTotals(cardEl, card);
    
    // Attach event handlers
    attachCardEventHandlers(cardEl, card);
    
    return cardEl;
}

function renderGroup(cardEl, groupData) {
    const template = document.getElementById('group-template');
    const groupEl = template.content.cloneNode(true).querySelector('.group-panel');
    
    groupEl.dataset.groupNumber = groupData.regGroupNumber;
    
    // Initialize group budget data if not exists
    if (!groupData.budget) {
        groupData.budget = {
            total: 0,
            excluded: 0,
            carryOver: 0
        };
    }
    
    // Create custom header with accordion and total
    const groupHeader = document.createElement('div');
    groupHeader.className = 'group-header';
    
    // Build title HTML based on whether group is filtered
    let titleHTML = '';
    if (groupData.isFiltered) {
        titleHTML = `
            <div class="group-header-main">
                <div class="group-title-row">
                    <span class="group-collapse-icon">▼</span>
                    <h4 class="group-title">
                        ${groupData.regGroupName} (${groupData.regGroupNumber})
                        <span class="filtered-badge">Filtered: "${groupData.filterTerm}"</span>
                    </h4>
                    <span class="item-count">${groupData.items.length} of ${groupData.totalCount} items</span>
                </div>
                <div class="group-totals">
                    <span class="group-total">$0.00</span>
                    <span class="group-weekly">$0.00/wk</span>
                </div>
            </div>
        `;
    } else {
        titleHTML = `
            <div class="group-header-main">
                <div class="group-title-row">
                    <span class="group-collapse-icon">▼</span>
                    <h4 class="group-title">${groupData.regGroupName} (${groupData.regGroupNumber})</h4>
                    <span class="item-count">${groupData.items.length} items</span>
                </div>
                <div class="group-totals">
                    <span class="group-total">$0.00</span>
                    <span class="group-weekly">$0.00/wk</span>
                </div>
            </div>
        `;
    }
    
    groupHeader.innerHTML = titleHTML + `
        <div class="group-actions">
            <button class="btn-text hide-unselected-btn">− Hide unselected</button>
            <button class="btn-text show-all-btn" style="display:none;">+ Show all</button>
            <button class="btn-icon-only remove-group-btn" aria-label="Remove group">✕</button>
        </div>
    `;
    
    const itemsList = document.createElement('div');
    itemsList.className = 'items-list';
    
    // Clear default content and add our custom structure
    groupEl.innerHTML = '';
    groupEl.appendChild(groupHeader);
    
    // Add group budget section
    const budgetSection = document.createElement('div');
    budgetSection.className = 'group-budget-section';
    budgetSection.innerHTML = `
        <div class="group-budget-inputs">
            <div class="form-group">
                <label>Group Budget</label>
                <input type="number" class="group-budget-amount" placeholder="0.00" inputmode="decimal" step="0.01" value="${groupData.budget.total || ''}">
            </div>
            <div class="form-group">
                <label>Excluded</label>
                <input type="number" class="group-excluded-amount" placeholder="0.00" inputmode="decimal" step="0.01" value="${groupData.budget.excluded || ''}">
            </div>
            <div class="form-group">
                <label>Carry Over</label>
                <input type="number" class="group-carry-amount" placeholder="0.00" inputmode="decimal" step="0.01" value="${groupData.budget.carryOver || ''}">
            </div>
        </div>
    `;
    groupEl.appendChild(budgetSection);
    
    // Add budget input handlers
    budgetSection.querySelectorAll('input').forEach(input => {
        input.addEventListener('input', () => {
            updateCardFromDOM(cardEl);
            saveState();
        });
    });
    
    groupEl.appendChild(itemsList);
    
    // Add items
    groupData.items.forEach((item, index) => {
        const itemEl = renderItem(item);
        itemsList.appendChild(itemEl);
    });
    
    // Add "Load all items" button if filtered
    if (groupData.isFiltered) {
        const loadAllBtn = document.createElement('button');
        loadAllBtn.className = 'btn-text load-all-items';
        loadAllBtn.textContent = `Load all ${groupData.totalCount} items from this group`;
        loadAllBtn.onclick = () => {
            // Get the card reference
            const card = state.cards.find(c => c.id === cardEl.dataset.cardId);
            if (!card) return;
            
            // Replace with full group
            const catalogueGroup = state.catalogue[groupData.regGroupNumber];
            if (catalogueGroup) {
                // Find the group index in card.groups
                const groupIndex = card.groups.findIndex(g => g.regGroupNumber === groupData.regGroupNumber);
                if (groupIndex >= 0) {
                    // Update the group data with all items
                    const fullGroupData = {
                        regGroupNumber: groupData.regGroupNumber,
                        regGroupName: catalogueGroup.regGroupName,
                        items: catalogueGroup.items.map(item => ({
                            ...item,
                            selected: false,
                            overridePrice: null,
                            statePrice: item.statePrices[card.state] || item.statePrices['NSW'] || 0,
                            hours: {},
                            days: {},
                            quantity: 0
                        }))
                    };
                    
                    // Preserve selected items from filtered group
                    groupData.items.forEach(filteredItem => {
                        if (filteredItem.selected) {
                            const fullItem = fullGroupData.items.find(i => i.supportItemNumber === filteredItem.supportItemNumber);
                            if (fullItem) {
                                fullItem.selected = true;
                                fullItem.hours = filteredItem.hours;
                                fullItem.days = filteredItem.days;
                                fullItem.quantity = filteredItem.quantity;
                                fullItem.overridePrice = filteredItem.overridePrice;
                            }
                        }
                    });
                    
                    // Update the card's group data
                    card.groups[groupIndex] = fullGroupData;
                    
                    // Re-render just this group
                    const groupsContainer = cardEl.querySelector('.groups-list');
                    const newGroupEl = document.createElement('div');
                    newGroupEl.innerHTML = '';
                    renderGroup(cardEl, fullGroupData);
                    
                    // The new group is already appended by renderGroup, so just remove the old one
                    groupEl.remove();
                    
                    // Update totals
                    updateCardTotals(cardEl, card);
                    saveState();
                }
            }
        };
        
        // Add the button at the end of items list
        itemsList.appendChild(loadAllBtn);
    }
    
    // Accordion toggle
    groupHeader.querySelector('.group-title-row').onclick = () => {
        groupEl.classList.toggle('collapsed');
        const icon = groupHeader.querySelector('.group-collapse-icon');
        icon.textContent = groupEl.classList.contains('collapsed') ? '►' : '▼';
    };
    
    // Hide/Show unselected handlers
    groupHeader.querySelector('.hide-unselected-btn').onclick = () => {
        itemsList.classList.add('hiding-unselected');
        const unselectedItems = itemsList.querySelectorAll('.item-row:not(.selected)');
        unselectedItems.forEach(item => {
            item.style.display = 'none';
        });
        groupHeader.querySelector('.hide-unselected-btn').style.display = 'none';
        groupHeader.querySelector('.show-all-btn').style.display = 'inline';
    };

    groupHeader.querySelector('.show-all-btn').onclick = () => {
        itemsList.classList.remove('hiding-unselected');
        const hiddenItems = itemsList.querySelectorAll('.item-row');
        hiddenItems.forEach(item => {
            item.style.display = '';
        });
        groupHeader.querySelector('.show-all-btn').style.display = 'none';
        groupHeader.querySelector('.hide-unselected-btn').style.display = 'inline';
    };

    // Remove group handler
    groupHeader.querySelector('.remove-group-btn').onclick = () => {
        if (confirm('Remove this group and all its items?')) {
            // Get card reference
            const card = state.cards.find(c => c.id === cardEl.dataset.cardId);
            if (card) {
                // Remove from card.groups
                const groupIndex = card.groups.findIndex(g => g.regGroupNumber === groupData.regGroupNumber);
                if (groupIndex >= 0) {
                    card.groups.splice(groupIndex, 1);
                }
            }
            
            groupEl.remove();
            updateCardFromDOM(cardEl);
            saveState();
        }
    };
    
    // Add to the groups list
    cardEl.querySelector('.groups-list').appendChild(groupEl);
    
    // Get the card for totals update
    const card = state.cards.find(c => c.id === cardEl.dataset.cardId);
    if (card) {
        // Update the group total
        updateGroupTotal(cardEl, groupEl, groupData.regGroupNumber);
    }
}

function updateGroupTotal(cardEl, groupEl, groupNumber) {
    // This is now handled by updateCardTotals, so just call that
    const card = state.cards.find(c => c.id === cardEl.dataset.cardId);
    if (card) {
        updateCardTotals(cardEl, card);
    }
}

function formatCurrency(amount) {
    return new Intl.NumberFormat('en-AU', {
        style: 'currency',
        currency: 'AUD',
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
    }).format(amount);
}

function renderItem(itemData) {
    const template = document.getElementById('item-template');
    const itemEl = template.content.cloneNode(true).querySelector('.item-row');
    
    itemEl.dataset.itemNumber = itemData.supportItemNumber;
    if (itemData.selected) {
        itemEl.classList.add('selected');
    }
    
    // Set item info
    const checkbox = itemEl.querySelector('.item-select');
    checkbox.checked = itemData.selected || false;
    itemEl.querySelector('.item-name').textContent = itemData.supportItemName;
    itemEl.querySelector('.item-number').textContent = itemData.supportItemNumber;
    itemEl.querySelector('.item-unit').textContent = itemData.unit;
    
    // Fix price display based on unit type
    const price = itemData.overridePrice || itemData.statePrice || 0;
    const priceText = price ? `$${price}${itemData.unit === 'H' ? '/hr' : ''}` : '—';
    itemEl.querySelector('.item-price').textContent = priceText;
    
    // Create hours/quantity inputs based on item type
    const inputsContainer = itemEl.querySelector('.item-inputs');
    
    if (itemData.unit === 'H') {
        // Hour-based items - existing logic
        if (itemData.flags.isWeekday) {
            const weekdayGroup = createWeekdayInputGroup(itemData);
            inputsContainer.appendChild(weekdayGroup);
        } else if (itemData.flags.isSaturday) {
            const saturdayInput = createHoursInput('Saturday', itemData.hours?.saturday || 0);
            inputsContainer.appendChild(saturdayInput);
        } else if (itemData.flags.isSunday) {
            const sundayInput = createHoursInput('Sunday', itemData.hours?.sunday || 0);
            inputsContainer.appendChild(sundayInput);
        } else if (itemData.flags.isPublicHoliday) {
            const phInput = createHoursInput('PH', itemData.hours?.publicHoliday || 0);
            inputsContainer.appendChild(phInput);
        }
    } else if (itemData.unit === 'E') {
        // Each-based items - new logic
        const eType = getEItemType(itemData.supportItemName);
        
        switch (eType) {
            case 'daily':
                const dailyInputs = createDailyCheckboxes(itemData);
                inputsContainer.appendChild(dailyInputs);
                break;
            case 'one-time':
                const oneTimeInput = createQuantityInput('Quantity', itemData.quantity || 0, true);
                inputsContainer.appendChild(oneTimeInput);
                break;
            case 'per-occurrence':
                const occurrenceInput = createQuantityInput('Per Day', itemData.quantity || 0, false);
                inputsContainer.appendChild(occurrenceInput);
                break;
            default:
                const standardInput = createQuantityInput('Quantity', itemData.quantity || 0, true);
                inputsContainer.appendChild(standardInput);
        }
    }
    
    // Item selection handler - FIXED VERSION
    checkbox.onchange = (e) => {
    if (e.target.checked) {
        itemEl.classList.add('selected');
    } else {
        itemEl.classList.remove('selected');
    }
    
    setTimeout(() => {
        const cardEl = itemEl.closest('.budget-card');
        updateCardFromDOM(cardEl);
        saveState(); // Add this
    }, 10);
};
  
    return itemEl;
}


function getEItemType(itemName) {
    const name = itemName.toLowerCase();
    
    // Check for daily/nightly items
    if (name.includes('sleepover') || 
        name.includes('overnight') || 
        name.includes('night-time') ||
        name.includes('on-call')) {
        return 'daily';
    }
    
    // Check for one-time items
    if (name.includes('establishment') || 
        name.includes('setup') ||
        name.includes('initial') ||
        name.includes('assessment') ||
        name.includes('fee')) {
        return 'one-time';
    }
    
    // Check for per-occurrence items
    if (name.includes('travel') || 
        name.includes('transport') ||
        name.includes('kilometre')) {
        return 'per-occurrence';
    }
    
    // Default
    return 'standard';
}

function createDailyCheckboxes(itemData) {
    const container = document.createElement('div');
    container.className = 'daily-checkboxes';
    
    const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    
    days.forEach(day => {
        const dayGroup = document.createElement('div');
        dayGroup.className = 'day-checkbox-group';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'day-checkbox';
        checkbox.checked = itemData.days?.[day] || false;
        checkbox.dataset.day = day;
        
        const label = document.createElement('label');
        label.className = 'day-label';
        label.textContent = day.substring(0, 1);
        
        // Update immediately when checkbox changes
        checkbox.onchange = () => {
            updateCardFromDOM(checkbox.closest('.budget-card'));
        };
        
        dayGroup.appendChild(checkbox);
        dayGroup.appendChild(label);
        container.appendChild(dayGroup);
    });
    
    return container;
}

function createQuantityInput(label, value, isInteger) {
    const group = document.createElement('div');
    group.className = 'quantity-input-group';
    
    const labelEl = document.createElement('label');
    labelEl.className = 'quantity-label';
    labelEl.textContent = label;
    
    const input = document.createElement('input');
    input.type = 'number';
    input.className = 'quantity-input';
    input.inputMode = isInteger ? 'numeric' : 'decimal';
    input.step = isInteger ? '1' : '0.1';
    input.min = '0';
    input.value = value;
    
    // Use 'input' event for real-time updates
    input.oninput = (e) => {
        updateCardFromDOM(e.target.closest('.budget-card'));
    };
    
    // Validate on blur
    input.onblur = (e) => {
        if (isInteger) {
            e.target.value = Math.round(e.target.value) || 0;
        }
        updateCardFromDOM(e.target.closest('.budget-card'));
    };
    
    group.appendChild(labelEl);
    group.appendChild(input);
    
    return group;
}
function createWeekdayInputGroup(itemData) {
    const container = document.createElement('div');
    container.className = 'hours-input-group';
    
    const mainInput = createHoursInput('Weekday', itemData.hours?.weekday || 0);
    container.appendChild(mainInput);
    
    const toggle = document.createElement('div');
    toggle.className = 'per-day-toggle';
    toggle.textContent = 'Per-day breakdown';
    
    const perDayContainer = document.createElement('div');
    perDayContainer.className = 'per-day-inputs hidden';
    ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'].forEach(day => {
        const dayInput = createHoursInput(day, itemData.hours?.[day] || 0);
        perDayContainer.appendChild(dayInput);
    });
    
    toggle.onclick = () => {
        if (perDayContainer.classList.contains('hidden')) {
            perDayContainer.classList.remove('hidden');
            mainInput.classList.add('hidden');
            toggle.textContent = 'Single value';
        } else {
            perDayContainer.classList.add('hidden');
            mainInput.classList.remove('hidden');
            toggle.textContent = 'Per-day breakdown';
        }
        // Trigger update when switching modes
        updateCardFromDOM(container.closest('.budget-card'));
    };
    
    container.appendChild(toggle);
    container.appendChild(perDayContainer);
    
    return container;
}

function createHoursInput(label, value) {
    const group = document.createElement('div');
    group.className = 'hours-input-group';
    
    const labelEl = document.createElement('label');
    labelEl.className = 'hours-label';
    labelEl.textContent = label;
    
    const input = document.createElement('input');
    input.type = 'number';
    input.className = 'hours-input';
    input.inputMode = 'decimal';
    input.step = '0.5';
    input.min = '0';
    input.value = value;
    
    // Change to use 'input' event for real-time updates
    input.oninput = (e) => {
        const validated = validateHours(e.target.value);
        if (validated % 0.5 !== 0) {
            e.target.classList.add('error');
        } else {
            e.target.classList.remove('error');
        }
        // Always update, even during typing
        updateCardFromDOM(e.target.closest('.budget-card'));
    };
    
    // Also handle blur to ensure final value is validated
    input.onblur = (e) => {
        e.target.value = validateHours(e.target.value);
        updateCardFromDOM(e.target.closest('.budget-card'));
    };
    
    group.appendChild(labelEl);
    group.appendChild(input);
    
    return group;
}

// Helper functions first
function parseDDMMYYYY(s) {
  const [dd, mm, yyyy] = s.split('-').map(Number);
  return new Date(Date.UTC(yyyy, mm - 1, dd));
}

function formatDateDDMMYYYY(d) {
    // Handle both Date objects and date strings
    const date = typeof d === 'string' ? new Date(d) : d;
    const day = String(date.getUTCDate()).padStart(2, '0');
    const month = String(date.getUTCMonth() + 1).padStart(2, '0');
    const year = date.getUTCFullYear();
    return `${day}-${month}-${year}`;
}


function eachDateInclusive(startStr, endStr, cb) {
  // Dates are yyyy-mm-dd from HTML inputs
  let d = new Date(startStr + 'T00:00:00Z');
  const end = new Date(endStr + 'T00:00:00Z');
  
  while (d <= end) {
    cb(new Date(d));
    d = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate() + 1));
  }
}


function isPublicHoliday(date, stateCode) {
  const dateStr = date.toISOString().split('T')[0];
  // Use the global state.publicHolidays, not the parameter
  return state.publicHolidays.some(ph => 
    ph.date === dateStr && (!ph.state || ph.state === stateCode)
  );
}


function isSleepoverItem(item) {
  return /sleepover/i.test(item.supportItemName);
}

function applyJulyUplift(basePrice, serviceDate, itemEndDate, upliftPercent) {
  // If no end date, assume it's current pricing (no uplift needed)
  if (!itemEndDate) return basePrice;
  
  // Handle both string and date formats
  let endDate;
  if (typeof itemEndDate === 'string') {
    // Handle dd-mm-yyyy format from the catalogue
    if (itemEndDate.match(/^\d{2}[-/]\d{2}[-/]\d{4}$/)) {
      const [day, month, year] = itemEndDate.split(/[-/]/);
      endDate = new Date(Date.UTC(parseInt(year), parseInt(month) - 1, parseInt(day)));
    } else {
      endDate = new Date(itemEndDate);
    }
  } else {
    endDate = itemEndDate;
  }
  
  if (isNaN(endDate.getTime())) return basePrice;
  
  // Only apply uplift if service date is after the item's end date
  if (serviceDate <= endDate) return basePrice;
  
  // Calculate how many July 1st periods have passed since the end date
  const endYear = endDate.getUTCFullYear();
  const serviceYear = serviceDate.getUTCFullYear();
  
  let periodsElapsed = 0;
  for (let year = endYear; year < serviceYear; year++) {
    const july1 = new Date(Date.UTC(year, 6, 1)); // July 1st
    if (serviceDate > july1 && july1 > endDate) {
      periodsElapsed++;
    }
  }
  
  // Check current year July 1st
  const currentYearJuly1 = new Date(Date.UTC(serviceYear, 6, 1));
  if (serviceDate >= currentYearJuly1 && currentYearJuly1 > endDate) {
    periodsElapsed++;
  }
  
  if (periodsElapsed <= 0) return basePrice;
  
  // Compound the uplift
  let price = basePrice;
  for (let i = 0; i < periodsElapsed; i++) {
    price = price * (1 + upliftPercent / 100);
  }
  
  return Math.round(price * 100) / 100;
}


function lookupPriceFromCatalogue(item, state, isSleepover, isPH) {
  // For sleepover on PH: use standard sleepover price (no PH rate)
  if (isSleepover && isPH) {
    return item.statePrices[state] || 0;
  }
  
  // Otherwise use the state price
  return item.statePrices[state] || 0;
}

function getUnitPrice(item, card, date, { isPH, isSleepover }) {
  let base = item.overridePrice || 
             lookupPriceFromCatalogue(item, card.state, isSleepover, isPH) || 
             0;
  
  if (base <= 0) return 0;
  
  if (card.settings.uplift.enabled) {
    base = applyJulyUplift(base, date, item.effectiveTo, card.settings.uplift.percent);
  }
  
  return base;
}

function resolveQuantityForDate(item, date, dayOfWeek, { isPH, isSleepover }) {
  if (item.unit === 'H') {
    // Hours logic
    if (item.hours) {
      // First check for specific day-of-week value (Mon, Tue, etc.)
      if (item.hours[dayOfWeek] !== undefined) {
        return item.hours[dayOfWeek];
      }
      
      // Then check for aggregated values
      if (isPH && item.hours.publicHoliday !== undefined) {
        return item.hours.publicHoliday;
      } else if (isSaturday(date) && item.hours.saturday !== undefined) {
        return item.hours.saturday;
      } else if (isSunday(date) && item.hours.sunday !== undefined) {
        return item.hours.sunday;
      } else if (isWeekday(date) && item.hours.weekday !== undefined) {
        return item.hours.weekday;
      }
    }
  } else if (item.unit === 'E') {
    if (isSleepover) {
      // Sleepover uses days selection
      return (item.days && item.days[dayOfWeek]) ? 1 : 0;
    } else if (getEItemType(item.supportItemName) === 'one-time') {
      // One-time items only on first day
      if (date.getTime() === new Date(card.period.start).getTime()) {
        return item.quantity || 0;
      }
    } else {
      // Other E items
      return item.quantity || 0;
    }
  }
  
  return 0;
}

// Main calculation function
function computeCardTotals(card) {
  const result = {
    usedCents: 0,
    perGroupCents: {},
    daysCount: 0,
    phCount: 0,
    weeks: 0,
    groupBudgets: {}, // Add group budget tracking
    totalAvailableCents: 0, // Track total available budget
    totalRemainingCents: 0 // Track total remaining
  };
  
  if (!card.period.start || !card.period.end) return result;
  
  // Parse dates - they're yyyy-mm-dd from HTML date inputs
  const startDate = new Date(card.period.start + 'T00:00:00Z');
  const endDate = new Date(card.period.end + 'T00:00:00Z');
  
  // Initialize group totals and budgets
  card.groups.forEach(group => {
    result.perGroupCents[group.regGroupNumber] = 0;
    if (card.settings.calculateByGroup && group.budget) {
      const groupTotal = (group.budget.total || 0);
      const groupExcluded = (group.budget.excluded || 0);
      const groupCarryOver = (group.budget.carryOver || 0);
      const groupAvailable = groupTotal + groupCarryOver - groupExcluded;
      
      result.groupBudgets[group.regGroupNumber] = {
        totalCents: groupTotal * 100,
        excludedCents: groupExcluded * 100,
        carryOverCents: groupCarryOver * 100,
        availableCents: groupAvailable * 100
      };
      
      result.totalAvailableCents += groupAvailable * 100;
    }
  });
  
  // Single pass through dates
  eachDateInclusive(card.period.start, card.period.end, (date) => {
    result.daysCount++;
    
    const isPH = isPublicHoliday(date, card.state);
    const dayOfWeek = getDayOfWeek(date);
    
    if (isPH) result.phCount++;
    
    card.groups.forEach(group => {
      group.items.forEach(item => {
        if (!item.selected) return;
        
        const isSleepover = isSleepoverItem(item);
        
        // Main gating logic with sleepover exception
        if (isPH) {
          if (isSleepover) {
            // Sleepover allowed on PH at standard rate
          } else {
            if (!card.settings.includePH) return;
            if (!item.flags.isPublicHoliday) return;
          }
        } else {
          // Non-PH day
          if (item.flags.isPublicHoliday) return;
          if (item.flags.isWeekday && !isWeekday(date)) return;
          if (item.flags.isSaturday && !isSaturday(date)) return;
          if (item.flags.isSunday && !isSunday(date)) return;
        }
        
        const quantity = resolveQuantityForDate(item, date, dayOfWeek, { isPH, isSleepover });
        if (quantity <= 0) return;
        
        const unitPrice = getUnitPrice(item, card, date, { isPH, isSleepover });
        const lineCents = Math.round(quantity * Math.round(unitPrice * 100));
        
        result.usedCents += lineCents;
        result.perGroupCents[group.regGroupNumber] += lineCents;
      });
    });
  });
  
  // Calculate weeks
  result.weeks = Math.max(1, Math.ceil(result.daysCount / 7));
  
  // Calculate total remaining if using group budgets
  if (card.settings.calculateByGroup) {
    result.totalRemainingCents = result.totalAvailableCents - result.usedCents;
  }
  
  return result;
}

// Helper function to count days in period
function countDaysInPeriod(startDate, endDate) {
    const dayCount = { Mon: 0, Tue: 0, Wed: 0, Thu: 0, Fri: 0, Sat: 0, Sun: 0 };
    const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    
    let current = new Date(startDate);
    while (current <= endDate) {
        const dayName = days[current.getDay()];
        dayCount[dayName]++;
        current.setDate(current.getDate() + 1);
    }
    
    return dayCount;
}

function updateCardTotals(cardEl, card) {
    const totals = computeCardTotals(card);
    
    // Update used amount
    const used = totals.usedCents / 100;
    cardEl.querySelector('.used-amount').textContent = formatCurrency(used);
    
    let available, remaining;
    
    if (card.settings.calculateByGroup) {
        // Use group budget totals
        available = totals.totalAvailableCents / 100;
        remaining = totals.totalRemainingCents / 100;
    } else {
        // Use overall budget
        const totalBudget = parseFloat(card.budget.total) || 0;
        const carryOver = parseFloat(card.budget.carryOver) || 0;
        const excluded = parseFloat(card.budget.excluded) || 0;
        available = totalBudget + carryOver - excluded;
        remaining = available - used;
    }
    
    // Update remaining
    const remainingEl = cardEl.querySelector('.remaining-amount');
    
    // If no budget is set, show a dash or message instead of negative number
    if (available === 0) {
        remainingEl.textContent = '—';
        remainingEl.classList.remove('negative');
    } else {
        remainingEl.textContent = formatCurrency(remaining);
        remainingEl.classList.toggle('negative', remaining < 0);
    }
    
    // Update weekly
    const weekly = totals.weeks > 0 ? (totals.usedCents / 100) / totals.weeks : 0;
    cardEl.querySelector('.weekly-amount').textContent = formatCurrency(weekly);
    
    // Update collapsed view
    const collapsedUsed = cardEl.querySelector('.collapsed-used');
    const collapsedRemaining = cardEl.querySelector('.collapsed-remaining');
    const collapsedBudget = cardEl.querySelector('.collapsed-budget');
    const collapsedStartDate = cardEl.querySelector('.collapsed-start-date');
    const collapsedEndDate = cardEl.querySelector('.collapsed-end-date');
    
    if (collapsedUsed) collapsedUsed.textContent = formatCurrency(used);
    if (collapsedRemaining) {
        collapsedRemaining.textContent = available === 0 ? '—' : formatCurrency(remaining);
        collapsedRemaining.classList.toggle('negative', remaining < 0);
    }
    if (collapsedBudget) collapsedBudget.textContent = formatCurrency(available);
    if (collapsedStartDate && card.period.start) {
        collapsedStartDate.textContent = formatDateDDMMYYYY(new Date(card.period.start));
    }
    if (collapsedEndDate && card.period.end) {
        collapsedEndDate.textContent = formatDateDDMMYYYY(new Date(card.period.end));
    }
    
    // Update all group totals
    cardEl.querySelectorAll('.group-panel').forEach(groupEl => {
        const groupNumber = groupEl.dataset.groupNumber;
        const groupTotal = (totals.perGroupCents[groupNumber] || 0) / 100;
        const groupWeekly = totals.weeks > 0 ? groupTotal / totals.weeks : 0;
        
        const totalEl = groupEl.querySelector('.group-total');
        if (totalEl) {
            if (card.settings.calculateByGroup) {
                // Find the group data
                const group = card.groups.find(g => g.regGroupNumber === groupNumber);
                if (group && group.budget) {
                    const groupBudget = parseFloat(group.budget.total) || 0;
                    const groupCarryOver = parseFloat(group.budget.carryOver) || 0;
                    const groupExcluded = parseFloat(group.budget.excluded) || 0;
                    const groupAvailable = groupBudget + groupCarryOver - groupExcluded;
                    const groupRemaining = groupAvailable - groupTotal;
                    
                    totalEl.innerHTML = `
                        <span style="font-size: 0.8em">Used:</span> ${formatCurrency(groupTotal)}<br>
                        <span style="font-size: 0.8em">Budget:</span> ${formatCurrency(groupAvailable)}
                    `;
                    totalEl.classList.toggle('over-budget', groupRemaining < 0);
                } else {
                    totalEl.textContent = formatCurrency(groupTotal);
                }
            } else {
                totalEl.textContent = formatCurrency(groupTotal);
            }
        }
        
        const weeklyEl = groupEl.querySelector('.group-weekly');
        if (weeklyEl) {
            weeklyEl.textContent = `${formatCurrency(groupWeekly)}/wk`;
        }
    });
}

function attachCardEventHandlers(cardEl, card) {
    // Collapse/expand
    cardEl.querySelector('.collapse-btn').onclick = () => {
        cardEl.classList.toggle('collapsed');
    };
    
    // Actions dropdown
    const actionsToggle = cardEl.querySelector('.actions-toggle');
    const actionsDropdown = cardEl.querySelector('.actions-dropdown');

    if (actionsToggle && actionsDropdown) {
        actionsToggle.onclick = (e) => {
            e.stopPropagation();
            actionsDropdown.classList.toggle('hidden');
        };
        
        // Use a more specific handler to avoid memory leaks
        const closeDropdown = (e) => {
            if (!actionsToggle.contains(e.target) && !actionsDropdown.contains(e.target)) {
                actionsDropdown.classList.add('hidden');
            }
        };
        
        // Only add listener when dropdown is open
        const handleDropdownToggle = () => {
            if (!actionsDropdown.classList.contains('hidden')) {
                document.addEventListener('click', closeDropdown);
            } else {
                document.removeEventListener('click', closeDropdown);
            }
        };
        
        // Watch for changes
        const observer = new MutationObserver(handleDropdownToggle);
        observer.observe(actionsDropdown, { attributes: true, attributeFilter: ['class'] });
        
        // Cleanup when card is removed
        const cardObserver = new MutationObserver(() => {
            if (!document.body.contains(cardEl)) {
                document.removeEventListener('click', closeDropdown);
                observer.disconnect();
                cardObserver.disconnect();
            }
        });
        cardObserver.observe(document.body, { childList: true, subtree: true });
    }
    
    // Input changes
    const inputs = [
        '.participant-name', '.ndis-number', '.start-date', '.end-date',
        '.budget-amount', '.excluded-amount', '.carry-in-amount', '.include-ph', '.july-uplift', '.uplift-rate',
        '.card-state', '.notes-input', '.calculate-by-group'
    ];

    inputs.forEach(selector => {
        const el = cardEl.querySelector(selector);
        if (el) {
            if (el.type === 'checkbox') {
                el.addEventListener('change', () => {
                    updateCardFromDOM(cardEl);
                    saveState();
                });
            } else {
                el.addEventListener('input', () => {
                    updateCardFromDOM(cardEl);
                    saveState();
                });
            }
        }
    });
    
    // View PH button
    cardEl.querySelector('.view-ph-btn').onclick = () => {
        showPublicHolidaysModal(card);
    };
    
    // Setup group search with the new primary search input
    const groupSearch = cardEl.querySelector('.group-search'); // Updated selector
    const searchResults = cardEl.querySelector('.group-search-results');
    let selectedGroup = null;

    if (groupSearch && searchResults) {
        // Search function
        const searchGroups = (query) => {
    if (!state.catalogue || !query) {
        searchResults.innerHTML = '';
        searchResults.classList.add('hidden');
        return;
    }
    
    const lowerQuery = query.toLowerCase();
    const results = [];
    
    // Search through all groups and items
    Object.entries(state.catalogue).forEach(([groupNumber, group]) => {
        let matchingItems = [];
        
        // Check if group matches
        const groupMatches = groupNumber.includes(lowerQuery) || 
            group.regGroupName.toLowerCase().includes(lowerQuery);
        
        // Check which items match
        group.items.forEach(item => {
            if (item.supportItemNumber.toLowerCase().includes(lowerQuery) ||
                item.supportItemName.toLowerCase().includes(lowerQuery)) {
                matchingItems.push(item);
            }
        });
        
        // Add result if group matches OR has matching items
        if (groupMatches || matchingItems.length > 0) {
            results.push({
                type: 'group',
                groupNumber,
                groupName: group.regGroupName,
                totalItems: group.items.length,
                matchingItems: matchingItems,
                directMatch: groupMatches
            });
        }
    });
    
    // Display results
    searchResults.innerHTML = '';
    if (results.length > 0) {
        results.slice(0, 20).forEach(result => {
            const div = document.createElement('div');
            div.className = 'group-search-result';
            
            let displayHtml = `
                <div class="search-result-header">
                    <span class="search-result-title">${result.groupName} (${result.groupNumber})</span>
                    <span class="search-result-count">${result.totalItems} items</span>
                </div>
            `;
            
            // If search matched items but not the group name/number, show preview
            if (!result.directMatch && result.matchingItems.length > 0) {
                displayHtml += `<div class="search-result-matches">`;
                displayHtml += `<div class="match-count">${result.matchingItems.length} matching item${result.matchingItems.length > 1 ? 's' : ''}:</div>`;
                
                // Show first 3 matching items
                const preview = result.matchingItems.slice(0, 3);
                preview.forEach(item => {
                    displayHtml += `<div class="match-item">• ${item.supportItemName}</div>`;
                });
                
                if (result.matchingItems.length > 3) {
                    displayHtml += `<div class="match-more">...and ${result.matchingItems.length - 3} more</div>`;
                }
                displayHtml += `</div>`;
            }
            
            div.innerHTML = displayHtml;
            
            div.onclick = () => {
    const groupNumber = result.groupNumber;
    const catalogueGroup = state.catalogue[groupNumber];
    if (!catalogueGroup) return;
    
    // Check if group already added
    if (card.groups.some(g => g.regGroupNumber === groupNumber)) {
        showError('This group has already been added');
        return;
    }
    
    // Create group data - but only include matching items if search was specific
    let itemsToInclude;
    
    if (!result.directMatch && result.matchingItems.length > 0) {
        // User searched for specific items - only include those
        itemsToInclude = result.matchingItems;
    } else {
        // User searched for the group itself - include all items
        itemsToInclude = catalogueGroup.items;
    }
    
    const groupData = {
        regGroupNumber: groupNumber,
        regGroupName: catalogueGroup.regGroupName,
        // Add a filtered flag and search term for display purposes
        isFiltered: !result.directMatch && result.matchingItems.length > 0,
        filterTerm: lowerQuery,
        matchedCount: result.matchingItems.length,
        totalCount: catalogueGroup.items.length,
        items: itemsToInclude.map(item => ({
            ...item,
            selected: false,
            overridePrice: null,
            statePrice: item.statePrices[card.state] || item.statePrices['NSW'] || 0,
            hours: {},
            days: {},
            quantity: 0
        }))
    };
    
    card.groups.push(groupData);
    renderGroup(cardEl, groupData);
    updateCardTotals(cardEl, card);
    
    // Clear search
    groupSearch.value = '';
    searchResults.classList.add('hidden');
};
            searchResults.appendChild(div);
        });
        searchResults.classList.remove('hidden');
    } else {
        const div = document.createElement('div');
        div.className = 'group-search-result no-results';
        div.textContent = 'No matching groups or items found';
        searchResults.appendChild(div);
        searchResults.classList.remove('hidden');
    }
};


        // Search input handler
        groupSearch.oninput = (e) => {
            searchGroups(e.target.value);
        };

        // Hide results when clicking outside
        const hideHandler = (e) => {
            if (!cardEl.contains(e.target)) {
                searchResults.classList.add('hidden');
            }
        };
        document.addEventListener('click', hideHandler);
        
        // Clean up event listener when card is removed
        const observer = new MutationObserver((mutations) => {
            if (!document.body.contains(cardEl)) {
                document.removeEventListener('click', hideHandler);
                observer.disconnect();
            }
        });
        observer.observe(document.body, { childList: true, subtree: true });
    }
    
    // Export button (now in dropdown)
    cardEl.querySelector('.export-btn').onclick = () => {
        // Hide dropdown first
        actionsDropdown.classList.add('hidden');
        
        // Update and save the current state before exporting
        updateCardFromDOM(cardEl);
        saveState();
        
        const errors = validateCard(card);
        if (errors.length > 0) {
            showValidationErrors(errors);
            return;
        }
        
        const csv = buildCsvRows(card);
        const filename = generateFilename(card);
        downloadCsv(filename, csv);
    };
    
    // Generate report button (now in dropdown)
    const reportBtn = cardEl.querySelector('.generate-report-btn');
if (reportBtn) {
    reportBtn.onclick = async function() {
        // Hide dropdown first
        actionsDropdown.classList.add('hidden');
        
        // Update and save the current state before generating PDF
        updateCardFromDOM(cardEl);
        saveState();
        
        // Show loading while generating
        showLoading('Generating report...');
        
        try {
            await generatePDFReport(card);
            hideLoading();
        } catch (error) {
            hideLoading();
            showError('Error generating report: ' + error.message);
        }
    };
}

    // Delete button (now in dropdown)
    cardEl.querySelector('.delete-btn').onclick = () => {
    if (confirm('Delete this funding period? This cannot be undone.')) {
        const index = state.cards.findIndex(c => c.id === card.id);
        if (index >= 0) {
            state.cards.splice(index, 1);
            cardEl.remove();
            saveState();
        }
    }
};


    // Continue button
    cardEl.querySelector('.continue-btn').onclick = () => {
        const newCard = createCard(card);
        state.cards.push(newCard);
        const newCardEl = renderCard(newCard);
        document.getElementById('cards-container').appendChild(newCardEl);
        newCardEl.scrollIntoView({ behavior: 'smooth' });
        saveState();
    };

    // Settings accordion
    const settingsAccordion = cardEl.querySelector('.settings-accordion');
    if (settingsAccordion) {
        settingsAccordion.querySelector('.accordion-header').onclick = () => {
            settingsAccordion.classList.toggle('collapsed');
        };
    }

    // Global hide/show buttons
    const globalHide = cardEl.querySelector('.global-hide-unselected');
    const globalShow = cardEl.querySelector('.global-show-all');
    
    // Calculate by group toggle handler
    const calculateByGroupToggle = cardEl.querySelector('.calculate-by-group');
    if (calculateByGroupToggle) {
        calculateByGroupToggle.addEventListener('change', (e) => {
            if (e.target.checked) {
                cardEl.classList.add('calculate-by-group-active');
                // Show all group budget sections
                cardEl.querySelectorAll('.group-budget-section').forEach(section => {
                    section.style.display = 'block';
                });
            } else {
                cardEl.classList.remove('calculate-by-group-active');
                // Hide all group budget sections
                cardEl.querySelectorAll('.group-budget-section').forEach(section => {
                    section.style.display = 'none';
                });
            }
            updateCardFromDOM(cardEl);
            saveState();
        });
    }

    if (globalHide) {
        globalHide.onclick = () => {
            // Hide unselected items in all groups
            cardEl.querySelectorAll('.group-panel').forEach(groupEl => {
                const hideBtn = groupEl.querySelector('.hide-unselected-btn');
                if (hideBtn && hideBtn.style.display !== 'none') {
                    hideBtn.click();
                }
            });
            
            globalHide.style.display = 'none';
            globalShow.style.display = 'inline';
        };
    }

    if (globalShow) {
        globalShow.onclick = () => {
            // Show all items in all groups
            cardEl.querySelectorAll('.group-panel').forEach(groupEl => {
                const showBtn = groupEl.querySelector('.show-all-btn');
                if (showBtn && showBtn.style.display !== 'none') {
                    showBtn.click();
                }
            });
            
            globalShow.style.display = 'none';
            globalHide.style.display = 'inline';
        };
    }
}
async function parseExportedCsv(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        
        reader.onload = (e) => {
            try {
                const text = e.target.result;
                const lines = text.split('\n');
                
                // Check if this is the new format with metadata
                if (lines[0] === 'Metadata,Value') {
                    const metadata = {};
                    let dataStartIndex = 0;
                    
                    // Read metadata
                    for (let i = 1; i < lines.length; i++) {
                        if (lines[i].trim() === '') {
                            dataStartIndex = i + 2; // Skip empty line and header
                            break;
                        }
                        const parts = lines[i].split(',');
                        const key = parts[0];
                        const value = parts.slice(1).join(',').replace(/^"|"$/g, '').replace(/""/g, '"');
                        
                        // Check if we've reached GroupBudgets section
                        if (value === 'GroupBudgets') {
                            // Skip the header row
                            i += 2; // Skip "GroupBudgets" and header row
                            
                            // Parse group budgets
                            metadata.groupBudgets = [];
                            while (i < lines.length && lines[i].trim() !== '') {
                                const groupParts = parseCSVLine(lines[i]);
                                if (groupParts.length >= 5) {
                                    metadata.groupBudgets.push({
                                        regGroupNumber: groupParts[0],
                                        regGroupName: groupParts[1],
                                        budget: {
                                            total: parseFloat(groupParts[2]) || 0,
                                            excluded: parseFloat(groupParts[3]) || 0,
                                            carryOver: parseFloat(groupParts[4]) || 0
                                        }
                                    });
                                }
                                i++;
                            }
                        } else {
                            metadata[key] = value;
                        }
                    }
                    
                    // Parse the data rows
                    const headers = parseCSVLine(lines[dataStartIndex - 1]);
                    
                    // Verify it's our format
                    if (headers.join(',') !== 'NDISNumber,SupportsDeliveredFrom,SupportsDeliveredTo,SupportNumber,Quantity,UnitPrice,GSTCode') {
                        throw new Error('Invalid CSV format');
                    }
                    
                    const rows = [];
                    for (let i = dataStartIndex; i < lines.length; i++) {
                        if (!lines[i].trim()) continue;
                        const values = parseCSVLine(lines[i]);
                        rows.push({
                            ndisNumber: values[0],
                            dateFrom: values[1],
                            dateTo: values[2],
                            supportNumber: values[3],
                            quantity: parseFloat(values[4]),
                            unitPrice: parseFloat(values[5]),
                            gstCode: values[6]
                        });
                    }
                    
                    resolve({ metadata, rows });
                    
                } else {
                    // Old format - use your existing logic
                    const headers = parseCSVLine(lines[0]);
                    
                    // Verify it's our format
                    if (headers.join(',') !== 'NDISNumber,SupportsDeliveredFrom,SupportsDeliveredTo,SupportNumber,Quantity,UnitPrice,GSTCode') {
                        throw new Error('Invalid CSV format');
                    }
                    
                    // Parse all lines
                    const rows = [];
                    for (let i = 1; i < lines.length; i++) {
                        if (!lines[i].trim()) continue;
                        const values = parseCSVLine(lines[i]);
                        rows.push({
                            ndisNumber: values[0],
                            dateFrom: values[1],
                            dateTo: values[2],
                            supportNumber: values[3],
                            quantity: parseFloat(values[4]),
                            unitPrice: parseFloat(values[5]),
                            gstCode: values[6]
                        });
                    }
                    
                    resolve({ rows }); // No metadata for old format
                }
            } catch (error) {
                reject(error);
            }
        };
        
        reader.onerror = reject;
        reader.readAsText(file);
    });
}

function createCardFromCsvRows(data) {
    const rows = data.rows;
    const metadata = data.metadata || {};
    
    if (!rows || rows.length === 0) return null;
    
    // Get date range and participant info from first/last rows
    const firstRow = rows[0];
    const lastRow = rows[rows.length - 1];
    
    // Parse dates (convert dd-mm-yyyy to yyyy-mm-dd)
    const parseToISODate = (dateStr) => {
        const [day, month, year] = dateStr.split('-');
        return `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
    };
    
    const card = {
        id: generateUUID(),
        participant: {
            name: metadata.ParticipantName || '', 
            ndisNumber: metadata.NDISNumber || firstRow.ndisNumber
        },
        period: {
            start: metadata.StartDate || parseToISODate(firstRow.dateFrom),
            end: metadata.EndDate || parseToISODate(lastRow.dateTo)
        },
        state: metadata.State || state.preferences.state,
        budget: {
            total: parseFloat(metadata.Budget) || 0,
            excluded: parseFloat(metadata.Excluded) || 0,
            carryOver: parseFloat(metadata.CarryOver) || 0
        },
        settings: {
            includePH: metadata.IncludePublicHolidays ? metadata.IncludePublicHolidays === 'true' : true,
            uplift: {
                enabled: metadata.PriceUplift ? metadata.PriceUplift === 'true' : true,
                percent: metadata.UpliftPercent ? parseFloat(metadata.UpliftPercent) : state.preferences.upliftPercent
            },
            calculateByGroup: metadata.CalculateByGroup ? metadata.CalculateByGroup === 'true' : false
        },
        notes: metadata.Notes || '',
        groups: []
    };
    
    // Keep all your existing logic for processing rows
    const itemsByNumber = new Map();
    const usedGroupNumbers = new Set();
    
    rows.forEach(row => {
        const supportNumber = row.supportNumber;
        const quantity = row.quantity;
        const date = parseToISODate(row.dateFrom);
        const dayOfWeek = getDayOfWeek(new Date(date));
        
        // Find which item this is
        let catalogueItem = null;
        for (const [groupNumber, group] of Object.entries(state.catalogue)) {
            catalogueItem = group.items.find(i => i.supportItemNumber === supportNumber);
            if (catalogueItem) {
                usedGroupNumbers.add(groupNumber);
                break;
            }
        }
        
        if (!catalogueItem) return;
        
        if (!itemsByNumber.has(supportNumber)) {
            itemsByNumber.set(supportNumber, {
                hours: {},
                days: {},
                quantities: {}, // Track individual day quantities
                unitPrice: row.unitPrice,
                isHourly: catalogueItem.unit === 'H',
                isSleepover: isSleepoverItem(catalogueItem)
            });
        }
        
        const itemData = itemsByNumber.get(supportNumber);
        
        if (itemData.isHourly) {
            // Store each day's hours separately first
            itemData.hours[dayOfWeek] = quantity;
            
            // For weekday items, check if all weekdays have the same value
            if (catalogueItem.flags.isWeekday) {
                if (!itemData.quantities[date]) {
                    itemData.quantities[date] = quantity;
                }
            }
        } else if (itemData.isSleepover) {
            // For sleepover, just mark the day as selected
            itemData.days[dayOfWeek] = true;
        } else {
            // Other E items
            itemData.quantity = quantity; // Use the last value found
        }
    });
    
    // Post-process to determine if weekday items should use single value or per-day
    itemsByNumber.forEach((itemData, supportNumber) => {
        if (itemData.isHourly) {
            // Check if this is a weekday item
            const catalogueItem = findCatalogueItem(supportNumber);
            if (catalogueItem?.flags.isWeekday) {
                // Check if Mon-Fri all have the same value
                const weekdayHours = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri']
                    .map(day => itemData.hours[day])
                    .filter(h => h !== undefined);
                
                if (weekdayHours.length > 0) {
                    const allSame = weekdayHours.every(h => h === weekdayHours[0]);
                    if (allSame) {
                        // Use single weekday value
                        itemData.hours = { weekday: weekdayHours[0] };
                    }
                    // Otherwise keep per-day values
                }
            }
        }
    });
    
    // Build complete groups from catalogue (not just used items)
    if (state.catalogue) {
        usedGroupNumbers.forEach(groupNumber => {
            const catalogueGroup = state.catalogue[groupNumber];
            if (!catalogueGroup) return;
            
            const groupData = {
                regGroupNumber: groupNumber,
                regGroupName: catalogueGroup.regGroupName,
                items: []
            };
            
            // Add ALL items from the group, not just used ones
            catalogueGroup.items.forEach(catalogueItem => {
                const importedData = itemsByNumber.get(catalogueItem.supportItemNumber);
                
                const itemData = {
                    ...catalogueItem,
                    selected: !!importedData, // Only select if it was in the CSV
                    overridePrice: null,
                    statePrice: catalogueItem.statePrices[card.state] || catalogueItem.statePrices['NSW'] || 0,
                    hours: importedData?.hours || {},
                    days: importedData?.days || {},
                    quantity: importedData?.quantity || 0
                };
                
                // Check if imported price differs from catalogue price
                if (importedData && importedData.unitPrice !== itemData.statePrice) {
                    itemData.overridePrice = importedData.unitPrice;
                }
                
                groupData.items.push(itemData);
            });
            
            card.groups.push(groupData);
        });
        
        // Apply group budgets if present in metadata
        if (metadata.groupBudgets && card.settings.calculateByGroup) {
            metadata.groupBudgets.forEach(groupBudget => {
                const group = card.groups.find(g => g.regGroupNumber === groupBudget.regGroupNumber);
                if (group) {
                    group.budget = groupBudget.budget;
                }
            });
        }
    }
    
    return card;
}

function findCatalogueItem(supportNumber) {
    for (const [groupNumber, group] of Object.entries(state.catalogue)) {
        const item = group.items.find(i => i.supportItemNumber === supportNumber);
        if (item) return item;
    }
    return null;
}
function updateCardFromDOM(cardEl) {
    const cardId = cardEl.dataset.cardId;
    const card = state.cards.find(c => c.id === cardId);
    if (!card) return;
    
    // Update card data from DOM
    card.participant.name = cardEl.querySelector('.participant-name').value;
    card.participant.ndisNumber = cardEl.querySelector('.ndis-number').value;
    card.period.start = cardEl.querySelector('.start-date').value;
    card.period.end = cardEl.querySelector('.end-date').value;
    
    // Ensure budget values are numbers, not strings
    card.budget.total = parseFloat(cardEl.querySelector('.budget-amount').value) || 0;
    card.budget.excluded = parseFloat(cardEl.querySelector('.excluded-amount').value) || 0;
    card.budget.carryOver = parseFloat(cardEl.querySelector('.carry-in-amount').value) || 0;
    
    card.settings.includePH = cardEl.querySelector('.include-ph').checked;
    card.settings.uplift.enabled = cardEl.querySelector('.july-uplift').checked;
    card.settings.uplift.percent = parseFloat(cardEl.querySelector('.uplift-rate').value) || 3.2;
    card.settings.calculateByGroup = cardEl.querySelector('.calculate-by-group').checked;
    
    // Update card class based on calculate by group setting
    if (card.settings.calculateByGroup) {
        cardEl.classList.add('calculate-by-group-active');
    } else {
        cardEl.classList.remove('calculate-by-group-active');
    }
    
    const stateSelect = cardEl.querySelector('.card-state');
    if (stateSelect) {
        card.state = stateSelect.value;
    }
    
    card.notes = cardEl.querySelector('.notes-input').value || '';
    
    // Update groups and items - YOUR EXISTING CODE for groups...
    const groupEls = cardEl.querySelectorAll('.group-panel');
    card.groups = [];
    
    groupEls.forEach(groupEl => {
        const groupNumber = groupEl.dataset.groupNumber;
        const catalogueGroup = state.catalogue[groupNumber];
        if (!catalogueGroup) return;
        
        const groupData = {
            regGroupNumber: groupNumber,
            regGroupName: catalogueGroup.regGroupName,
            items: []
        };
        
        const itemEls = groupEl.querySelectorAll('.item-row');
        itemEls.forEach((itemEl, index) => {
            const itemNumber = itemEl.dataset.itemNumber;
            const catalogueItem = catalogueGroup.items.find(i => i.supportItemNumber === itemNumber);
            if (!catalogueItem) return;
            
            // THIS IS THE KEY FIX - properly read the checkbox state
            const isSelected = itemEl.querySelector('.item-select').checked;
            
            const itemData = {
                ...catalogueItem,
                selected: isSelected,
                overridePrice: null,
                statePrice: catalogueItem.statePrices[card.state] || catalogueItem.statePrices['NSW'] || 0,
                hours: {},
                days: {},
                quantity: 0
            };
            
            // Only read hours/quantity if item is selected
            if (isSelected) {
                // Read hours/quantity from inputs
                if (catalogueItem.unit === 'H') {
                    if (catalogueItem.flags.isWeekday) {
                        const perDayInputs = itemEl.querySelector('.per-day-inputs');
                        if (perDayInputs && !perDayInputs.classList.contains('hidden')) {
                            // Per-day values
                            ['Mon', 'Tue', 'Wed', 'Thu', 'Fri'].forEach((day, i) => {
                                const input = perDayInputs.children[i].querySelector('.hours-input');
                                if (input) {
                                    itemData.hours[day] = validateHours(input.value);
                                }
                            });
                        } else {
                            // Single weekday value
                            const weekdayInput = itemEl.querySelector('.hours-input');
                            if (weekdayInput) {
                                itemData.hours.weekday = validateHours(weekdayInput.value);
                            }
                        }
                    } else {
                        const input = itemEl.querySelector('.hours-input');
                        if (input) {
                            if (catalogueItem.flags.isSaturday) {
                                itemData.hours.saturday = validateHours(input.value);
                            } else if (catalogueItem.flags.isSunday) {
                                itemData.hours.sunday = validateHours(input.value);
                            } else if (catalogueItem.flags.isPublicHoliday) {
                                itemData.hours.publicHoliday = validateHours(input.value);
                            }
                        }
                    }
                } else if (catalogueItem.unit === 'E') {
                    const eType = getEItemType(catalogueItem.supportItemName);
                    
                    if (eType === 'daily') {
                        // Read checkbox states
                        itemData.days = {};
                        const checkboxes = itemEl.querySelectorAll('.day-checkbox');
                        checkboxes.forEach(cb => {
                            itemData.days[cb.dataset.day] = cb.checked;
                        });
                    } else {
                        // Read quantity
                        const quantityInput = itemEl.querySelector('.quantity-input');
                        if (quantityInput) {
                            itemData.quantity = parseFloat(quantityInput.value) || 0;
                        }
                    }
                }
            }
            
            groupData.items.push(itemData);
        });
        
        // Read group budget values if calculate by group is enabled
        const budgetAmountInput = groupEl.querySelector('.group-budget-amount');
        const excludedAmountInput = groupEl.querySelector('.group-excluded-amount');
        const carryAmountInput = groupEl.querySelector('.group-carry-amount');
        
        if (budgetAmountInput) {
            if (!groupData.budget) groupData.budget = {};
            groupData.budget.total = parseFloat(budgetAmountInput.value) || 0;
            groupData.budget.excluded = parseFloat(excludedAmountInput.value) || 0;
            groupData.budget.carryOver = parseFloat(carryAmountInput.value) || 0;
        }
        
        card.groups.push(groupData);
    });
    
    // Update the totals after reading all the data
    updateCardTotals(cardEl, card);
}
function generateFilename(card) {
    const parts = [];
    
    if (card.participant.name) {
        parts.push(sanitizeFilename(card.participant.name));
    }
    
    if (card.participant.ndisNumber) {
        parts.push(card.participant.ndisNumber);
    }
    
    if (card.period.start) {
        // card.period.start is yyyy-mm-dd string, convert to dd-mm-yyyy
        const startDate = new Date(card.period.start);
        parts.push(formatDateDDMMYYYY(startDate));
    }
    
    if (card.period.end) {
        const endDate = new Date(card.period.end);
        parts.push(formatDateDDMMYYYY(endDate));
    }
    
    return parts.join('_') + '.csv';
}

function showPublicHolidaysModal(card) {
    const modal = document.getElementById('ph-modal');
    const list = document.getElementById('ph-list');
    
    list.innerHTML = '';
    
    const startDate = new Date(card.period.start);
    const endDate = new Date(card.period.end);
    
    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                       'July', 'August', 'September', 'October', 'November', 'December'];
    
    state.publicHolidays.forEach(ph => {
        const phDate = new Date(ph.date);
        if (phDate >= startDate && phDate <= endDate) {
            const item = document.createElement('div');
            item.className = 'ph-item';
            
            const dateEl = document.createElement('span');
            dateEl.className = 'ph-date';
            // Format as "5 July, 2025"
            dateEl.textContent = `${phDate.getDate()} ${monthNames[phDate.getMonth()]}, ${phDate.getFullYear()}`;
            
            const nameEl = document.createElement('span');
            nameEl.className = 'ph-name';
            nameEl.textContent = ph.name;
            
            item.appendChild(dateEl);
            item.appendChild(nameEl);
            
            list.appendChild(item);
        }
    });
    
    // Add a note about what happens on these days
    const note = document.createElement('p');
    note.className = 'ph-note';
    note.innerHTML = card.settings.includePH 
        ? '<strong>Public holidays included:</strong> Only public holiday items will be billed on these days (except sleepover at designated rate).'
        : '<strong>Public holidays excluded:</strong> No items will be billed on these days (except sleepover at standard rate).';
    list.appendChild(note);
    
    modal.classList.add('show');
}

// ===== Storage Functions =====
function saveState() {
    if (isSaving) return;
    isSaving = true;
    
    localStorage.setItem(STORAGE_KEYS.CARDS, JSON.stringify(state.cards));
    localStorage.setItem(STORAGE_KEYS.PREFERENCES, JSON.stringify(state.preferences));
    if (state.catalogue) {
        localStorage.setItem(STORAGE_KEYS.CATALOGUE, JSON.stringify(state.catalogue));
    }
    
    isSaving = false;
}



async function loadState() {
    try {
        const cards = localStorage.getItem(STORAGE_KEYS.CARDS);
        if (cards) {
            state.cards = JSON.parse(cards);
        }
        
        const prefs = localStorage.getItem(STORAGE_KEYS.PREFERENCES);
        if (prefs) {
            state.preferences = { ...state.preferences, ...JSON.parse(prefs) };
        }
        
        // Try to load catalogue from cache, or fetch from Supabase
        const cachedCatalogue = localStorage.getItem(STORAGE_KEYS.CATALOGUE);
        if (cachedCatalogue) {
            state.catalogue = JSON.parse(cachedCatalogue);
        } else {
            try {
                state.catalogue = await fetchCatalogueFromSupabase();
                localStorage.setItem(STORAGE_KEYS.CATALOGUE, JSON.stringify(state.catalogue));
            } catch (error) {
                state.catalogue = null;
                throw error; // Re-throw to be caught by init()
            }
        }
        
        // Always fetch holidays from Supabase
        try {
            state.publicHolidays = await fetchPublicHolidays();
        } catch (error) {
            state.publicHolidays = [];
        }
        
    } catch (error) {
        throw error; // Re-throw for init to handle
    }
}

async function init() {
    try {
        await loadState();
    } catch (error) {
        console.error('Init error:', error);
        // Show the actual error message
        alert(`Error: ${error.message}\n\nCheck the browser console for details.`);
    }
    
    if (!state.catalogue || Object.keys(state.catalogue).length === 0) {
        // Don't show the generic message if we already showed an error
        if (!state.catalogue) {
            console.error('Catalogue is null');
        } else {
            console.error('Catalogue is empty');
        }
    }
    
    // Remove these lines - state is now per-card, not global
    // document.getElementById('default-state').value = state.preferences.state;
    
    // Render existing cards
    const container = document.getElementById('cards-container');
state.cards.forEach(card => {
    container.appendChild(renderCard(card));
});


// Add this to sync the data after rendering
setTimeout(() => {
    const cardEls = container.querySelectorAll('.budget-card');
    cardEls.forEach(cardEl => {
        updateCardFromDOM(cardEl);
    });
}, 100);

    
    document.getElementById('new-card-btn').onclick = () => {
        if (!state.catalogue) {
            showError('Catalogue is still loading, please wait...');
            return;
        }
        
        const card = createCard();
        state.cards.push(card);
        const cardEl = renderCard(card);
        container.appendChild(cardEl);
        cardEl.scrollIntoView({ behavior: 'smooth' });
        saveState();
    };
    
    // Remove this handler - state is now per-card
    // document.getElementById('default-state').onchange = (e) => {
    //     state.preferences.state = e.target.value;
    //     saveState();
    // };
    
    // Modal close buttons
    document.querySelectorAll('.close-modal').forEach(btn => {
        btn.onclick = (e) => {
            e.target.closest('.modal').classList.remove('show');
        };
    });
    
    // Click outside modal to close
    document.querySelectorAll('.modal').forEach(modal => {
        modal.onclick = (e) => {
            if (e.target === modal) {
                modal.classList.remove('show');
            }
        };
    });
    
    // CSV import handler
    document.getElementById('csv-import').onchange = async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    try {
        showLoading('Importing CSV...');
        const data = await parseExportedCsv(file); // Now returns {metadata, rows}
        const card = createCardFromCsvRows(data);
        
        if (card) {
            state.cards.push(card);
            const cardEl = renderCard(card);
            document.getElementById('cards-container').appendChild(cardEl);
            cardEl.scrollIntoView({ behavior: 'smooth' });
            saveState();
            hideLoading();
            
            // Update message based on whether metadata was found
            if (data.metadata) {
                showError('CSV imported successfully with all details!');
            } else {
                showError('CSV imported successfully! Please enter participant name and budget.');
            }
        } else {
            hideLoading();
            showError('No data found in CSV');
        }
    } catch (error) {
        hideLoading();
        showError('Error importing CSV: ' + error.message);
    }
};

    // Upload menu handlers
    const uploadToggle = document.querySelector('.upload-menu-toggle');
    const uploadDropdown = document.querySelector('.upload-dropdown');
    
    if (uploadToggle && uploadDropdown) {
        uploadToggle.onclick = (e) => {
            e.stopPropagation();
            uploadDropdown.classList.toggle('hidden');
        };
        
        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!uploadToggle.contains(e.target) && !uploadDropdown.contains(e.target)) {
                uploadDropdown.classList.add('hidden');
            }
        });
    }
    
    // QR Scanner button handler (now in dropdown)
    document.getElementById('qr-scan-btn').onclick = () => {
        uploadDropdown.classList.add('hidden'); // Close dropdown
        const modal = document.getElementById('qr-scanner-modal');
        modal.classList.add('show');
        
        // Initialize scanner when modal opens
        setTimeout(() => {
            initQRScanner();
        }, 100);
    };
    
    // CSV import button handler (now in dropdown)
    document.getElementById('csv-import-btn').onclick = () => {
        uploadDropdown.classList.add('hidden'); // Close dropdown
        document.getElementById('csv-import').click();
    };
    
    // Multi-period report button handler
    document.getElementById('multi-period-report-btn').onclick = async () => {
        if (state.cards.length === 0) {
            showError('No funding periods available to report on');
            return;
        }
        
        await generateMultiPeriodReport();
    };
    
    // Close QR scanner properly when modal closes
    document.querySelectorAll('.modal').forEach(modal => {
        modal.addEventListener('click', (e) => {
            if (modal.id === 'qr-scanner-modal' && (e.target === modal || e.target.classList.contains('close-modal'))) {
                if (html5QrCode && html5QrCode.isScanning) {
                    html5QrCode.stop().then(() => {
                        modal.classList.remove('show');
                        // Reset the action buttons
                        document.getElementById('qr-actions').classList.add('hidden');
                        document.querySelector('.qr-scanner-info').textContent = 'Position the QR code from an NDIS report within the frame';
                    }).catch(err => {
                        console.error('Error stopping QR scanner:', err);
                        modal.classList.remove('show');
                    });
                }
            }
        });
    });
}
// Start the app
document.addEventListener('DOMContentLoaded', () => init());
</script>
</body>
</html>

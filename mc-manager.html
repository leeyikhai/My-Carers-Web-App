<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>MC Manager - Complete System</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <title>My Carers</title>
  
    <!-- favicon links -->
    <link rel="icon" type="image/png" sizes="16x16" href="https://gqchhsayqxttewthcsah.supabase.co/storage/v1/object/public/Branding/mc-favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://gqchhsayqxttewthcsah.supabase.co/storage/v1/object/public/Branding/mc-favicon-32x32.png">

    <style>

      
        :root {

            .participant-badge {
    display: inline-block;
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 500;
    color: white;
    white-space: nowrap;
}

.location-badge {
    display: inline-block;
    padding: 4px 12px;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 500;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    white-space: nowrap;
}
          

          /* Add to your existing styles */
@media (max-width: 768px) {
    /* Header adjustments */
    .header-content {
        flex-direction: column;
        padding: 12px;
        gap: 8px;
    }
    
    /* View toggle stack vertically */
    .view-toggle {
        flex-direction: column;
        width: 100%;
    }
    
    .view-toggle button {
        width: 100%;
        padding: 12px;
    }
    
    /* Table responsive */
    .roster-table {
        font-size: 11px;
    }
    
    .roster-table th,
    .roster-table td {
        padding: 8px 4px;
    }
    
    /* Hide less important columns on mobile */
    .roster-table th:nth-child(5),
    .roster-table td:nth-child(5) {
        display: none; /* Hide location column */
    }
    
    /* Timesheet responsive */
    .timesheet-table {
        font-size: 11px;
    }
    
    .timesheet-table th,
    .timesheet-table td {
        padding: 8px 4px;
    }
    
    /* Stack hour breakdown vertically */
    .hour-breakdown-item {
        display: block;
        margin-bottom: 4px;
    }
    
    /* Modal full screen on mobile */
    .modal {
        max-width: 100%;
        width: 100%;
        height: 100vh;
        border-radius: 0;
    }
    
    /* Filters stack vertically */
    .filter-row {
        grid-template-columns: 1fr;
    }
    
    /* Week navigation stack */
    .week-nav {
        flex-direction: column;
        gap: 12px;
    }
    
    .week-nav button {
        width: 100%;
    }
    
    /* Cards full width */
    .card {
        margin: 8px;
    }
    
    /* Request items stack content */
    .request-item {
        font-size: 13px;
    }
    
    .request-actions {
        flex-direction: column;
    }
    
    .request-actions .btn {
        width: 100%;
    }
    
    /* Summary cards stack */
    .summary-grid {
        grid-template-columns: 1fr;
    }
    
    /* Availability grid smaller */
    .availability-grid {
        font-size: 10px;
        grid-template-columns: 80px repeat(7, 1fr);
    }
    
    .availability-cell {
        padding: 6px;
        min-height: 35px;
    }
}

@media (max-width: 480px) {
    /* Even smaller screens */
    .roster-table {
        font-size: 10px;
    }
    
    /* Show only essential columns */
    .roster-table th:nth-child(6),
    .roster-table td:nth-child(6) {
        display: none; /* Hide duty type */
    }
    
    /* Compact timesheet */
    .timesheet-wrapper {
        margin: 0;
        border-radius: 0;
    }
    
    /* Smaller buttons */
    .btn {
        padding: 6px 12px;
        font-size: 12px;
    }
    
    .btn-sm {
        padding: 4px 8px;
        font-size: 11px;
    }
}
            --primary-color: #004990;
            --primary-hover: #003d75;
            --success-color: #88a542;
            --success-hover: #7a9339;
            --info-color: #359dca;
            --info-hover: #2e8bb5;
            --warning-color: #f39c12;
            --warning-hover: #e67e22;
            --danger-color: #e74c3c;
            --danger-hover: #c0392b;
            
            --text-primary: #2c3e50;
            --text-secondary: #34495e;
            --text-muted: #7f8c8d;
            --text-light: #95a5a6;
            
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-light: #ecf0f1;
            
            --border-color: #bdc3c7;
            --border-light: #ecf0f1;
            
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 15px rgba(0,0,0,0.1);
            
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 12px;
            
            --transition: all 0.2s ease-in-out;
            --font-size-xs: 0.75rem;
            --font-size-sm: 0.875rem;
            --font-size-base: 1rem;
            --font-size-lg: 1.125rem;
            --font-size-xl: 1.25rem;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            line-height: 1.6;
            font-size: var(--font-size-base);
        }

        /* Header Styles */
        .header {
            background: var(--bg-primary);
            box-shadow: var(--shadow-sm);
            position: sticky;
            top: 0;
            z-index: 1000;
            border-bottom: 1px solid var(--border-light);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 64px;
        }

        .logo {
            font-size: var(--font-size-xl);
            font-weight: 700;
            color: var(--primary-color);
            letter-spacing: -0.5px;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .user-name {
            font-weight: 500;
            color: var(--text-secondary);
            font-size: var(--font-size-base);
        }

        .user-role {
            background: var(--primary-color);
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: var(--font-size-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Container */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 24px;
        }

        /* Button System */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 8px 16px;
            border: none;
            border-radius: var(--radius-md);
            font-size: var(--font-size-sm);
            font-weight: 500;
            line-height: 1.4;
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
            white-space: nowrap;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--primary-hover);
            transform: translateY(-1px);
        }

        .btn-success {
            background: var(--success-color);
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: var(--success-hover);
            transform: translateY(-1px);
        }

        .btn-warning {
            background: var(--warning-color);
            color: white;
        }

        .btn-warning:hover:not(:disabled) {
            background: var(--warning-hover);
            transform: translateY(-1px);
        }

        .btn-danger {
            background: var(--danger-color);
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: var(--danger-hover);
            transform: translateY(-1px);
        }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        .btn-outline:hover:not(:disabled) {
            background: var(--bg-light);
            border-color: var(--text-secondary);
        }

        .btn-sm {
            padding: 4px 12px;
            font-size: var(--font-size-xs);
        }

        .btn-lg {
            padding: 12px 24px;
            font-size: var(--font-size-base);
        }

        /* Card System */
        .card {
            background: var(--bg-primary);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-light);
            overflow: hidden;
            transition: var(--transition);
        }

        .card:hover {
            box-shadow: var(--shadow-md);
        }

        .card-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border-light);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-secondary);
        }

        .card-title {
            font-size: var(--font-size-lg);
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }

        .card-content {
            padding: 24px;
        }

        /* View Controls */
        .view-controls {
            background: var(--bg-primary);
            padding: 24px;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            margin-bottom: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 16px;
        }

        .view-toggle {
            display: flex;
            background: var(--bg-light);
            border-radius: var(--radius-md);
            padding: 4px;
            gap: 2px;
        }

        .view-toggle button {
            padding: 10px 16px;
            border: none;
            background: transparent;
            border-radius: var(--radius-sm);
            font-size: var(--font-size-sm);
            font-weight: 500;
            color: var(--text-muted);
            cursor: pointer;
            transition: var(--transition);
        }

        .view-toggle button.active {
            background: var(--bg-primary);
            color: var(--text-primary);
            box-shadow: var(--shadow-sm);
        }

        .view-toggle button:hover:not(.active) {
            color: var(--text-secondary);
        }

        .view-actions {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        /* Week Navigation */
        .week-nav {
            background: var(--bg-primary);
            padding: 20px 24px;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            margin-bottom: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 24px;
        }

        .week-display {
            font-size: var(--font-size-lg);
            font-weight: 600;
            color: var(--text-primary);
            min-width: 250px;
            text-align: center;
        }

        /* Filters */
        .filters {
            background: var(--bg-primary);
            padding: 24px;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            margin-bottom: 24px;
        }

        .filter-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            align-items: end;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
        }

        .filter-group label {
            font-weight: 500;
            margin-bottom: 8px;
            color: var(--text-secondary);
            font-size: var(--font-size-sm);
        }

        .filter-group input, 
        .filter-group select {
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            font-size: var(--font-size-sm);
            background: var(--bg-primary);
            transition: var(--transition);
        }

        .filter-group input:focus, 
        .filter-group select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0, 73, 144, 0.1);
        }

        .searchable-dropdown {
            position: relative;
        }

        .searchable-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            font-size: var(--font-size-sm);
            background: var(--bg-primary);
            transition: var(--transition);
        }

        .searchable-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0, 73, 144, 0.1);
        }

        /* Table System */
        .table-container {
            background: var(--bg-primary);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            overflow: hidden;
            margin-bottom: 24px;
            border: 1px solid var(--border-light);
        }

        .table-header {
            padding: 24px;
            border-bottom: 1px solid var(--border-light);
            background: var(--bg-secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 16px;
        }

        .table-title {
            font-size: var(--font-size-xl);
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }

        .table-actions {
            display: flex;
            gap: 12px;
        }

        .roster-table {
            width: 100%;
            border-collapse: collapse;
            font-size: var(--font-size-sm);
        }

        .roster-table th {
            background: var(--bg-light);
            padding: 16px 12px;
            text-align: left;
            font-weight: 600;
            font-size: var(--font-size-xs);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            border-bottom: 2px solid var(--border-color);
        }

        .roster-table td {
            padding: 16px 12px;
            border-bottom: 1px solid var(--border-light);
            vertical-align: top;
            line-height: 1.4;
        }

        .roster-table tr:hover:not(.day-header) {
            background: var(--bg-secondary);
        }

        /* Day Color Coding - Subtle Left Border */
        .monday-shift { border-left: 4px solid #e91e63; }
        .tuesday-shift { border-left: 4px solid #ff9800; }
        .wednesday-shift { border-left: 4px solid #4caf50; }
        .thursday-shift { border-left: 4px solid #2196f3; }
        .friday-shift { border-left: 4px solid #9c27b0; }
        .saturday-shift { border-left: 4px solid #673ab7; }
        .sunday-shift { border-left: 4px solid #f44336; }

        /* Day Headers */
        .day-header {
            background: linear-gradient(135deg, var(--primary-color), var(--info-color)) !important;
        }

        .day-header td {
            color: white !important;
            font-weight: 600;
            padding: 12px 16px;
        }

        .day-stats {
            float: right;
            background: rgba(255,255,255,0.2);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: var(--font-size-xs);
            font-weight: 500;
        }

        /* Status System */
        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: var(--font-size-xs);
            font-weight: 500;
            text-transform: capitalize;
        }

        .status-scheduled, .status-confirmed {
            background: #e3f2fd;
            color: #1565c0;
        }

        .status-completed {
            background: #e8f5e8;
            color: #2e7d32;
        }

        .status-no_show, .status-cancelled {
            background: #ffebee;
            color: #c62828;
        }

        .status-pending {
            background: #fff8e1;
            color: #f57c00;
        }

        /* Hour and Pay Display */
        .hour-breakdown {
            cursor: help;
            border-bottom: 1px dotted var(--text-muted);
            position: relative;
            font-weight: 600;
        }

        .pay-breakdown {
            font-size: var(--font-size-xs);
            color: var(--text-muted);
            margin-top: 4px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            line-height: 1.3;
        }

        .pay-override {
            background: #fff3cd;
            border-left: 3px solid var(--warning-color);
            padding: 4px 8px;
            font-size: var(--font-size-xs);
            border-radius: var(--radius-sm);
            margin-top: 4px;
            color: #856404;
        }

        .transfer-pending, .adjustment-pending {
            display: inline-block;
            padding: 2px 8px;
            border-radius: var(--radius-sm);
            font-size: var(--font-size-xs);
            font-weight: 500;
            margin-top: 4px;
        }

        .transfer-pending {
            background: #fff3cd;
            color: #856404;
        }

        .adjustment-pending {
            background: #e1d5ff;
            color: #5b21b6;
        }

        .hour-warning {
            background: #f8d7da;
            color: #721c24;
            padding: 12px 16px;
            border-radius: var(--radius-md);
            font-size: var(--font-size-sm);
            font-weight: 500;
            margin-top: 12px;
            border: 1px solid #f5c6cb;
        }

        /* Modal System */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal {
            background: var(--bg-primary);
            border-radius: var(--radius-lg);
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow-lg);
        }

        .modal.large {
            max-width: 800px;
        }

        .modal-header {
            padding: 24px;
            border-bottom: 1px solid var(--border-light);
            background: var(--bg-secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: var(--font-size-lg);
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-muted);
            padding: 4px;
            border-radius: var(--radius-sm);
            transition: var(--transition);
        }

        .modal-close:hover {
            background: var(--bg-light);
            color: var(--text-primary);
        }

        .modal-content {
            padding: 24px;
            overflow: auto;
            flex: 1;
        }

        .modal-footer {
            padding: 20px 24px;
            border-top: 1px solid var(--border-light);
            background: var(--bg-secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .modal-footer .btn-danger {
            margin-right: auto;
        }

        .modal-footer .modal-actions {
            display: flex;
            gap: 12px;
        }

        /* Form System */
        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-secondary);
            font-size: var(--font-size-sm);
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            font-size: var(--font-size-sm);
            background: var(--bg-primary);
            transition: var(--transition);
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0, 73, 144, 0.1);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 100px;
            line-height: 1.5;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        /* View Content */
        .view-content {
            display: none;
        }

        .view-content.active {
            display: block;
        }

        /* Summary Grid */
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 24px;
            margin-bottom: 24px;
        }

        .summary-card {
            background: var(--bg-primary);
            padding: 24px;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-light);
        }

        .summary-card h3 {
            margin-bottom: 20px;
            color: var(--text-primary);
            font-size: var(--font-size-lg);
            font-weight: 600;
            border-bottom: 1px solid var(--border-light);
            padding-bottom: 12px;
        }

        .summary-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-light);
        }

        .summary-item:last-child {
            border-bottom: none;
        }

        .summary-item-details {
            font-size: var(--font-size-xs);
            color: var(--text-muted);
            margin-top: 4px;
            line-height: 1.4;
        }

        /* Loading States */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            color: var(--text-muted);
            flex-direction: column;
            gap: 12px;
        }

        .spinner {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border-light);
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Notification System */
        .notification {
            position: fixed;
            top: 24px;
            right: 24px;
            padding: 16px 20px;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-lg);
            z-index: 10000;
            max-width: 400px;
            animation: slideIn 0.3s ease-out;
            border: 1px solid transparent;
        }

        .notification.success {
            background: var(--success-color);
            color: white;
            border-color: var(--success-hover);
        }

        .notification.error {
            background: var(--danger-color);
            color: white;
            border-color: var(--danger-hover);
        }

        .notification.info {
            background: var(--info-color);
            color: white;
            border-color: var(--info-hover);
        }

        .notification.warning {
            background: var(--warning-color);
            color: white;
            border-color: var(--warning-hover);
        }

        @keyframes slideIn {
            from { 
                transform: translateX(100%); 
                opacity: 0; 
            }
            to { 
                transform: translateX(0); 
                opacity: 1; 
            }
        }

        /* Empty States */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-muted);
        }

        .empty-state h3 {
            color: var(--text-secondary);
            margin-bottom: 12px;
        }

        .empty-state p {
            margin-bottom: 20px;
            line-height: 1.5;
        }

        /* Holiday Management */
        .holiday-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            margin-bottom: 8px;
            border: 1px solid var(--border-light);
        }

        .holiday-form {
            padding: 20px;
            background: var(--bg-light);
            border-radius: var(--radius-md);
            margin-bottom: 20px;
            border: 1px solid var(--border-light);
        }

        .overlap-indicator {
    display: inline-block;
    background: #ffc107;
    color: #000;
    padding: 2px 6px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: bold;
    margin-left: 8px;
    cursor: help;
}

.overlap-tooltip {
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 12px;
    z-index: 10000;
    max-width: 300px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

@keyframes slideIn {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
}
@keyframes slideOut {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(100%); opacity: 0; }
}



.status-pending {
    background: #fff3cd;
    color: #856404;
}

.status-confirmed {
    background: #d4edda;
    color: #155724;
}

.status-completed {
    background: #cce5ff;
    color: #004085;
}
        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 16px;
            }
            
            .header-content {
                padding: 0 16px;
                flex-direction: column;
                height: auto;
                gap: 12px;
                padding-top: 12px;
                padding-bottom: 12px;
            }
            
            .view-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .view-toggle {
                justify-content: center;
            }
            
            .view-actions {
                justify-content: center;
            }
            
            .week-nav {
                flex-direction: column;
                gap: 16px;
            }
            
            .filter-row {
                grid-template-columns: 1fr;
                gap: 16px;
            }
            
            .table-header {
                flex-direction: column;
                align-items: stretch;
            }
            
            .table-actions {
                justify-content: center;
            }
            
            .roster-table {
                font-size: var(--font-size-xs);
            }

            .roster-table th,
            .roster-table td {
                padding: 12px 8px;
            }
            
            .modal {
                max-width: 95%;
                margin: 0 auto;
            }
            
            .modal-footer {
                flex-direction: column;
                gap: 12px;
            }
            
            .modal-footer .btn-danger {
                margin-right: 0;
                order: 2;
            }
            
            .modal-footer .modal-actions {
                order: 1;
                width: 100%;
                justify-content: stretch;
            }
            
            .modal-actions .btn {
                flex: 1;
            }
        }

        @media (max-width: 480px) {
            .summary-grid {
                grid-template-columns: 1fr;
            }
            
            .roster-table th,
            .roster-table td {
                padding: 8px 4px;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <img src="https://gqchhsayqxttewthcsah.supabase.co/storage/v1/object/public/Branding/LOGO%20No%20Background.png" 
            alt="My Carers Logo" 
            width="200">
                        <div class="user-info">
                <span class="user-name" id="userName">Loading...</span>
                <span class="user-role" id="userRole">Staff</span>
                <button class="btn btn-outline btn-sm" onclick="logout()">Logout</button>
            </div>
        </div>
    </header>

    <main class="container">
        <!-- View Controls -->
        <section class="view-controls">
          <div class="view-toggle">
            <button onclick="switchView('table')" class="active" id="tableViewBtn">Roster</button>
            <button onclick="switchView('requests')" id="requestsViewBtn">Requests</button>
            <button onclick="switchView('templates')" data-view="templates" id="templatesViewBtn">Templates</button><button onclick="switchView('conflicts')" id="conflictsViewBtn" class="btn btn-danger btn-sm">Conflicts</button>        
<button onclick="switchView('summary')" id="summaryViewBtn">Summary</button>
            <button onclick="switchView('timesheet')" id="timesheetViewBtn">Timesheet</button>
            <button onclick="switchView('notes')" id="notesViewBtn">Notes</button>
            <button onclick="switchView('availability')" id="availabilityViewBtn">Availability</button>
        </div>        
            <div class="view-actions">
              <button class="btn btn-outline btn-sm" id="undoBtn" onclick="UndoRedoManager.undo()" disabled title="Nothing to undo (Ctrl+Z)">↶ Undo</button>
              <button class="btn btn-outline btn-sm" id="redoBtn" onclick="UndoRedoManager.redo()" disabled title="Nothing to redo (Ctrl+Y)">↷ Redo</button>
              <span style="border-left: 1px solid var(--border-color); margin: 0 8px; height: 24px;"></span>
              <button class="btn btn-primary" onclick="showAddShiftModal()">Add Shift</button>
              <button class="btn btn-warning" onclick="showPublicHolidayModal()">Holidays</button>
              <button class="btn btn-success btn-sm" onclick="generatePayrollSummary()">Payroll</button>
              <button class="btn btn-success btn-sm" onclick="exportData()">Export</button>
              <button class="btn btn-outline btn-sm" onclick="debugDataLoading()" style="background: #ff6b6b; color: white;">Debug</button>
          </div>
          
        </section>

        <!-- Week Navigation -->
        <section class="week-nav">
            <button class="btn btn-outline" onclick="previousWeek">Previous Week</button>
            <div class="week-display" id="weekDisplay">Loading...</div>
            <button class="btn btn-outline" onclick="nextWeek">Next Week</button>
            <button class="btn btn-primary btn-sm" onclick="goToCurrentWeek()">This Week</button>
        </section>

        <!-- Filters -->
        <section class="filters">
            <div class="filter-row">
                <div class="filter-group">
                    <label>Start Date</label>
                    <input type="date" id="startDate" onchange="applyFilters()">
                </div>
                <div class="filter-group">
                    <label>End Date</label>
                    <input type="date" id="endDate" onchange="applyFilters()">
                </div>
                <div class="filter-group">
                    <label>Staff</label>
                    <input type="text" class="searchable-input" id="staffFilterInput" 
                           placeholder="Type to search staff..." 
                           list="staffFilterList" onchange="updateStaffFilter()">
                    <datalist id="staffFilterList"></datalist>
                </div>
                <div class="filter-group">
                    <label>Participant</label>
                    <input type="text" class="searchable-input" id="participantFilterInput" 
                           placeholder="Type to search participants..." 
                           list="participantFilterList" onchange="updateParticipantFilter()">
                    <datalist id="participantFilterList"></datalist>
                </div>
                <div class="filter-group">
                    <label>Status</label>
                    <select id="statusFilter" onchange="applyFilters()">
                        <option value="">All Status</option>
                        <option value="scheduled">Scheduled</option>
                        <option value="confirmed">Confirmed</option>
                        <option value="completed">Completed</option>
                        <option value="no_show">No Show</option>
                        <option value="cancelled">Cancelled</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label>Actions</label>
                    <button class="btn btn-outline btn-sm" onclick="clearAllFilters()" style="width: 100%;">Clear Filters</button>
                </div>
            </div>
        </section>

        <!-- Table View -->
        <div id="tableView" class="view-content active">
            <div class="table-container">
                <header class="table-header">
                    <h2 class="table-title">Shift Roster</h2>
                    <div class="table-actions">
                        <button class="btn btn-outline btn-sm" onclick="refreshData()">Refresh</button>
                    </div>
                </header>
                <div style="overflow-x: auto;">
                  <table class="roster-table">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Time</th>
                            <th>Staff</th>
                            <th>Client</th>
                            <th>Location</th>
                            <th>Duty Type</th>
                            <th>Status</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="shiftsTableBody">
                        <tr>
                            <td colspan="8" class="loading">
                                <div class="spinner"></div>
                                <span>Loading shifts...</span>
                            </td>
                        </tr>
                    </tbody>
                </table>                
                </div>
            </div>
        </div>
       <div id="requestsView" class="view-content">
    <div class="table-container">
        <header class="table-header">
            <h2 class="table-title">Shift Requests Management</h2>
            <div class="table-actions">
                <button class="btn btn-outline btn-sm" onclick="renderRequests()">
                    <span style="margin-right: 4px;">🔄</span> Refresh
                </button>
                <button class="btn btn-primary btn-sm" onclick="showRequestTransferModal()" style="margin-left: 8px;">
                    <span style="margin-right: 4px;">➡️</span> Request Transfer
                </button>
                <button class="btn btn-info btn-sm" onclick="showRequestAdjustmentModal()" style="margin-left: 8px;">
                    <span style="margin-right: 4px;">⏰</span> Request Adjustment
                </button>
            </div>
        </header>
        <div class="card-content" id="requestsContent">
            <div class="loading">
                <div class="spinner"></div>
                <span>Loading requests...</span>
            </div>
        </div>
    </div>
</div>
        <!-- Summary View -->
        <div id="summaryView" class="view-content">
            <div class="summary-grid" id="summaryGrid">
                <div class="loading">
                    <div class="spinner"></div>
                    <span>Loading summary...</span>
                </div>
            </div>
        </div>

        <div id="templatesView" class="view-content" style="display: none;">
            <div class="table-container">
                <header class="table-header">
                    <h2 class="table-title">Roster Templates</h2>
                    <div class="table-actions">
                        <button class="btn btn-primary" onclick="openCreateTemplateModal()">
                            <span style="margin-right: 4px;"></span> New Template
                        </button>
                        <button class="btn btn-outline" onclick="loadTemplates()">
                            <span style="margin-right: 4px;">🔄</span> Refresh
                        </button>
                    </div>
                </header>
                <div id="templatesContent" style="padding: 24px;">
                    <!-- Templates will be loaded here -->
                </div>
            </div>
        </div>

        <!-- Timesheet View -->
        <div id="timesheetView" class="view-content">
            <div class="table-container">
                <header class="table-header">
                    <h2 class="table-title">Detailed Timesheet</h2>
                    <div class="table-actions">
                        <button class="btn btn-success btn-sm" onclick="exportTimesheet()">Export Timesheet</button>
                    </div>
                </header>
                <div class="card-content" id="timesheetContent">
                    <div class="loading">
                        <div class="spinner"></div>
                        <span>Loading timesheet...</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="conflictsView" class="view-content">
          <div id="conflictsContent"></div>
      </div>

        <!-- Notes View -->
        <div id="notesView" class="view-content">
            <div class="table-container">
                <header class="table-header">
                    <h2 class="table-title">Shift Notes</h2>
                    <div class="table-actions">
                        <button class="btn btn-primary btn-sm" onclick="showAddNoteModal()">Add Note</button>
                    </div>
                </header>
                <div class="card-content" id="notesContent">
                    <div class="loading">
                        <div class="spinner"></div>
                        <span>Loading notes...</span>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Edit Shift Modal -->
    <div id="editShiftModal" class="modal-overlay" style="display: none;">
        <div class="modal large">
            <header class="modal-header">
                <h3 class="modal-title">Edit Shift</h3>
                <button class="modal-close" onclick="closeModal('editShiftModal')">&times;</button>
            </header>
            <div class="modal-content">
                <form id="editShiftForm">
                    <input type="hidden" id="editShiftId">
                    <div class="form-group">
                        <label>Date *</label>
                        <input type="date" id="editShiftDate" required>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Start Time</label>
                            <input type="time" id="editShiftStartTime">
                        </div>
                        <div class="form-group">
                            <label>End Time</label>
                            <input type="time" id="editShiftEndTime">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Staff *</label>
                        <input type="text" class="searchable-input" id="editShiftStaffInput" 
                               placeholder="Type to search staff..." 
                               list="editStaffList" required onchange="updateEditStaffSelection()">
                        <datalist id="editStaffList"></datalist>
                        <input type="hidden" id="editShiftStaff">
                    </div>
                    <div class="form-group">
                        <label>Participant</label>
                        <input type="text" class="searchable-input" id="editShiftParticipantInput" 
                               placeholder="Type to search participants..." 
                               list="editParticipantList" onchange="updateEditParticipantSelection()">
                        <datalist id="editParticipantList"></datalist>
                        <input type="hidden" id="editShiftParticipant">
                    </div>
                    <div class="form-group">
                        <label>Location</label>
                        <select id="editShiftLocation">
                            <option value="">Select Location</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Duty Type *</label>
                        <select id="editShiftDutyType" required onchange="updateEditTimeFields()">
                            <option value="">Select Duty Type</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Pay Rate Override</label>
                        <select id="editShiftPayRate">
                            <option value="">Use Staff Default</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Status</label>
                        <select id="editShiftStatus">
                            <option value="scheduled">Scheduled</option>
                            <option value="confirmed">Confirmed</option>
                            <option value="completed">Completed</option>
                            <option value="no_show">No Show</option>
                            <option value="cancelled">Cancelled</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Notes</label>
                        <textarea id="editShiftNotes" placeholder="Shift notes..."></textarea>
                    </div>
                </form>
            </div>
            <footer class="modal-footer">
                <button class="btn btn-danger" onclick="deleteShiftConfirm()">Delete Shift</button>
                <div class="modal-actions">
                    <button class="btn btn-outline" onclick="closeModal('editShiftModal')">Cancel</button>
                    <button class="btn btn-primary" onclick="updateShift()">Save Changes</button>
                </div>
            </footer>
        </div>
    </div>

    <!-- Add Shift Modal -->
    <div id="addShiftModal" class="modal-overlay" style="display: none;">
        <div class="modal large">
            <header class="modal-header">
                <h3 class="modal-title">Add New Shift</h3>
                <button class="modal-close" onclick="closeModal('addShiftModal')">&times;</button>
            </header>
            <div class="modal-content">
                <form id="addShiftForm">
                    <div class="form-group">
                        <label>Date *</label>
                        <input type="date" id="shiftDate" required>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Start Time</label>
                            <input type="time" id="shiftStartTime">
                        </div>
                        <div class="form-group">
                            <label>End Time</label>
                            <input type="time" id="shiftEndTime">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Staff *</label>
                        <input type="text" class="searchable-input" id="shiftStaffInput" 
                               placeholder="Type to search staff..." 
                               list="staffDataList" required onchange="updateStaffSelection()">
                        <datalist id="staffDataList"></datalist>
                        <input type="hidden" id="shiftStaff">
                    </div>
                    <div class="form-group">
                        <label>Participant</label>
                        <input type="text" class="searchable-input" id="shiftParticipantInput" 
                               placeholder="Type to search participants..." 
                               list="participantDataList" onchange="updateParticipantSelection()">
                        <datalist id="participantDataList"></datalist>
                        <input type="hidden" id="shiftParticipant">
                    </div>
                    <div class="form-group">
                        <label>Location</label>
                        <select id="shiftLocation">
                            <option value="">Select Location</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Duty Type *</label>
                        <select id="shiftDutyType" required onchange="updateTimeFields()">
                            <option value="">Select Duty Type</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Pay Rate Override</label>
                        <select id="shiftPayRate">
                            <option value="">Use Staff Default</option>
                        </select>
                    </div>
                    <div id="hourWarningText" style="display: none;" class="hour-warning"></div>
                </form>
            </div>
            <footer class="modal-footer">
                <div class="modal-actions">
                    <button class="btn btn-outline" onclick="closeModal('addShiftModal')">Cancel</button>
                    <button class="btn btn-primary" onclick="createShift()">Create Shift</button>
                </div>
            </footer>
        </div>
    </div>

    <!-- Add Note Modal -->
    <div id="addNoteModal" class="modal-overlay" style="display: none;">
        <div class="modal">
            <header class="modal-header">
                <h3 class="modal-title">Add Shift Note</h3>
                <button class="modal-close" onclick="closeModal('addNoteModal')">&times;</button>
            </header>
            <div class="modal-content">
                <form id="addNoteForm">
                    <div class="form-group">
                        <label>Shift *</label>
                        <select id="noteShift" required>
                            <option value="">Select Shift</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Note Type *</label>
                        <select id="noteType" required>
                            <option value="shift">Shift Note (Visible to Managers)</option>
                            <option value="handover">Handover Note (Staff Only)</option>
                            <option value="incident">Incident Report</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Note *</label>
                        <textarea id="noteContent" required placeholder="Enter your note..."></textarea>
                    </div>
                </form>
            </div>
            <footer class="modal-footer">
                <div class="modal-actions">
                    <button class="btn btn-outline" onclick="closeModal('addNoteModal')">Cancel</button>
                    <button class="btn btn-primary" onclick="createNote()">Add Note</button>
                </div>
            </footer>
        </div>
    </div>

    <!-- Public Holiday Modal -->
    <div id="publicHolidayModal" class="modal-overlay" style="display: none;">
        <div class="modal large">
            <header class="modal-header">
                <h3 class="modal-title">Public Holidays Management</h3>
                <button class="modal-close" onclick="closeModal('publicHolidayModal')">&times;</button>
            </header>
            <div class="modal-content">
                <div style="margin-bottom: 24px;">
                    <button class="btn btn-primary btn-sm" onclick="showAddHolidayForm()">Add Holiday</button>
                    <button class="btn btn-outline btn-sm" onclick="loadAustralianHolidays()">Load AU Holidays</button>
                </div>
                
                <div id="addHolidayForm" class="holiday-form" style="display: none;">
                    <div class="form-row">
                        <div class="form-group">
                            <label>Holiday Date</label>
                            <input type="date" id="holidayDate">
                        </div>
                        <div class="form-group">
                            <label>Holiday Name</label>
                            <input type="text" id="holidayName" placeholder="e.g., Christmas Day">
                        </div>
                    </div>
                    <div style="display: flex; gap: 12px;">
                        <button class="btn btn-success btn-sm" onclick="addHoliday()">Add Holiday</button>
                        <button class="btn btn-outline btn-sm" onclick="cancelAddHoliday()">Cancel</button>
                    </div>
                </div>

                <div>
                    <h4 style="margin-bottom: 16px; color: var(--text-secondary);">Current Public Holidays</h4>
                    <div id="holidayList" style="max-height: 300px; overflow-y: auto;">
                        <div class="loading">
                            <div class="spinner"></div>
                            <span>Loading holidays...</span>
                        </div>
                    </div>
                </div>
            </div>
            <footer class="modal-footer">
                <div class="modal-actions">
                    <button class="btn btn-outline" onclick="closeModal('publicHolidayModal')">Close</button>
                </div>
            </footer>
        </div>
    </div>

    <script>
        // Initialize Supabase
        const supabaseUrl = 'https://gqchhsayqxttewthcsah.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdxY2hoc2F5cXh0dGV3dGhjc2FoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY2OTA0ODksImV4cCI6MjA3MjI2NjQ4OX0.iAGhrDZaHkpLwjJY07o-73l2OiePB2x1ZnnTEfUBd_M';
        const { createClient } = supabase;
        const supabaseClient = createClient(supabaseUrl, supabaseKey);

        let rosterTemplates = [];
let currentTemplate = null;
let templateShifts = [];
        let payRateLabels = new Map();
        let currentUser = null;
        let currentUserRole = 'staff';
        let currentStaffData = null;
        let shifts = [];
        let shiftId= [];
        let staff = [];
        let participants = [];
        let locations = [];
        let dutyTypes = [];
        let payRates = [];
        let filteredShifts = [];
        let currentView = 'table';
        let publicHolidays = new Set();
        let currentWeekStart = new Date();
        let staffFilterValue = '';
        let participantFilterValue = '';
        let undoStack = [];
let redoStack = [];
const MAX_UNDO_STACK = 20;
let careHomes = new Map(); 
let activeCareHomeFilter = null; 
const TIMEZONE = 'Australia/Sydney';
const LOCALE = 'en-AU';
const LOCATION_IDS = {
    SAUNDERS_CARE_HOME: "82be1e0c-7036-4063-b161-1ab91162c3e1",
    CLIENT_HOME: "00000000-0000-0000-0000-000000000001", 
    MY_CARERS_OFFICE: "e020835c-b8d8-46d2-81ac-4761cbe77f17"
};

const DB_ERRORS = {
    FOREIGN_KEY_VIOLATION: "23503", // Referenced record doesn't exist
    UNIQUE_VIOLATION: "23505",      // Duplicate entry
    NOT_NULL_VIOLATION: "23502"     // Required field missing
};

async function verifyDataConnections() {
    console.log('=== VERIFYING DATA CONNECTIONS ===');
    
    const tests = {
        // Test shifts table structure
        'Shifts ID type': async () => {
            const { data } = await supabaseClient.from('shifts').select('id').limit(1);
            return data?.[0]?.id ? `✅ Type: ${typeof data[0].id}` : '❌ No shifts';
        },
        
        // Test shift_adjustment_requests
        'Adjustment Request shift_id': async () => {
            const { error } = await supabaseClient
                .from('shift_adjustment_requests')
                .insert({ 
                    shift_id: 1, // Try integer
                    staff_id: staff[0]?.id,
                    reason: 'test'
                })
                .select();
            await supabaseClient.from('shift_adjustment_requests').delete().eq('reason', 'test');
            return error ? `❌ Error: ${error.message}` : '✅ Accepts integers';
        },
        
        // Test template day_of_week constraint
        'Template day_of_week range': async () => {
            const { data } = await supabaseClient
                .from('roster_template_shifts')
                .select('day_of_week')
                .order('day_of_week');
            const days = [...new Set(data?.map(d => d.day_of_week) || [])];
            return `Range: ${Math.min(...days)}-${Math.max(...days)} (Should be 0-6)`;
        },
        
        // Check loaded data
        'Staff loaded': staff?.length || 0,
        'Participants loaded': participants?.length || 0,
        'Locations loaded': locations?.length || 0,
        'Duty Types loaded': dutyTypes?.length || 0,
        'Current Staff': currentStaffData?.id ? '✅' : '❌'
    };
    
    for (const [test, check] of Object.entries(tests)) {
        const result = typeof check === 'function' ? await check() : check;
        console.log(`${test}: ${result}`);
    }
}

async function initializeApp() {
    try {
        console.log('=== INITIALIZING MC MANAGER ===');
        
        // Check authentication
        const { data: { session }, error } = await supabaseClient.auth.getSession();
        
        if (error) throw error;
        
        if (!session) {
            window.location.href = 'index.html';
            return;
        }

        currentUser = session.user;
        
        // Check both possible locations for role
        currentUserRole = currentUser.user_metadata?.role || 
                         currentUser.raw_user_meta_data?.role || 
                         'staff';
        
        console.log('User authenticated:', currentUser.email);
        console.log('User role detected:', currentUserRole);
        
        // Get staff record if linked
        if (currentUser.id) {
            const { data: staffData, error: staffError } = await supabaseClient
                .from('staff')
                .select('*')
                .eq('user_id', currentUser.id)
                .maybeSingle();
            
            if (staffError) {
                console.error('Error loading staff data:', staffError);
            }
            
            currentStaffData = staffData;
            console.log('Current staff data loaded:', currentStaffData);
        }

        // Update UI
        let displayName = 'Unknown User';
        
        if (currentStaffData) {
            displayName = `${currentStaffData.first_name} ${currentStaffData.last_name}`;
        } else if (currentUser.user_metadata?.first_name) {
            displayName = `${currentUser.user_metadata.first_name} ${currentUser.user_metadata.last_name || ''}`;
        } else if (currentUser.email) {
            displayName = currentUser.email.split('@')[0];
        }
        
        // Update the UI elements
        document.getElementById('userName').textContent = displayName;
        document.getElementById('userRole').textContent = 
            currentUserRole.charAt(0).toUpperCase() + currentUserRole.slice(1);

        // Initialize week navigation
        setCurrentWeek();
        
        // Load all data - make sure these functions exist
        console.log('Loading initial data...');
        await loadInitialData();
        
        console.log('Loading public holidays...');
        await loadPublicHolidays();
        
        console.log('Loading shifts...');
        await loadShifts();

        console.log('=== INITIALIZATION COMPLETE ===');

    } catch (error) {
        console.error('CRITICAL: Initialization error:', error);
        document.getElementById('userName').textContent = 'Error Loading';
        document.getElementById('userRole').textContent = 'Error';
        showNotification('Failed to initialize: ' + error.message, 'error');
    }
}

async function enrichRequestData(requests, type) {
    if (!requests || requests.length === 0) return [];
    
    return await Promise.all(requests.map(async req => {
        const shift = shifts.find(s => s.id === req.shift_id);
        const participant = shift ? participants.find(p => p.id === shift.participant_id) : null;
        const location = shift ? locations.find(l => l.id === shift.location_id) : null;
        
        const baseEnrichment = {
            ...req,
            shift: shift ? {
                ...shift,
                participant,
                location,
                participantName: participant ? 
                    `${participant.first_name} ${participant.last_name}` : 
                    (location?.name || 'Unassigned')
            } : null
        };
        
        if (type === 'transfer') {
            return {
                ...baseEnrichment,
                fromStaff: staff.find(s => s.id === req.from_staff_id),
                toStaff: req.to_staff_id ? staff.find(s => s.id === req.to_staff_id) : null
            };
        } else if (type === 'adjustment') {
            return {
                ...baseEnrichment,
                staff: staff.find(s => s.id === req.staff_id)
            };
        }
        
        return baseEnrichment;
    }));
}

async function requestTransfer(shiftId) {
    const { data, error } = await supabaseClient
        .from('transfer_requests')
        .insert({
            shift_id: parseInt(shiftId), // CRITICAL: Convert to INTEGER
            from_staff_id: currentStaff.id,
            to_staff_id: null,
            status: 'pending',
            reason: 'Personal reason',
            created_at: new Date().toISOString() // Add required field
        });
    
    if (error) {
        console.error('Transfer request error:', error);
        if (error.code === DB_ERRORS.FOREIGN_KEY_VIOLATION) {
            showToast('Invalid shift reference', 'error');
        } else {
            showToast('Failed to request transfer', 'error');
        }
    } else {
        showToast('Transfer request submitted', 'success');
    }
}

async function refreshAfterChange() {
    await loadShifts(); // Reload base data
    
    // Refresh the current active view
    if (currentView === 'conflicts') {
        await renderConflicts();
    } else if (currentView === 'requests') {
        await renderRequests();
    } else if (currentView === 'timesheet') {
        await renderTimesheet();
    } else if (currentView === 'notes') {
        await renderNotes();
    } else if (currentView === 'summary') {
        await renderSummary();
    } else if (currentView === 'table') {
        renderTable();
    } else {
        renderCurrentView();
    }
}

async function renderRequests() {
    const requestsContent = document.getElementById('requestsContent');
    if (!requestsContent) return;
    
    try {
        // Load pending shifts
        const { data: pendingShifts } = await supabaseClient
            .from('shifts')
            .select(`
                *,
                staff:staff_id(first_name, last_name),
                participants:participant_id(first_name, last_name),
                locations:location_id(name),
                duty_types:duty_type_id(name)
            `)
            .eq('status', 'pending')
            .order('created_at', { ascending: false });

        // Load transfer requests
        const { data: transferRequests } = await supabaseClient
            .from('transfer_requests')
            .select('*')
            .order('created_at', { ascending: false });
        
        // Load adjustment requests
        const { data: adjustmentRequests } = await supabaseClient
            .from('shift_adjustment_requests')
            .select('*')
            .order('created_at', { ascending: false });
        
        // Enrich requests with related data
        const enrichedTransferRequests = await enrichRequestData(transferRequests, 'transfer');
        const enrichedAdjustmentRequests = await enrichRequestData(adjustmentRequests, 'adjustment');
        
        // Build HTML
        let html = '<div class="requests-container">';
        
        // Pending Shifts Section
        html += `
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">Pending Shift Approvals (${pendingShifts?.length || 0})</h3>
                </div>
                <div class="card-content">
        `;
        
        if (pendingShifts && pendingShifts.length > 0) {
            pendingShifts.forEach(shift => {
                const staffName = shift.staff ? 
                    `${shift.staff.first_name} ${shift.staff.last_name}` : 'Unassigned';
                const participantName = shift.participants ? 
                    `${shift.participants.first_name} ${shift.participants.last_name}` : 
                    (shift.locations?.name || 'TBA');
                
                html += `
                    <div class="request-item">
                        <div class="request-header">
                            <strong>${formatDateFriendly(shift.date)}</strong>
                            <span class="badge badge-warning">Pending</span>
                        </div>
                        <div class="request-details">
                            <strong>Staff:</strong> ${staffName}<br>
                            <strong>Client/Location:</strong> ${participantName}<br>
                            <strong>Time:</strong> ${shift.start_time && shift.end_time ? 
                                `${formatTime12Hour(shift.start_time)} - ${formatTime12Hour(shift.end_time)}` : 
                                'Sleepover'}<br>
                            <strong>Type:</strong> ${shift.duty_types?.name || 'Not specified'}<br>
                            ${shift.notes ? `<strong>Notes:</strong> ${shift.notes}<br>` : ''}
                        </div>
                        <div class="request-actions">
                            <button class="btn btn-success btn-sm" onclick="approveShift('${shift.id}')">Approve</button>
                            <button class="btn btn-danger btn-sm" onclick="denyShift('${shift.id}')">Deny</button>
                        </div>
                    </div>
                `;
            });
        } else {
            html += '<p style="text-align: center; color: var(--text-muted); padding: 20px;">No pending shifts</p>';
        }
        
        html += '</div></div>';
        
        // Transfer Requests Section
        html += `
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">Transfer Requests (${enrichedTransferRequests.filter(r => r.status === 'pending').length})</h3>
                </div>
                <div class="card-content">
        `;
        
        const pendingTransfers = enrichedTransferRequests.filter(r => r.status === 'pending');
        if (pendingTransfers.length > 0) {
            pendingTransfers.forEach(req => {
                html += `
                    <div class="request-item">
                        <div class="request-header">
                            <strong>${req.shift ? formatDateFriendly(req.shift.date) : 'Unknown Date'}</strong>
                            <span class="badge badge-warning">Pending</span>
                        </div>
                        <div class="request-details">
                            ${req.shift ? `
                                <strong>Shift:</strong> ${formatTime12Hour(req.shift.start_time)} - ${formatTime12Hour(req.shift.end_time)}<br>
                                <strong>Client/Location:</strong> ${req.shift.participantName}<br>
                            ` : 'Shift details not found<br>'}
                            <strong>From:</strong> ${req.fromStaff ? `${req.fromStaff.first_name} ${req.fromStaff.last_name}` : 'Unknown'}<br>
                            ${req.to_staff_id ? 
                                `<strong>To:</strong> ${req.toStaff ? `${req.toStaff.first_name} ${req.toStaff.last_name}` : 'Unknown'}` : 
                                '<strong>To:</strong> <em>Open to all staff</em>'
                            }
                        </div>
                        ${req.reason ? `<div class="request-reason">${req.reason}</div>` : ''}
                        <div class="request-actions">
                            <button class="btn btn-success btn-sm" onclick="approveTransfer('${req.id}')">Approve</button>
                            <button class="btn btn-danger btn-sm" onclick="denyTransfer('${req.id}')">Deny</button>
                        </div>
                    </div>
                `;
            });
        } else {
            html += '<p style="text-align: center; color: var(--text-muted); padding: 20px;">No pending transfer requests</p>';
        }
        
        html += '</div></div>';
        
        // Adjustment Requests Section
        html += `
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">Time Adjustment Requests (${enrichedAdjustmentRequests.filter(r => r.status === 'pending').length})</h3>
                </div>
                <div class="card-content">
        `;
        
        const pendingAdjustments = enrichedAdjustmentRequests.filter(r => r.status === 'pending');
        if (pendingAdjustments.length > 0) {
            pendingAdjustments.forEach(req => {
                html += `
                    <div class="request-item">
                        <div class="request-header">
                            <strong>${req.shift ? formatDateFriendly(req.shift.date) : 'Unknown Date'}</strong>
                            <span class="badge badge-warning">Pending</span>
                        </div>
                        <div class="request-details">
                            <strong>Staff:</strong> ${req.staff ? `${req.staff.first_name} ${req.staff.last_name}` : 'Unknown'}<br>
                            ${req.shift ? `
                                <strong>Client/Location:</strong> ${req.shift.participantName}<br>
                                <strong>Current:</strong> ${formatTime12Hour(req.shift.start_time)} - ${formatTime12Hour(req.shift.end_time)}<br>
                            ` : ''}
                            <strong>Requested:</strong> ${formatTime12Hour(req.requested_start_time)} - ${formatTime12Hour(req.requested_end_time)}
                        </div>
                        ${req.reason ? `<div class="request-reason">${req.reason}</div>` : ''}
                        <div class="request-actions">
                            <button class="btn btn-success btn-sm" onclick="approveAdjustment('${req.id}')">Approve</button>
                            <button class="btn btn-danger btn-sm" onclick="denyAdjustment('${req.id}')">Deny</button>
                        </div>
                    </div>
                `;
            });
        } else {
            html += '<p style="text-align: center; color: var(--text-muted); padding: 20px;">No pending adjustment requests</p>';
        }
        
        html += '</div></div>';
        html += '</div>';
        
        requestsContent.innerHTML = html;
        
    } catch (error) {
        console.error('Error rendering requests:', error);
        requestsContent.innerHTML = '<div class="error">Failed to load requests</div>';
    }
}


async function approveShift(shiftId) {
    try {
        const { error } = await supabaseClient
            .from('shifts')
            .update({ 
                status: 'confirmed',
                updated_at: new Date().toISOString()
            })
            .eq('id', shiftId);
        
        if (error) throw error;
        
        showNotification('Shift approved successfully', 'success');
        await refreshAfterChange();
        
    } catch (error) {
        console.error('Error approving shift:', error);
        showNotification('Failed to approve shift', 'error');
    }
}

async function denyShift(shiftId) {
    try {
        const reason = prompt('Reason for denying this shift:');
        if (!reason) return;
        
        const { error } = await supabaseClient
            .from('shifts')
            .update({ 
                status: 'cancelled',
                notes: `DENIED: ${reason}`,
                updated_at: new Date().toISOString()
            })
            .eq('id', shiftId);
        
        if (error) throw error;
        
        showNotification('Shift denied', 'info');
        await refreshAfterChange();
        
    } catch (error) {
        console.error('Error denying shift:', error);
        showNotification('Failed to deny shift', 'error');
    }
}

async function isStaffAvailable(staffId, date, startTime, endTime) {
    try {
        // Check staff_availability table
        const { data: availability } = await supabaseClient
            .from('staff_availability')
            .select('is_available, start_time, end_time')
            .eq('staff_id', staffId)
            .eq('date', date)
            .single();
        
        // If no availability record, assume unavailable
        if (!availability) {
            return false;
        }
        
        // If marked as unavailable
        if (!availability.is_available) {
            return false;
        }
        
        // If times provided, check if within available hours
        if (startTime && endTime && availability.start_time && availability.end_time) {
            const shiftStart = new Date(`2000-01-01T${startTime}`);
            const shiftEnd = new Date(`2000-01-01T${endTime}`);
            const availStart = new Date(`2000-01-01T${availability.start_time}`);
            const availEnd = new Date(`2000-01-01T${availability.end_time}`);
            
            if (shiftStart < availStart || shiftEnd > availEnd) {
                return false;
            }
        }
        
        // Check for approved leave
        const { data: leaves } = await supabaseClient
            .from('leave_requests')
            .select('id')
            .eq('staff_id', staffId)
            .eq('status', 'approved')
            .lte('start_date', date)
            .gte('end_date', date);
        
        return !leaves || leaves.length === 0;
        
    } catch (error) {
        console.error('Error checking availability:', error);
        return false; // Assume unavailable on error
    }
}


function systemHealthCheck() {
    console.log('=== SYSTEM HEALTH CHECK ===');
    console.log('User:', currentUser?.email, '| Role:', currentUserRole);
    console.log('Staff Data:', currentStaffData ? `${currentStaffData.first_name} ${currentStaffData.last_name}` : 'Not linked');
    console.log('Shifts Loaded:', shifts.length);
    console.log('Staff Count:', staff.length);
    console.log('Participants:', participants.length);
    console.log('Care Homes Detected:', careHomes.size);
    console.log('Pay Rate Labels:', payRateLabels.size);
    console.log('Undo Stack:', undoStack.length, '| Redo Stack:', redoStack.length);
    
    // Check for any $0 pay issues
    const zeroPay = shifts.filter(s => s.calculated_pay === 0);
    if (zeroPay.length > 0) {
        console.warn(`Found ${zeroPay.length} shifts with $0 pay - check pay rate assignments`);
    }
    
    return {
        status: 'OK',
        issues: zeroPay.length > 0 ? ['Zero pay calculations found'] : []
    };
}

async function loadShifts() {
    try {
        console.log('=== LOADING SHIFTS ===');
        
        // Load shifts per schema - id is SERIAL
        let query = supabaseClient
            .from('shifts')
            .select('*')
            .is('deleted_at', null)
            .order('date', { ascending: false })
            .order('start_time', { ascending: true });

        const { data: basicShifts, error } = await query;
        
        if (error) {
            console.error('Shifts query error:', error);
            throw error;
        }
        
        console.log('Basic shifts loaded:', basicShifts?.length || 0);
        
        if (!basicShifts || basicShifts.length === 0) {
            console.log('No shifts found in database');
            shifts = [];
            filteredShifts = [];
            renderCurrentView();
            return;
        }
        
        // Enrich with related data and calculate hours
        shifts = await enrichShiftsData(basicShifts);
        console.log('Enriched shifts:', shifts.length);
        console.log('Sample enriched shift:', shifts[0]);
        
        // Calculate overlap information for each shift
        console.log('Calculating overlap information...');
        
        for (const shift of shifts) {
            // Only check overlaps for shifts with participants and times
            if (shift.participant_id && shift.start_time && shift.end_time) {
                // Find all other shifts for the same participant on the same date
                const sameParticipantShifts = shifts.filter(s => 
                    s.id !== shift.id &&
                    s.participant_id === shift.participant_id &&
                    s.date === shift.date &&
                    s.start_time && 
                    s.end_time
                );
                
                if (sameParticipantShifts.length > 0) {
                    const overlappingStaff = [];
                    
                    // Parse current shift times
                    const shiftStart = new Date(`2000-01-01T${shift.start_time}`);
                    let shiftEnd = new Date(`2000-01-01T${shift.end_time}`);
                    
                    // Handle overnight shifts
                    if (shiftEnd <= shiftStart) {
                        shiftEnd.setDate(shiftEnd.getDate() + 1);
                    }
                    
                    // Check each other shift for overlap
                    sameParticipantShifts.forEach(otherShift => {
                        const otherStart = new Date(`2000-01-01T${otherShift.start_time}`);
                        let otherEnd = new Date(`2000-01-01T${otherShift.end_time}`);
                        
                        // Handle overnight shifts
                        if (otherEnd <= otherStart) {
                            otherEnd.setDate(otherEnd.getDate() + 1);
                        }
                        
                        // Check for time overlap
                        const hasOverlap = !(shiftEnd <= otherStart || shiftStart >= otherEnd);
                        
                        if (hasOverlap) {
                            // Calculate the actual overlap period
                            const overlapStart = new Date(Math.max(shiftStart.getTime(), otherStart.getTime()));
                            const overlapEnd = new Date(Math.min(shiftEnd.getTime(), otherEnd.getTime()));
                            
                            overlappingStaff.push({
                                staff: otherShift.staff,
                                staff_id: otherShift.staff_id,
                                shift_id: parseInt(shiftId),
                                time: `${formatTime12Hour(otherShift.start_time)}-${formatTime12Hour(otherShift.end_time)}`,
                                overlap_period: {
                                    start: overlapStart.toTimeString().slice(0, 5),
                                    end: overlapEnd.toTimeString().slice(0, 5),
                                    duration: ((overlapEnd - overlapStart) / (1000 * 60 * 60)).toFixed(1) + 'h'
                                }
                            });
                        }
                    });
                    
                    // If overlaps were found, add the information to the shift
                    if (overlappingStaff.length > 0) {
                        shift.overlap_info = {
                            count: overlappingStaff.length + 1, // +1 for current shift
                            ratio: `${overlappingStaff.length + 1}:1`,
                            staff: overlappingStaff,
                            message: `${overlappingStaff.length + 1} staff providing care simultaneously`,
                            details: overlappingStaff.map(s => 
                                `${s.staff?.first_name} ${s.staff?.last_name} (${s.overlap_period.start}-${s.overlap_period.end})`
                            ).join(', ')
                        };
                    }
                }
            }
            
            // Check for staff conflicts (overlapping shifts for same staff)
            if (shift.staff_id && shift.start_time && shift.end_time) {
                const staffConflicts = shifts.filter(s =>
                    s.id !== shift.id &&
                    s.staff_id === shift.staff_id &&
                    s.date === shift.date &&
                    s.start_time &&
                    s.end_time
                );
                
                if (staffConflicts.length > 0) {
                    const conflicts = [];
                    
                    const shiftStart = new Date(`2000-01-01T${shift.start_time}`);
                    let shiftEnd = new Date(`2000-01-01T${shift.end_time}`);
                    
                    if (shiftEnd <= shiftStart) {
                        shiftEnd.setDate(shiftEnd.getDate() + 1);
                    }
                    
                    staffConflicts.forEach(conflict => {
                        const conflictStart = new Date(`2000-01-01T${conflict.start_time}`);
                        let conflictEnd = new Date(`2000-01-01T${conflict.end_time}`);
                        
                        if (conflictEnd <= conflictStart) {
                            conflictEnd.setDate(conflictEnd.getDate() + 1);
                        }
                        
                        const hasOverlap = !(shiftEnd <= conflictStart || shiftStart >= conflictEnd);
                        
                        if (hasOverlap) {
                            conflicts.push({
                                shift_id: conflict.id,
                                participant: conflict.participant,
                                time: `${formatTime12Hour(conflict.start_time)}-${formatTime12Hour(conflict.end_time)}`,
                                participant_name: conflict.participant ? 
                                    `${conflict.participant.first_name} ${conflict.participant.last_name}` :
                                    'Unknown'
                            });
                        }
                    });
                    
                    if (conflicts.length > 0) {
                        shift.staff_conflict = {
                            has_conflict: true,
                            count: conflicts.length,
                            conflicts: conflicts,
                            message: `⚠️ Staff double-booked with ${conflicts.length} other shift(s)`
                        };
                    }
                }
            }
            
            // Check for sleepover + late shift violations
            if (shift.duty_type?.name?.toLowerCase().includes('sleepover')) {
                const otherShiftsToday = shifts.filter(s =>
                    s.id !== shift.id &&
                    s.staff_id === shift.staff_id &&
                    s.date === shift.date &&
                    s.start_time
                );
                
                const violations = [];
                otherShiftsToday.forEach(otherShift => {
                    if (otherShift.start_time) {
                        const startHour = parseInt(otherShift.start_time.split(':')[0]);
                        const endHour = otherShift.end_time ? 
                            parseInt(otherShift.end_time.split(':')[0]) : 0;
                        
                        // Check for 10pm+ starts or 12am-6am periods
                        if (startHour >= 22 || startHour < 6 || (endHour > 0 && endHour <= 6)) {
                            violations.push({
                                shift_id: parseInt(shiftId),
                                time: `${formatTime12Hour(otherShift.start_time)}-${formatTime12Hour(otherShift.end_time || '00:00')}`,
                                reason: startHour >= 22 ? 'Late night shift (after 10pm)' : 'Early morning shift (before 6am)'
                            });
                        }
                    }
                });
                
                if (violations.length > 0) {
                    shift.sleepover_violation = {
                        has_violation: true,
                        violations: violations,
                        message: `⚠️ Sleepover conflicts with ${violations.length} shift(s)`
                    };
                }
            }
        }
        
        console.log('Overlap detection complete');
        
        // Check for any critical issues
        const shiftsWithStaffConflicts = shifts.filter(s => s.staff_conflict?.has_conflict);
        const shiftsWithSleepoverViolations = shifts.filter(s => s.sleepover_violation?.has_violation);
        
        if (shiftsWithStaffConflicts.length > 0) {
            console.warn(`Found ${shiftsWithStaffConflicts.length} shifts with staff double-booking`);
        }
        
        if (shiftsWithSleepoverViolations.length > 0) {
            console.warn(`Found ${shiftsWithSleepoverViolations.length} shifts with sleepover violations`);
        }
        
        // Apply filters after all calculations
        applyFilters();
        
        // Show warning notification if conflicts exist
        if (shiftsWithStaffConflicts.length > 0 || shiftsWithSleepoverViolations.length > 0) {
            const warningMessage = [];
            if (shiftsWithStaffConflicts.length > 0) {
                warningMessage.push(`${shiftsWithStaffConflicts.length} staff double-bookings`);
            }
            if (shiftsWithSleepoverViolations.length > 0) {
                warningMessage.push(`${shiftsWithSleepoverViolations.length} sleepover violations`);
            }
            
            showNotification(
                `⚠️ Scheduling conflicts detected: ${warningMessage.join(', ')}`,
                'warning'
            );
        }

    } catch (error) {
        console.error('Error loading shifts:', error);
        showNotification('Failed to load shifts: ' + error.message, 'error');
        
        const tbody = document.getElementById('shiftsTableBody');
        if (tbody) {
            tbody.innerHTML = `
                <tr>
                    <td colspan="9" style="text-align: center; padding: 40px; color: var(--danger-color);">
                        <strong>Error Loading Shifts</strong><br>
                        ${error.message}<br>
                        <button class="btn btn-primary btn-sm" onclick="loadShifts()" style="margin-top: 12px;">Retry</button>
                    </td>
                </tr>
            `;
        }
        
        // Also update other views if they're active
        const timesheetContent = document.getElementById('timesheetContent');
        if (timesheetContent && currentView === 'timesheet') {
            timesheetContent.innerHTML = `
                <div class="error" style="text-align: center; padding: 40px;">
                    <strong>Error Loading Shifts</strong><br>
                    ${error.message}<br>
                    <button class="btn btn-primary btn-sm" onclick="loadShifts()" style="margin-top: 12px;">Retry</button>
                </div>
            `;
        }
    }
}      

        function detectCareHomes() {
    console.log('Detecting care homes...');
    console.log('Total participants:', participants.length);
    
    // Clear previous data
    careHomes.clear();
    
    // Group participants by address (normalized)
    const addressGroups = {};
    
    participants.forEach(p => {
        // Skip if no address
        if (!p.address || p.address.trim() === '') return;
        
        // Normalize address for comparison (lowercase, trim)
        const normalizedAddress = p.address.trim().toLowerCase();
        
        // Also check if this is a care home entity itself (like "Saunders Care Home" participant)
        const isCareHomeEntity = (p.first_name && p.last_name && 
            (p.last_name.toLowerCase().includes('care') || 
             p.last_name.toLowerCase().includes('home') ||
             p.first_name.toLowerCase().includes('saunders')));
        
        // If it's a care home entity, skip adding it as a resident
        if (isCareHomeEntity) {
            console.log('Found care home entity:', p.first_name, p.last_name, p.id);
            // Store care home entity info
            if (!addressGroups[normalizedAddress]) {
                addressGroups[normalizedAddress] = {
                    residents: [],
                    careHomeEntity: p
                };
            } else {
                addressGroups[normalizedAddress].careHomeEntity = p;
            }
        } else {
            // This is a resident
            if (!addressGroups[normalizedAddress]) {
                addressGroups[normalizedAddress] = {
                    residents: [],
                    careHomeEntity: null
                };
            }
            addressGroups[normalizedAddress].residents.push(p);
            console.log('Added resident:', p.first_name, p.last_name, 'at', normalizedAddress);
        }
    });
    
    // Process each address group
    Object.entries(addressGroups).forEach(([address, data]) => {
        // Check if this looks like a care home (multiple residents OR has a care home entity OR contains "saunders")
        if (data.residents.length > 1 || data.careHomeEntity || address.includes('saunders')) {
            let careHomeName = 'Care Home';
            let mainEntityId = null;
            
            // Determine care home name and main entity
            if (data.careHomeEntity) {
                careHomeName = `${data.careHomeEntity.first_name} ${data.careHomeEntity.last_name}`;
                mainEntityId = data.careHomeEntity.id;
            } else if (address.includes('saunders')) {
                careHomeName = 'Saunders Care Home';
                // Find the Saunders Care Home participant entity if it exists
                const saundersEntity = participants.find(p => 
                    p.first_name === 'Saunders' && p.last_name === 'Care Home'
                );
                if (saundersEntity) {
                    mainEntityId = saundersEntity.id;
                }
            }
            
            careHomes.set(address, {
                name: careHomeName,
                address: address,
                residents: data.residents,
                mainEntityId: mainEntityId
            });
            
            console.log(`Care home detected: ${careHomeName} at ${address} with ${data.residents.length} residents`);
        }
    });
    
    // Also check for Saunders Care Home entity specifically
    const saundersEntity = participants.find(p => 
        (p.first_name === 'Saunders' && p.last_name === 'Care Home') ||
        (p.first_name === 'Saunders' && p.last_name === 'Carehome')
    );
    
    if (saundersEntity) {
        console.log('Found Saunders Care Home entity:', saundersEntity);
        
        // Find all participants with Saunders address
        const saundersAddress = '1 saunders avenue, liverpool';
        const saundersResidents = participants.filter(p => 
            p.address && 
            p.address.toLowerCase().includes('saunders') &&
            p.id !== saundersEntity.id // Don't include the care home entity itself
        );
        
        // Update or create Saunders care home entry
        careHomes.set(saundersAddress, {
            name: 'Saunders Care Home',
            address: saundersAddress,
            residents: saundersResidents,
            mainEntityId: saundersEntity.id
        });
        
        console.log(`Saunders Care Home: ${saundersResidents.length} residents found`);
        console.log('Residents:', saundersResidents.map(r => `${r.first_name} ${r.last_name}`));
    }
    
    console.log(`Total care homes detected: ${careHomes.size}`);
    console.log('Care homes:', Array.from(careHomes.entries()));
}
// Helper function to detect care home name
function detectCareHomeName(address, residents) {
    // Check if address contains common care home keywords
    if (address.includes('saunders')) return 'Saunders Care Home';
    if (address.includes('care') || address.includes('home')) {
        // Extract the name from address
        return address.split(',')[0].replace(/\d+/g, '').trim();
    }
    // Default: use the address
    return `Care Home at ${address.split(',')[0]}`;
}

// Helper to find if there's a care home entity (not a person)
function findCareHomeEntity(residents, address) {
    const careHomeEntity = participants.find(p => 
        (p.first_name?.includes('Care') || p.last_name?.includes('Care') ||
         p.first_name?.includes('Home') || p.last_name?.includes('Home')) &&
        p.address?.toLowerCase() === address
    );
    return careHomeEntity?.id || null;
}

        async function enrichShiftsData(basicShifts) {
            if (!basicShifts || basicShifts.length === 0) return [];
            
            try {
                console.log('Enriching shifts with related data...');
                
                // Get unique IDs for batch loading
                const staffIds = [...new Set(basicShifts.map(s => s.staff_id).filter(Boolean))];
                const participantIds = [...new Set(basicShifts.map(s => s.participant_id).filter(Boolean))];
                const locationIds = [...new Set(basicShifts.map(s => s.location_id).filter(Boolean))];
                const dutyTypeIds = [...new Set(basicShifts.map(s => s.duty_type_id).filter(Boolean))];
                const payRateIds = [...new Set(basicShifts.map(s => s.pay_override_id).filter(Boolean))];

                console.log('Loading related data for IDs:', {
                    staffIds: staffIds.length,
                    participantIds: participantIds.length,
                    locationIds: locationIds.length,
                    dutyTypeIds: dutyTypeIds.length,
                    payRateIds: payRateIds.length
                });

                // Load related data in parallel
                const [
                    { data: staffData },
                    { data: participantData },
                    { data: locationData },
                    { data: dutyTypeData },
                    { data: payRateData }
                ] = await Promise.all([
                    staffIds.length ? supabaseClient.from('staff').select('*').in('id', staffIds) : { data: [] },
                    participantIds.length ? supabaseClient.from('participants').select('*').in('id', participantIds) : { data: [] },
                    locationIds.length ? supabaseClient.from('locations').select('*').in('id', locationIds) : { data: [] },
                    dutyTypeIds.length ? supabaseClient.from('duty_types').select('*').in('id', dutyTypeIds) : { data: [] },
                    payRateIds.length ? supabaseClient.from('pay_rates').select('*').in('id', payRateIds) : { data: [] }
                ]);

                console.log('Related data loaded:', {
                    staff: staffData?.length || 0,
                    participants: participantData?.length || 0,
                    locations: locationData?.length || 0,
                    dutyTypes: dutyTypeData?.length || 0,
                    payRates: payRateData?.length || 0
                });

                // Create lookup maps
                const staffMap = new Map((staffData || []).map(s => [s.id, s]));
                const participantMap = new Map((participantData || []).map(p => [p.id, p]));
                const locationMap = new Map((locationData || []).map(l => [l.id, l]));
                const dutyTypeMap = new Map((dutyTypeData || []).map(d => [d.id, d]));
                const payRateMap = new Map((payRateData || []).map(r => [r.id, r]));

                // Enrich shifts and calculate hours/pay
                const enrichedShifts = basicShifts.map(shift => {
                    const enrichedShift = {
                        ...shift,
                        staff: staffMap.get(shift.staff_id) || null,
                        participant: participantMap.get(shift.participant_id) || null,
                        location: locationMap.get(shift.location_id) || null,
                        duty_type: dutyTypeMap.get(shift.duty_type_id) || null,
                        pay_override: payRateMap.get(shift.pay_override_id) || null
                    };

                    // Calculate hours and pay - FIXED LOGIC
                    enrichedShift.calculated_hours = calculateShiftHours(enrichedShift);
                    enrichedShift.calculated_pay = calculateShiftPay(enrichedShift, enrichedShift.calculated_hours);

                    console.log(`Shift ${shift.id} calculations:`, {
                        date: shift.date,
                        start: shift.start_time,
                        end: shift.end_time,
                        hours: enrichedShift.calculated_hours,
                        pay: enrichedShift.calculated_pay
                    });

                    return enrichedShift;
                });

                return enrichedShifts;
                
            } catch (error) {
                console.error('Error enriching shifts:', error);
                return basicShifts;
            }
        }

        // Format hours with 1 decimal place
function formatHours(hours) {
    if (hours === undefined || hours === null) return '0.0';
    return parseFloat(hours).toFixed(1);
}

// Format date to "Mon 5 Aug 2025"
function formatDateFriendly(dateString) {
    if (!dateString) return '';
    const date = new Date(dateString + 'T12:00:00'); // Use noon to avoid timezone issues
    const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    
    return `${days[date.getDay()]} ${date.getDate()} ${months[date.getMonth()]} ${date.getFullYear()}`;
}

function formatTime(time) {
    if (!time) return '';
    
    // Handle if time is already in HH:MM format
    if (typeof time === 'string' && time.includes(':')) {
        const [hours, minutes] = time.split(':');
        const hour = parseInt(hours);
        const ampm = hour >= 12 ? 'PM' : 'AM';
        const displayHour = hour % 12 || 12;
        return `${displayHour}:${minutes} ${ampm}`;
    }
    
    // Handle Date objects
    if (time instanceof Date) {
        const hours = time.getHours();
        const minutes = time.getMinutes();
        const ampm = hours >= 12 ? 'PM' : 'AM';
        const displayHour = hours % 12 || 12;
        return `${displayHour}:${minutes.toString().padStart(2, '0')} ${ampm}`;
    }
    
    return time;
}


function formatTime12Hour(timeStr) {
    if (!timeStr) return '';
    const [hours, minutes] = timeStr.split(':');
    const hour = parseInt(hours);
    const ampm = hour >= 12 ? 'PM' : 'AM';
    const displayHour = hour % 12 || 12;
    return `${displayHour}:${minutes} ${ampm}`;
}

function formatDateShort(dateStr) {
    if (!dateStr) return '';
    const date = new Date(dateStr);
    return date.toLocaleDateString('en-AU', { month: 'short', day: 'numeric' });
}

// Undo/Redo Manager
const UndoRedoManager = {
    // Save state before any modification
    saveState: function(action, data) {
        undoStack.push({
            action: action,
            data: JSON.parse(JSON.stringify(data)), // Deep clone
            timestamp: new Date().toISOString()
        });
        
        // Limit stack size
        if (undoStack.length > MAX_UNDO_STACK) {
            undoStack.shift();
        }
        
        // Clear redo stack when new action is performed
        redoStack = [];
        
        // Update UI buttons
        this.updateButtons();
    },
    
    undo: async function() {
        if (undoStack.length === 0) {
            showNotification('Nothing to undo', 'info');
            return;
        }
        
        const state = undoStack.pop();
        
        try {
            switch(state.action) {
                case 'create_shift':
                    // Undo creation by soft deleting
                    await supabaseClient
                        .from('shifts')
                        .update({ deleted_at: new Date().toISOString() })
                        .eq('id', state.data.id);
                    
                    redoStack.push(state);
                    showNotification('Shift creation undone', 'success');
                    break;
                    
                case 'update_shift':
                    // Restore previous values
                    await supabaseClient
                        .from('shifts')
                        .update(state.data.previous)
                        .eq('id', state.data.id);
                    
                    redoStack.push({
                        action: 'update_shift',
                        data: {
                            id: state.data.id,
                            previous: state.data.current,
                            current: state.data.previous
                        }
                    });
                    showNotification('Shift update undone', 'success');
                    break;
                    
                case 'delete_shift':
                    // Undo deletion by removing deleted_at
                    await supabaseClient
                        .from('shifts')
                        .update({ deleted_at: null })
                        .eq('id', state.data.id);
                    
                    redoStack.push(state);
                    showNotification('Shift deletion undone', 'success');
                    break;
            }
            
            await loadShifts();
            this.updateButtons();
            
        } catch (error) {
            console.error('Undo failed:', error);
            showNotification('Undo failed: ' + error.message, 'error');
            undoStack.push(state); // Restore to stack if failed
        }
    },
    
    redo: async function() {
        if (redoStack.length === 0) {
            showNotification('Nothing to redo', 'info');
            return;
        }
        
        const state = redoStack.pop();
        
        try {
            switch(state.action) {
                case 'create_shift':
                    // Redo creation by removing deleted_at
                    await supabaseClient
                        .from('shifts')
                        .update({ deleted_at: null })
                        .eq('id', state.data.id);
                    break;
                    
                case 'update_shift':
                    // Apply the update again
                    await supabaseClient
                        .from('shifts')
                        .update(state.data.current)
                        .eq('id', state.data.id);
                    break;
                    
                case 'delete_shift':
                    // Redo deletion
                    await supabaseClient
                        .from('shifts')
                        .update({ deleted_at: new Date().toISOString() })
                        .eq('id', state.data.id);
                    break;
            }
            
            undoStack.push(state);
            await loadShifts();
            this.updateButtons();
            showNotification('Action redone', 'success');
            
        } catch (error) {
            console.error('Redo failed:', error);
            showNotification('Redo failed: ' + error.message, 'error');
            redoStack.push(state); // Restore to stack if failed
        }
    },
    
    updateButtons: function() {
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        
        if (undoBtn) {
            undoBtn.disabled = undoStack.length === 0;
            undoBtn.title = undoStack.length > 0 ? 
                `Undo: ${undoStack[undoStack.length - 1].action.replace('_', ' ')}` : 
                'Nothing to undo (Ctrl+Z)';
        }
        
        if (redoBtn) {
            redoBtn.disabled = redoStack.length === 0;
            redoBtn.title = redoStack.length > 0 ? 
                `Redo: ${redoStack[redoStack.length - 1].action.replace('_', ' ')}` : 
                'Nothing to redo (Ctrl+Y)';
        }
    }
};

// Add keyboard shortcuts for undo/redo
document.addEventListener('keydown', function(e) {
    // Check if user is typing in an input field
    const activeElement = document.activeElement;
    const isInputField = activeElement && (
        activeElement.tagName === 'INPUT' || 
        activeElement.tagName === 'TEXTAREA' || 
        activeElement.tagName === 'SELECT'
    );
    
    // Don't trigger undo/redo if user is typing
    if (isInputField) return;
    
    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        UndoRedoManager.undo();
    } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        e.preventDefault();
        UndoRedoManager.redo();
    }
});

document.addEventListener('keydown', function(e) {
    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        UndoRedoManager.undo();
    } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        e.preventDefault();
        UndoRedoManager.redo();
    }
});

function calculateShiftHours(shift) {
    const result = {
        total: 0,
        weekdayDay: 0,
        weekdayEvening: 0,
        weekdayNight: 0,
        saturday: 0,
        sunday: 0,
        publicHoliday: 0,
        sleepover: 0
    };

    const dutyType = shift.duty_type;
    const isSleepover = dutyType && dutyType.name && 
        dutyType.name.toLowerCase().includes('sleepover');

    // If it has times AND is a sleepover, calculate both
    if (isSleepover && shift.start_time && shift.end_time) {
        // This is BOTH active hours AND a sleepover
        
        // First calculate active hours
        const startTime = new Date(`${shift.date}T${shift.start_time}`);
        let endTime = new Date(`${shift.date}T${shift.end_time}`);
        
        if (endTime <= startTime) {
            endTime.setDate(endTime.getDate() + 1);
        }
        
        const activeHours = (endTime - startTime) / (1000 * 60 * 60);
        
        // Apply penalty logic for active hours
        const shiftDate = new Date(shift.date);
        const dayOfWeek = shiftDate.getDay();
        const isPublicHoliday = publicHolidays.has(shift.date);
        
        if (isPublicHoliday) {
            result.publicHoliday = activeHours;
        } else if (dayOfWeek === 6) {
            result.saturday = activeHours;
        } else if (dayOfWeek === 0) {
            result.sunday = activeHours;
        } else {
            const weekdayBreakdown = splitWeekdayHours(startTime, endTime);
            Object.assign(result, weekdayBreakdown);
        }
        
        // ADD the sleepover hours on top
        result.sleepover = 2; // Always 2 hours for sleepover
        result.total = activeHours + 2; // Total is active + sleepover
        
        console.log(`Combined shift: ${activeHours}h active + 2h sleepover = ${result.total}h total`);
        
    } else if (isSleepover) {
        // Just a sleepover, no active hours
        result.sleepover = 2;
        result.total = 2;
        
    } else if (shift.start_time && shift.end_time) {
        // Just active hours, no sleepover
        const startTime = new Date(`${shift.date}T${shift.start_time}`);
        let endTime = new Date(`${shift.date}T${shift.end_time}`);
        
        if (endTime <= startTime) {
            endTime.setDate(endTime.getDate() + 1);
        }
        
        const totalHours = (endTime - startTime) / (1000 * 60 * 60);
        result.total = totalHours;
        
        // Apply penalty logic
        const shiftDate = new Date(shift.date);
        const dayOfWeek = shiftDate.getDay();
        const isPublicHoliday = publicHolidays.has(shift.date);
        
        if (isPublicHoliday) {
            result.publicHoliday = totalHours;
        } else if (dayOfWeek === 6) {
            result.saturday = totalHours;
        } else if (dayOfWeek === 0) {
            result.sunday = totalHours;
        } else {
            const weekdayBreakdown = splitWeekdayHours(startTime, endTime);
            Object.assign(result, weekdayBreakdown);
        }
    }
    
    return result;
}

        function splitWeekdayHours(startTime, endTime) {
            const result = {
                total: 0,
                weekdayDay: 0,      // 6am-8pm
                weekdayEvening: 0,  // 8pm-12am  
                weekdayNight: 0     // 12am-6am
            };

            const current = new Date(startTime);
            
            while (current < endTime) {
                // Calculate end of current period
                const nextPeriod = new Date(current);
                nextPeriod.setMinutes(current.getMinutes() + 30); // Calculate in 30-min increments for accuracy
                
                const periodEnd = nextPeriod > endTime ? endTime : nextPeriod;
                const periodHours = (periodEnd - current) / (1000 * 60 * 60);
                
                const hour = current.getHours();
                
                // Time period classification
                if (hour >= 6 && hour < 20) {
                    result.weekdayDay += periodHours;
                } else if (hour >= 20 && hour < 24) {
                    result.weekdayEvening += periodHours;
                } else {
                    result.weekdayNight += periodHours;
                }
                
                current.setTime(periodEnd.getTime());
            }

            result.total = result.weekdayDay + result.weekdayEvening + result.weekdayNight;
            return result;
        }

        // Update the calculateShiftPay function (around line 1050)
function calculateShiftPay(shift, hoursBreakdown) {
    // Get effective pay rate - FIXED LOGIC
    let payRate = null;
    
    // Check if there's a pay override
    if (shift.pay_override_id && shift.pay_override_id !== '00000000-0000-0000-0000-000000000002') {
        // Use the override rate
        payRate = shift.pay_override || payRates.find(pr => pr.id === shift.pay_override_id);
    } 
    
    // If no override OR if it's the standard rate placeholder, use staff's assigned rate
    if (!payRate || shift.pay_override_id === '00000000-0000-0000-0000-000000000002') {
        if (shift.staff && shift.staff.pay_rate_id) {
            payRate = payRates.find(pr => pr.id === shift.staff.pay_rate_id);
            console.log(`Using staff ${shift.staff.first_name}'s assigned rate:`, payRate);
        }
    }
    
    // Final fallback
    if (!payRate) {
        console.warn(`No pay rate found for shift ${shift.id}, using zero rates`);
        payRate = {
            hourly_pay_rate: 0,
            afternoon: 0,
            night: 0,
            saturday: 0,
            sunday: 0,
            public_holiday: 0,
            sleepover: 0
        };
    }
    
    const baseRate = parseFloat(payRate.hourly_pay_rate) || 0;
    
    const totalPay = 
        (hoursBreakdown.weekdayDay * baseRate) +
        (hoursBreakdown.weekdayEvening * (parseFloat(payRate.afternoon) || baseRate)) +
        (hoursBreakdown.weekdayNight * (parseFloat(payRate.night) || baseRate)) +
        (hoursBreakdown.saturday * (parseFloat(payRate.saturday) || baseRate)) +
        (hoursBreakdown.sunday * (parseFloat(payRate.sunday) || baseRate)) +
        (hoursBreakdown.publicHoliday * (parseFloat(payRate.public_holiday) || baseRate)) +
        (hoursBreakdown.sleepover * (parseFloat(payRate.sleepover) / 2|| baseRate));

    console.log(`Pay calculation for shift ${shift.id}:`, {
        staffName: shift.staff?.first_name,
        payRateId: payRate.id,
        baseRate: baseRate,
        breakdown: hoursBreakdown,
        totalPay: totalPay
    });

    return totalPay;
}

        // ========================================
        // WEEK NAVIGATION
        // ========================================
        
        function setCurrentWeek() {
    const today = new Date();
    currentWeekStart = getWeekStart(today);
    updateWeekDisplay();
}

function previousWeek() {
    const prevWeek = new Date(currentWeekStart);
    prevWeek.setDate(prevWeek.getDate() - 7);
    currentWeekStart = prevWeek;
    updateWeekDisplay();
    loadShifts();
}

function nextWeek() {
    const next = new Date(currentWeekStart);
    next.setDate(next.getDate() + 7);
    currentWeekStart = next;
    updateWeekDisplay();
    loadShifts();
}

        function goToCurrentWeek() {
            setCurrentWeek();
            applyFilters();
        }

        function updateWeekDisplay() {
            const weekEnd = new Date(currentWeekStart);
            weekEnd.setDate(weekEnd.getDate() + 6);
            
            const startStr = currentWeekStart.toLocaleDateString('en-AU', { 
                month: 'short', day: 'numeric' 
            });
            const endStr = weekEnd.toLocaleDateString('en-AU', { 
                month: 'short', day: 'numeric', year: 'numeric' 
            });
            
            document.getElementById('weekDisplay').textContent = `Week of ${startStr} - ${endStr}`;
        }

        function setWeekDateRange() {
            const weekEnd = new Date(currentWeekStart);
            weekEnd.setDate(weekEnd.getDate() + 6);
            
            document.getElementById('startDate').value = currentWeekStart.toISOString().split('T')[0];
            document.getElementById('endDate').value = weekEnd.toISOString().split('T')[0];
        }

        function getWeekStart(date) {
    const start = new Date(date);
    const day = start.getDay();
    // Adjust to Monday as start of week
    // If Sunday (0), go back 6 days; otherwise go back (day-1) days
    const diff = day === 0 ? -6 : 1 - day;
    start.setDate(start.getDate() + diff);
    start.setHours(0, 0, 0, 0);
    return start;
}
        // ========================================
        // FILTERING AND VIEW SWITCHING
        // ========================================

        function applyFilters() {
            console.log('=== APPLYING FILTERS ===');
            
            const startDate = document.getElementById('startDate')?.value;
            const endDate = document.getElementById('endDate')?.value;
            const statusFilter = document.getElementById('statusFilter')?.value;

            console.log('Filter values:', { startDate, endDate, staffFilterValue, participantFilterValue, statusFilter });

            filteredShifts = shifts.filter(shift => {
                if (startDate && shift.date < startDate) return false;
                if (endDate && shift.date > endDate) return false;
                if (staffFilterValue && shift.staff_id !== staffFilterValue) return false;
                if (participantFilterValue && shift.participant_id !== participantFilterValue) return false;
                if (statusFilter && shift.status !== statusFilter) return false;
                return true;
            });

            console.log('Filtered result:', filteredShifts.length, 'shifts');
            renderCurrentView();
        }

        // Add this to your switch view function
        function switchView(view) {
    currentView = view;
    
    // Update buttons
    document.querySelectorAll('.view-toggle button').forEach(btn => {
        btn.classList.remove('active');
    });
    
    // Handle different button ID patterns
    const activeBtn = document.getElementById(`${view}ViewBtn`) || 
                     document.querySelector(`[data-view="${view}"]`);
    if (activeBtn) {
        activeBtn.classList.add('active');
    }

    // Hide ALL view contents
    document.querySelectorAll('.view-content').forEach(content => {
        content.classList.remove('active');
        content.style.display = 'none';
    });
    
    // Show the selected view
    const activeView = document.getElementById(`${view}View`) || 
                      document.getElementById(`${view}sView`);  // Handle 'templates' -> 'templatesView'
    
    if (activeView) {
        activeView.classList.add('active');
        activeView.style.display = 'block';
    }

    // Render the appropriate view
    switch(view) {
        case 'table':
            renderTable();
            break;
        case 'requests':
            renderRequests();
            break;
        case 'summary':
            renderSummary();
            break;
        case 'timesheet':
            renderTimesheet();
            break;
        case 'conflicts':
            renderConflicts();
            break;
        case 'notes':
            renderNotes();
            break;
        case 'availability':
            renderAvailability();
            break;
        case 'templates':
            // Load templates view
            if (typeof loadTemplates === 'function') {
                loadTemplates();
            }
            break;
        case 'staff':
            if (typeof renderStaffView === 'function') {
                renderStaffView();
            }
            break;
    }
}

async function updateShift() {
    try {
        const shiftId = parseInt(document.getElementById('editShiftId').value);
        const date = document.getElementById('editShiftDate').value;
        const startTime = document.getElementById('editShiftStartTime').value;
        const endTime = document.getElementById('editShiftEndTime').value;
        const staffId = document.getElementById('editShiftStaff').value;
        const participantId = document.getElementById('editShiftParticipant').value || null;
        const locationId = document.getElementById('editShiftLocation').value || null;
        const dutyTypeId = document.getElementById('editShiftDutyType').value;
        const payRateId = document.getElementById('editShiftPayRate').value;
        const status = document.getElementById('editShiftStatus').value;
        const notes = document.getElementById('editShiftNotes').value;

        if (!date || !staffId || !dutyTypeId) {
            showNotification('Please fill required fields', 'error');
            return;
        }

        const updateData = {
            date,
            start_time: startTime || null,
            end_time: endTime || null,
            staff_id: staffId,
            participant_id: participantId,
            location_id: locationId,
            duty_type_id: dutyTypeId,
            status: status,
            notes: notes || null,
            updated_at: new Date().toISOString()
        };

        // Handle pay override - explicitly set it based on the selection
        if (payRateId && payRateId !== '') {
            // User selected a specific pay rate override
            updateData.pay_override_id = payRateId;
        } else {
            // User selected "Use Staff Default" - get staff's default rate
            const selectedStaff = staff.find(s => s.id === staffId);
            updateData.pay_override_id = selectedStaff?.pay_rate_id || '00000000-0000-0000-0000-000000000002';
        }

        // Calculate new duration
        const selectedDutyType = dutyTypes.find(d => d.id === dutyTypeId);
        if (selectedDutyType?.name.toLowerCase().includes('sleepover')) {
            updateData.duration_hours = 2;
        } else if (startTime && endTime) {
            const start = new Date(`2000-01-01T${startTime}`);
            let end = new Date(`2000-01-01T${endTime}`);
            if (end <= start) end.setDate(end.getDate() + 1);
            updateData.duration_hours = (end - start) / (1000 * 60 * 60);
        }

        console.log('Updating shift with data:', updateData);

        const { error } = await supabaseClient
            .from('shifts')
            .update(updateData)
            .eq('id', shiftId);

        if (error) throw error;

        showNotification('Shift updated successfully', 'success');
        closeModal('editShiftModal');
        await loadShifts();

    } catch (error) {
        console.error('Error updating shift:', error);
        showNotification('Failed to update shift: ' + error.message, 'error');
    }
}

async function approveLeave(requestId) {
    try {
        // Get leave request details
        const { data: leave, error: fetchError } = await supabaseClient
            .from('leave_requests')
            .select('*')
            .eq('id', requestId)
            .single();
            
        if (fetchError || !leave) {
            throw new Error('Leave request not found');
        }
        
        // Update leave request status
        const { error: updateError } = await supabaseClient
            .from('leave_requests')
            .update({
                status: 'approved',
                updated_at: new Date().toISOString()
            })
            .eq('id', requestId);
            
        if (updateError) throw updateError;
        
        // Create staff_availability records for the leave period
        const startDate = new Date(leave.start_date);
        const endDate = new Date(leave.end_date);
        const availabilityRecords = [];
        
        for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
            availabilityRecords.push({
                staff_id: leave.staff_id,
                date: d.toISOString().split('T')[0],
                is_available: false,
                start_time: null,
                end_time: null,
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString()
            });
        }
        
        // Upsert availability records
        if (availabilityRecords.length > 0) {
            const { error: availError } = await supabaseClient
                .from('staff_availability')
                .upsert(availabilityRecords, {
                    onConflict: 'staff_id,date',
                    ignoreDuplicates: false
                });
                
            if (availError) {
                console.error('Error creating availability records:', availError);
                // Don't fail the whole operation
            }
        }
        
        showNotification('Leave approved successfully', 'success');
        
        // Refresh views if functions exist
        if (typeof renderRequests === 'function') {
            await renderRequests();
        }
        if (typeof renderAvailability === 'function') {
            await renderAvailability();
        }
        
    } catch (error) {
        console.error('Error approving leave:', error);
        showNotification('Failed to approve leave: ' + error.message, 'error');
    }
}

function formatDateFriendly(dateStr) {
    if (!dateStr) return 'Unknown';
    const date = new Date(dateStr);
    const options = { weekday: 'short', month: 'short', day: 'numeric' };
    return date.toLocaleDateString('en-AU', options);
}



async function denyLeave(requestId) {
    try {
        const { error } = await supabaseClient
            .from('leave_requests')
            .update({
                status: 'rejected',
                updated_at: new Date().toISOString()
            })
            .eq('id', requestId);
            
        if (error) throw error;
        
        showNotification('Leave request denied', 'info');
        
        if (typeof renderRequests === 'function') {
            await renderRequests();
        }
        
    } catch (error) {
        console.error('Error denying leave:', error);
        showNotification('Failed to deny leave: ' + error.message, 'error');
    }
}


async function approveTransfer(requestId) {
    try {
        // Get the transfer request details
        const { data: request, error: fetchError } = await supabaseClient
            .from('transfer_requests')
            .select('*')
            .eq('id', requestId)
            .single();
        
        if (fetchError || !request) {
            throw new Error('Transfer request not found');
        }
        
        // Update the shift with new staff member if specified
        if (request.to_staff_id) {
            const { error: shiftError } = await supabaseClient
                .from('shifts')
                .update({
                    staff_id: request.to_staff_id,
                    updated_at: new Date().toISOString()
                })
                .eq('id', request.shift_id);
                
            if (shiftError) throw shiftError;
        } else {
            // If no target staff specified, unassign the shift
            const { error: shiftError } = await supabaseClient
                .from('shifts')
                .update({
                    staff_id: null,
                    updated_at: new Date().toISOString()
                })
                .eq('id', request.shift_id);
                
            if (shiftError) throw shiftError;
        }
        
        // Update request status
        const { error: requestError } = await supabaseClient
            .from('transfer_requests')
            .update({ 
                status: 'approved',
                updated_at: new Date().toISOString()
            })
            .eq('id', requestId);
            
        if (requestError) throw requestError;
        
        showNotification('Transfer approved successfully', 'success');
        
        // Refresh the view
        await renderRequests();
        
        // Refresh shifts if loaded
        if (typeof loadShifts === 'function') {
            await loadShifts();
        }
        
    } catch (error) {
        console.error('Error approving transfer:', error);
        showNotification('Failed to approve transfer: ' + error.message, 'error');
    }
}


async function denyTransfer(requestId) {
    try {
        const { error } = await supabaseClient
            .from('transfer_requests')
            .update({ 
                status: 'rejected',
                updated_at: new Date().toISOString()
            })
            .eq('id', requestId);
        
        if (error) throw error;
        
        showNotification('Transfer denied', 'info');
        await renderRequests();
        
    } catch (error) {
        console.error('Error denying transfer:', error);
        showNotification('Failed to deny transfer: ' + error.message, 'error');
    }
}
async function approveAdjustment(requestId) {
    try {
        // Get the adjustment request details
        const { data: request, error: fetchError } = await supabaseClient
            .from('shift_adjustment_requests')
            .select('*')
            .eq('id', requestId)
            .single();
        
        if (fetchError || !request) {
            throw new Error('Adjustment request not found');
        }
        
        // Update the shift with new times
        const updateData = {};
        if (request.requested_start_time) {
            updateData.start_time = request.requested_start_time;
        }
        if (request.requested_end_time) {
            updateData.end_time = request.requested_end_time;
        }
        updateData.updated_at = new Date().toISOString();
        
        const { error: shiftError } = await supabaseClient
            .from('shifts')
            .update(updateData)
            .eq('id', request.shift_id);
            
        if (shiftError) throw shiftError;

        // Update request status
        const { error: requestError } = await supabaseClient
            .from('shift_adjustment_requests')
            .update({ 
                status: 'approved',
                updated_at: new Date().toISOString()
            })
            .eq('id', requestId);
            
        if (requestError) throw requestError;
        
        showNotification('Adjustment approved successfully', 'success');
        
        // Refresh views
        await renderRequests();
        
        // Refresh shifts if loaded
        if (typeof loadShifts === 'function') {
            await loadShifts();
        }
        
    } catch (error) {
        console.error('Error approving adjustment:', error);
        showNotification('Failed to approve adjustment: ' + error.message, 'error');
    }
}

async function denyAdjustment(requestId) {
    try {
        const { error } = await supabaseClient
            .from('shift_adjustment_requests')
            .update({ 
                status: 'rejected',
                updated_at: new Date().toISOString()
            })
            .eq('id', requestId);
        
        if (error) throw error;
        
        showNotification('Adjustment denied', 'info');
        await renderRequests();
        
    } catch (error) {
        console.error('Error denying adjustment:', error);
        showNotification('Failed to deny adjustment: ' + error.message, 'error');
    }
}


        function renderCurrentView() {
            console.log(`Rendering ${currentView} view with ${filteredShifts.length} shifts`);
            
            switch (currentView) {
                case 'table':
                    renderTable();
                    break;
                case 'summary':
                    renderSummary();
                    break;
                case 'timesheet':
                    renderTimesheet();
                    break;
                case 'notes':
                    renderNotes();
                    break;
            }
        }


        async function renderAvailability() {
    const availabilityContent = document.getElementById('availabilityContent');
    if (!availabilityContent) {
        const availabilityView = document.getElementById('availabilityView');
        if (availabilityView) {
            availabilityView.innerHTML = `
                <div class="table-container">
                    <header class="table-header">
                        <h2 class="table-title">Staff Availability Management</h2>
                        <div class="table-actions">
                            <button class="btn btn-primary btn-sm" onclick="showAvailabilityModal()">Set Availability</button>
                            <button class="btn btn-outline btn-sm" onclick="renderAvailability()">Refresh</button>
                        </div>
                    </header>
                    <div class="card-content" id="availabilityContent">
                        <div class="loading">
                            <div class="spinner"></div>
                            <span>Loading availability...</span>
                        </div>
                    </div>
                </div>
            `;
        }
        return;
    }
    
    try {
        // Load staff availability for the current week
        const weekStart = getWeekStart(new Date());
        const weekEnd = new Date(weekStart);
        weekEnd.setDate(weekEnd.getDate() + 6);
        
        const { data: availability } = await supabaseClient
            .from('staff_availability')
            .select(`
                *,
                staff:staff_id(first_name, last_name)
            `)
            .gte('date', weekStart.toISOString().split('T')[0])
            .lte('date', weekEnd.toISOString().split('T')[0])
            .order('date');
        
        let html = `
            <style>
                .availability-grid {
                    display: grid;
                    grid-template-columns: 150px repeat(7, 1fr);
                    gap: 1px;
                    background: #e9ecef;
                    border-radius: 8px;
                    overflow: hidden;
                    margin-bottom: 24px;
                }
                
                .availability-cell {
                    background: white;
                    padding: 12px;
                    min-height: 50px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 14px;
                }
                
                .availability-header {
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    font-weight: 600;
                    font-size: 12px;
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                }
                
                .availability-name {
                    background: #f8f9fa;
                    font-weight: 500;
                    justify-content: flex-start;
                    padding-left: 16px;
                }
                
                .available {
                    background: #d4edda;
                    color: #155724;
                }
                
                .unavailable {
                    background: #f8d7da;
                    color: #721c24;
                }
                
                .partial {
                    background: #fff3cd;
                    color: #856404;
                }
            </style>
            
            <div class="availability-grid">
                <div class="availability-cell availability-header">Staff</div>
        `;
        
        // Add day headers
        const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
        days.forEach((day, index) => {
            const date = new Date(weekStart);
            date.setDate(date.getDate() + index);
            html += `
                <div class="availability-cell availability-header">
                    ${day}<br>${date.getDate()}
                </div>
            `;
        });
        
        // Group availability by staff
        const staffAvailability = {};
        availability?.forEach(av => {
            const staffId = av.staff_id;
            if (!staffAvailability[staffId]) {
                staffAvailability[staffId] = {
                    staff: av.staff,
                    days: {}
                };
            }
            const dayIndex = new Date(av.date).getDay();
            staffAvailability[staffId].days[dayIndex] = av.available;
        });
        
        // Render each staff member's availability
        Object.values(staffAvailability).forEach(sa => {
            html += `<div class="availability-cell availability-name">${sa.staff.first_name} ${sa.staff.last_name}</div>`;
            
            for (let i = 0; i < 7; i++) {
                const dayIndex = i === 6 ? 0 : i + 1; // Adjust for Monday start
                const isAvailable = sa.days[dayIndex];
                const className = isAvailable === true ? 'available' : 
                                 isAvailable === false ? 'unavailable' : '';
                const text = isAvailable === true ? '✓' : 
                           isAvailable === false ? '✗' : '-';
                
                html += `<div class="availability-cell ${className}">${text}</div>`;
            }
        });
        
        html += '</div>';
        
        availabilityContent.innerHTML = html;
        
    } catch (error) {
        console.error('Error loading availability:', error);
        availabilityContent.innerHTML = '<div class="error">Failed to load availability</div>';
    }
}
function renderShiftRow(shift, date) {  // <-- Remove async, back to regular function
    const staff = shift.staff || {};
    const participant = shift.participant || {};
    const location = shift.location || {};
    const dutyType = shift.duty_type || {};
    
    // REMOVE THE PROBLEMATIC QUERY - just set leave indicator to empty
    let leaveIndicator = '';
    // Removed the try-catch block with the staff_availability query that was causing 406
    
    // Get participant color
    const participantColor = getParticipantColor(shift.participant_id);
    
    // Check if this is a care home resident
    const isCareHomeResident = participant.address && 
        Array.from(careHomes.keys()).some(address => 
            participant.address.toLowerCase().includes(address)
        );
    
    // Client display with colored badge
    const clientDisplay = participant.first_name ? 
        `<span class="participant-badge" style="background: ${participantColor};">
            ${participant.first_name} ${participant.last_name}
            ${isCareHomeResident ? ' 🏠' : ''}
        </span>` : 
        (location.name ? `<span class="location-badge">${location.name}</span>` : 'TBA');
    
    // Time display
    const timeDisplay = shift.start_time && shift.end_time ? 
        `${formatTime12Hour(shift.start_time)} - ${formatTime12Hour(shift.end_time)}` : 
        (shift.duty_type?.name?.toLowerCase().includes('sleepover') ? 'Sleepover' : '-');
    
    // Hours and pay with proper styling
    const hours = shift.calculated_hours?.total || 0;
    const pay = shift.calculated_pay || 0;
    
    // Determine if shift can be edited (based on role and status)
    const canEdit = currentUserRole !== 'staff' && shift.status !== 'completed';
    
    // Status badge
    let statusClass = 'badge-secondary';
    if (shift.status === 'confirmed') statusClass = 'badge-success';
    else if (shift.status === 'pending') statusClass = 'badge-warning';
    else if (shift.status === 'completed') statusClass = 'badge-info';
    else if (shift.status === 'cancelled') statusClass = 'badge-danger';
    
    const shiftActions = renderShiftActions(shift);
    
    return `
        <tr class="shift-row" data-shift-id="${shift.id}">
            <td>${formatDate(shift.date)}</td>
            <td class="time-cell">${timeDisplay}</td>
            <td>
                ${staff.first_name || ''} ${staff.last_name || ''}
                ${leaveIndicator}
            </td>
            <td>${clientDisplay}</td>
            <td>${location.name || participant.address || '-'}</td>
            <td>${dutyType.name || '-'}</td>
            <td><span class="badge ${statusClass}">${shift.status || 'pending'}</span></td>
            <td class="actions-cell">${shiftActions}</td>
        </tr>
    `;
}

// Keep renderTable as it was originally (no async, no await needed)
function renderTable() {
    const tbody = document.getElementById('shiftsTableBody');
    
    if (!tbody) {
        console.error('shiftsTableBody element not found');
        return;
    }
    
    if (filteredShifts.length === 0) {
        tbody.innerHTML = `
            <tr>
                <td colspan="8" class="empty-state">
                    <h3>No shifts found</h3>
                    <p>Try adjusting your date range or filters</p>
                    <button class="btn btn-outline btn-sm" onclick="clearAllFilters()">Clear Filters</button>
                    <button class="btn btn-primary btn-sm" onclick="showAddShiftModal()" style="margin-left: 12px;">Add Shift</button>
                </td>
            </tr>
        `;
        return;
    }

    // Group shifts by date
    const groupedShifts = groupShiftsByDate(filteredShifts);
    
    let html = '';
    
    Object.keys(groupedShifts).sort().forEach(date => {
        const dayShifts = groupedShifts[date];
        const dayStats = calculateDayStats(dayShifts);
        
        // Day header
        html += `
            <tr class="day-header">
                <td colspan="8">
                    ${formatDateLong(date)} 
                    <span class="day-stats">
                        ${dayStats.shifts} shifts | ${formatHours(dayStats.totalHours)}h | $${dayStats.totalPay.toFixed(2)}
                    </span>
                </td>
            </tr>
        `;
        
        for (const shift of dayShifts) {
            html += renderShiftRow(shift, date);  // No await needed anymore
        }
    });

    tbody.innerHTML = html;
}

async function loadParticipantTemplates(participantId) {
    if (!participantId) {
        const templateSelect = document.getElementById('shiftTemplate');
        if (templateSelect) {
            templateSelect.innerHTML = '<option value="">-- Select Template --</option>';
            templateSelect.style.display = 'none';
        }
        return;
    }
    
    try {
        // Load templates from roster_templates table
        // These can be general templates or participant-specific
        const { data: templates, error: templatesError } = await supabaseClient
            .from('roster_templates')
            .select(`
                *,
                roster_template_shifts(*)
            `)
            .or(`participant_id.eq.${participantId},participant_id.is.null`) // Get participant-specific OR general templates
            .eq('is_active', true)
            .order('name');
        
        const templateSelect = document.getElementById('shiftTemplate');
        if (!templateSelect) return;
        
        templateSelect.innerHTML = '<option value="">-- No Template --</option>';
        
        if (!templatesError && templates && templates.length > 0) {
            // Group templates by type
            const participantTemplates = templates.filter(t => t.participant_id === participantId);
            const generalTemplates = templates.filter(t => !t.participant_id);
            
            // Add participant-specific templates first
            if (participantTemplates.length > 0) {
                templateSelect.innerHTML += '<optgroup label="Participant Templates">';
                participantTemplates.forEach(t => {
                    const shiftsCount = t.roster_template_shifts ? t.roster_template_shifts.length : 0;
                    templateSelect.innerHTML += `
                        <option value='${JSON.stringify(t)}'>
                            ${t.name} (${shiftsCount} shifts)
                        </option>`;
                });
                templateSelect.innerHTML += '</optgroup>';
            }
            
            // Add general templates
            if (generalTemplates.length > 0) {
                templateSelect.innerHTML += '<optgroup label="General Templates">';
                generalTemplates.forEach(t => {
                    const shiftsCount = t.roster_template_shifts ? t.roster_template_shifts.length : 0;
                    templateSelect.innerHTML += `
                        <option value='${JSON.stringify(t)}'>
                            ${t.name} (${shiftsCount} shifts)
                        </option>`;
                });
                templateSelect.innerHTML += '</optgroup>';
            }
            
            // Show template selector and add visual indicator
            templateSelect.style.display = 'block';
            if (templateSelect.parentElement) {
                templateSelect.parentElement.style.display = 'block';
            }
            
            // Add info message
            const existingInfo = templateSelect.parentElement?.querySelector('.text-info');
            if (existingInfo) {
                existingInfo.remove();
            }
            
            const infoDiv = document.createElement('div');
            infoDiv.className = 'text-info small mt-1';
            infoDiv.textContent = `${templates.length} template(s) available`;
            if (templateSelect.parentElement && !templateSelect.parentElement.querySelector('.text-info')) {
                templateSelect.parentElement.appendChild(infoDiv);
            }
        } else {
            // Hide template selector if no templates
            templateSelect.style.display = 'none';
            if (templateSelect.parentElement) {
                const existingInfo = templateSelect.parentElement.querySelector('.text-info');
                if (existingInfo) existingInfo.remove();
            }
        }
        
        // Add change handler to apply template
        templateSelect.onchange = function() {
            if (this.value) {
                applyTemplateToShift(JSON.parse(this.value));
            }
        };
        
    } catch (error) {
        console.error('Error loading participant templates:', error);
        const templateSelect = document.getElementById('shiftTemplate');
        if (templateSelect) {
            templateSelect.innerHTML = '<option value="">-- Error loading templates --</option>';
            templateSelect.style.display = 'none';
        }
    }
}

function applyTemplateToShift(template) {
    if (!template || !template.roster_template_shifts) return;
    
    // Get the first shift from the template (or handle multiple)
    const templateShift = template.roster_template_shifts[0];
    if (!templateShift) return;
    
    // Apply template values to the form
    const startTimeInput = document.getElementById('shiftStartTime');
    const endTimeInput = document.getElementById('shiftEndTime');
    const dutyTypeSelect = document.getElementById('shiftDutyType');
    const locationSelect = document.getElementById('shiftLocation');
    const staffSelect = document.getElementById('shiftStaff');
    const notesTextarea = document.getElementById('shiftNotes');
    
    if (startTimeInput && templateShift.start_time) {
        startTimeInput.value = templateShift.start_time;
    }
    
    if (endTimeInput && templateShift.end_time) {
        endTimeInput.value = templateShift.end_time;
    }
    
    if (dutyTypeSelect && templateShift.duty_type_id) {
        dutyTypeSelect.value = templateShift.duty_type_id;
    }
    
    if (locationSelect && templateShift.location_id) {
        locationSelect.value = templateShift.location_id;
    }
    
    if (staffSelect && templateShift.staff_id) {
        staffSelect.value = templateShift.staff_id;
    }
    
    if (notesTextarea && templateShift.notes) {
        notesTextarea.value = templateShift.notes;
    }
    
    showToast('Template applied successfully', 'success');
}

async function createParticipantTemplate(participantId, templateName, shifts) {
    try {
        // Create the template header
        const { data: template, error: templateError } = await supabaseClient
            .from('roster_templates')
            .insert({
                name: templateName,
                participant_id: participantId, // Link to specific participant
                description: `Template for ${participantId}`,
                is_active: true,
                created_by: currentUser?.id || null
            })
            .select()
            .single();
        
        if (templateError) throw templateError;
        
        // Create the template shifts
        if (shifts && shifts.length > 0) {
            const templateShifts = shifts.map(shift => ({
                template_id: template.id,
                day_of_week: shift.day_of_week || 1, // Default to Monday
                start_time: shift.start_time,
                end_time: shift.end_time,
                staff_id: shift.staff_id || null,
                duty_type_id: shift.duty_type_id,
                location_id: shift.location_id,
                notes: shift.notes || null
            }));
            
            const { error: shiftsError } = await supabaseClient
                .from('roster_template_shifts')
                .insert(templateShifts);
            
            if (shiftsError) throw shiftsError;
        }
        
        showToast('Template created successfully', 'success');
        return template;
        
    } catch (error) {
        console.error('Error creating participant template:', error);
        showToast('Failed to create template', 'error');
        return null;
    }
}

function applyShiftTemplate(templateJson) {
    if (!templateJson) {
        // Clear template-related fields if no template selected
        return;
    }
    
    try {
        const template = JSON.parse(templateJson);
        
        // Apply template values to form with validation
        if (template.start_time) {
            const startTimeInput = document.getElementById('shiftStartTime');
            if (startTimeInput) startTimeInput.value = template.start_time;
        }
        
        if (template.end_time) {
            const endTimeInput = document.getElementById('shiftEndTime');
            if (endTimeInput) endTimeInput.value = template.end_time;
        }
        
        if (template.duty_type_id) {
            const dutyTypeSelect = document.getElementById('shiftDutyType');
            if (dutyTypeSelect) {
                dutyTypeSelect.value = template.duty_type_id;
                // Trigger any onchange handlers
                if (dutyTypeSelect.onchange) dutyTypeSelect.onchange();
            }
        }
        
        if (template.location_id) {
            const locationSelect = document.getElementById('shiftLocation');
            if (locationSelect) locationSelect.value = template.location_id;
        }
        
        if (template.pay_rate_id) {
            const payRateSelect = document.getElementById('shiftPayRate');
            if (payRateSelect) payRateSelect.value = template.pay_rate_id;
        }
        
        // Add any template notes to the notes field
        if (template.notes) {
            const notesField = document.getElementById('shiftNotes');
            if (notesField) {
                notesField.value = template.notes + (notesField.value ? '\n' + notesField.value : '');
            }
        }
        
        showNotification(`Template "${template.template_name}" applied successfully`, 'success');
        
        // Highlight applied fields briefly
        const appliedFields = ['shiftStartTime', 'shiftEndTime', 'shiftDutyType', 'shiftLocation'];
        appliedFields.forEach(fieldId => {
            const field = document.getElementById(fieldId);
            if (field && field.value) {
                field.style.backgroundColor = '#e8f5e9';
                setTimeout(() => {
                    field.style.backgroundColor = '';
                }, 2000);
            }
        });
        
    } catch (error) {
        console.error('Error applying template:', error);
        showNotification('Failed to apply template', 'error');
    }
}

async function renderAvailability() {
    const availabilityContent = document.getElementById('availabilityContent');
    if (!availabilityContent) {
        const availabilityView = document.getElementById('availabilityView');
        if (availabilityView) {
            availabilityView.innerHTML = `
                <div class="table-container">
                    <header class="table-header">
                        <h2 class="table-title">Staff Availability & Leave</h2>
                        <div class="table-actions">
                            <button class="btn btn-primary btn-sm" onclick="showAvailabilityModal()">Set Availability</button>
                            <button class="btn btn-outline btn-sm" onclick="renderAvailability()">Refresh</button>
                        </div>
                    </header>
                    <div class="card-content" id="availabilityContent">
                        <div class="loading">
                            <div class="spinner"></div>
                            <span>Loading availability...</span>
                        </div>
                    </div>
                </div>
            `;
            availabilityContent = document.getElementById('availabilityContent');
        }
    }
    
    if (!availabilityContent) return;
    
    try {
        // Get current week dates
        const weekStart = new Date(currentWeekStart);
        const weekEnd = new Date(weekStart);
        weekEnd.setDate(weekEnd.getDate() + 6);
        
        // FIX #5: Load leave data for the week
        const { data: weekLeave } = await supabaseClient
            .from('staff_availability')
            .select('*, staff:staff_id(first_name, last_name)')
            .gte('date', weekStart.toISOString().split('T')[0])
            .lte('date', weekEnd.toISOString().split('T')[0])
            .eq('available', false)
            .order('date');
        
        // Load regular availability patterns
        const { data: availabilityPatterns } = await supabaseClient
            .from('staff_weekly_availability')
            .select('*, staff:staff_id(first_name, last_name)')
            .order('staff_id, day_of_week');
        
        // Build enhanced availability view
        let html = `
            <style>
                .availability-wrapper {
                    background: white;
                    border-radius: var(--radius-lg);
                    overflow: hidden;
                    margin-bottom: 20px;
                }
                .availability-tabs {
                    display: flex;
                    background: var(--bg-light);
                    border-bottom: 2px solid var(--border-color);
                }
                .availability-tab {
                    flex: 1;
                    padding: 15px;
                    text-align: center;
                    cursor: pointer;
                    background: transparent;
                    border: none;
                    font-weight: 500;
                    transition: all 0.3s;
                }
                .availability-tab.active {
                    background: white;
                    border-bottom: 3px solid var(--primary-color);
                    color: var(--primary-color);
                }
                .availability-content {
                    padding: 20px;
                }
                .week-grid {
                    display: grid;
                    grid-template-columns: repeat(7, 1fr);
                    gap: 10px;
                    margin-top: 20px;
                }
                .day-card {
                    background: white;
                    border: 1px solid var(--border-color);
                    border-radius: 8px;
                    min-height: 200px;
                    overflow: hidden;
                }
                .day-header {
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 12px;
                    text-align: center;
                }
                .day-header.weekend {
                    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
                }
                .day-date {
                    font-size: 11px;
                    opacity: 0.9;
                }
                .day-name {
                    font-weight: 600;
                    font-size: 14px;
                }
                .day-content {
                    padding: 12px;
                    max-height: 150px;
                    overflow-y: auto;
                }
                .leave-indicator {
                    margin-bottom: 8px;
                    padding: 8px;
                    border-radius: 6px;
                    font-size: 12px;
                    background: var(--bg-light);
                    border-left: 3px solid;
                }
                .leave-indicator.annual {
                    border-color: #17a2b8;
                    background: #d1ecf1;
                }
                .leave-indicator.sick {
                    border-color: #dc3545;
                    background: #f8d7da;
                }
                .leave-indicator.personal {
                    border-color: #ffc107;
                    background: #fff3cd;
                }
                .leave-indicator.other {
                    border-color: #6c757d;
                    background: #e2e3e5;
                }
                .staff-name {
                    font-weight: 600;
                    color: var(--text-primary);
                }
                .leave-type {
                    font-size: 10px;
                    text-transform: uppercase;
                    opacity: 0.8;
                }
                .availability-summary {
                    background: var(--bg-light);
                    padding: 15px;
                    border-radius: 8px;
                    margin-bottom: 20px;
                }
                .summary-stats {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                    gap: 15px;
                }
                .stat-item {
                    text-align: center;
                }
                .stat-value {
                    font-size: 24px;
                    font-weight: 700;
                    color: var(--primary-color);
                }
                .stat-label {
                    font-size: 12px;
                    color: var(--text-muted);
                    text-transform: uppercase;
                }
            </style>
            
            <div class="availability-wrapper">
                <div class="availability-tabs">
                    <button class="availability-tab active" onclick="switchAvailabilityView('week')">
                        Week View
                    </button>
                    <button class="availability-tab" onclick="switchAvailabilityView('staff')">
                        Staff Patterns
                    </button>
                    <button class="availability-tab" onclick="switchAvailabilityView('summary')">
                        Summary
                    </button>
                </div>
                
                <div class="availability-content">
                    <div id="weekView">
                        <h3>Week of ${formatDateShort(weekStart.toISOString())}</h3>
                        
                        <div class="availability-summary">
                            <div class="summary-stats">
                                <div class="stat-item">
                                    <div class="stat-value">${staff.length}</div>
                                    <div class="stat-label">Total Staff</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-value">${weekLeave ? weekLeave.length : 0}</div>
                                    <div class="stat-label">On Leave</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-value">${staff.length - (weekLeave ? weekLeave.length : 0)}</div>
                                    <div class="stat-label">Available</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="week-grid">
        `;
        
        // Create day cards
        const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        
        for (let day = 0; day < 7; day++) {
            const currentDate = new Date(weekStart);
            currentDate.setDate(currentDate.getDate() + day);
            const dateStr = currentDate.toISOString().split('T')[0];
            const dayName = dayNames[currentDate.getDay()];
            const isWeekend = currentDate.getDay() === 0 || currentDate.getDay() === 6;
            
            // Get leave for this day
            const dayLeave = weekLeave ? weekLeave.filter(l => l.date === dateStr) : [];
            
            html += `
                <div class="day-card" data-date="${dateStr}">
                    <div class="day-header ${isWeekend ? 'weekend' : ''}">
                        <div class="day-name">${dayName}</div>
                        <div class="day-date">${formatDateShort(dateStr)}</div>
                    </div>
                    <div class="day-content">
            `;
            
            if (dayLeave.length > 0) {
                dayLeave.forEach(leave => {
                    const leaveType = leave.reason || 'Leave';
                    let typeClass = 'other';
                    if (leaveType.toLowerCase().includes('annual')) typeClass = 'annual';
                    else if (leaveType.toLowerCase().includes('sick')) typeClass = 'sick';
                    else if (leaveType.toLowerCase().includes('personal')) typeClass = 'personal';
                    
                    html += `
                        <div class="leave-indicator ${typeClass}">
                            <div class="staff-name">
                                ${leave.staff.first_name} ${leave.staff.last_name}
                            </div>
                            <div class="leave-type">${leaveType}</div>
                        </div>
                    `;
                });
            } else {
                html += `
                    <div style="text-align: center; padding: 40px 10px; color: var(--text-muted);">
                        <div style="font-size: 24px; margin-bottom: 5px;">✅</div>
                        <div style="font-size: 12px;">All Available</div>
                    </div>
                `;
            }
            
            html += `
                    </div>
                </div>
            `;
        }
        
        html += `
                        </div>
                    </div>
                    
                    <div id="staffView" style="display: none;">
                        <h3>Staff Availability Patterns</h3>
                        <div style="margin-top: 20px;">
                            <!-- Staff patterns will be loaded here -->
                        </div>
                    </div>
                    
                    <div id="summaryView" style="display: none;">
                        <h3>Availability Summary</h3>
                        <div style="margin-top: 20px;">
                            <!-- Summary statistics will be loaded here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="availability-legend" style="margin-top: 20px; padding: 15px; background: var(--bg-light); border-radius: 8px;">
                <strong>Legend:</strong>
                <span class="badge badge-info" style="margin: 0 5px;">Annual Leave</span>
                <span class="badge badge-danger" style="margin: 0 5px;">Sick Leave</span>
                <span class="badge badge-warning" style="margin: 0 5px;">Personal Leave</span>
                <span class="badge badge-secondary" style="margin: 0 5px;">Other</span>
            </div>
        `;
        
        availabilityContent.innerHTML = html;
        
    } catch (error) {
        console.error('Error loading availability:', error);
        availabilityContent.innerHTML = '<div class="error">Failed to load availability data</div>';
    }
}

// This goes in the modal HTML structure - add after participant select
function getAddShiftModalTemplateHTML() {
    return `
        <div class="form-group" id="templateGroup" style="display: none;">
            <label>Use Template (Optional)</label>
            <select id="shiftTemplate" class="form-control" onchange="applyShiftTemplate(this.value)">
                <option value="">-- Select Template --</option>
            </select>
            <small class="form-text text-muted">
                Templates provide pre-filled shift settings for this participant
            </small>
        </div>
    `;
}
// Helper function to switch availability views
function switchAvailabilityView(view) {
    // Update tab active states
    document.querySelectorAll('.availability-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    event.target.classList.add('active');
    
    // Show/hide views
    document.getElementById('weekView').style.display = view === 'week' ? 'block' : 'none';
    document.getElementById('staffView').style.display = view === 'staff' ? 'block' : 'none';
    document.getElementById('summaryView').style.display = view === 'summary' ? 'block' : 'none';
}

// Add event listener for participant selection to load templates
function setupParticipantTemplateLoader() {
    const participantSelect = document.getElementById('shiftParticipant');
    if (participantSelect) {
        participantSelect.addEventListener('change', function() {
            loadParticipantTemplates(this.value);
        });
    }
    
    const participantInput = document.getElementById('shiftParticipantInput');
    if (participantInput) {
        participantInput.addEventListener('change', function() {
            const hiddenSelect = document.getElementById('shiftParticipant');
            if (hiddenSelect && hiddenSelect.value) {
                loadParticipantTemplates(hiddenSelect.value);
            }
        });
    }
}


function onParticipantSelect(participantSelectId, locationSelectId) {
    const participantSelect = document.getElementById(participantSelectId);
    const locationSelect = document.getElementById(locationSelectId);
    
    if (!participantSelect.value) {
        locationSelect.value = '';
        return;
    }
    
    const selectedParticipant = participants.find(p => p.id === participantSelect.value);
    if (!selectedParticipant) return;
    
    // Auto-select location based on participant
    let foundLocation = false;
    
    // Check if participant is in a care home
    if (selectedParticipant.address) {
        const participantAddress = selectedParticipant.address.toLowerCase();
        
        // Check for care homes
        careHomes.forEach((careHome, careHomeAddress) => {
            if (participantAddress.includes(careHomeAddress)) {
                const careHomeLocation = locations.find(l => 
                    l.name.toLowerCase().includes('saunders') || 
                    (l.address && l.address.toLowerCase().includes(careHomeAddress))
                );
                
                if (careHomeLocation) {
                    locationSelect.value = careHomeLocation.id;
                    foundLocation = true;
                }
            }
        });
    }
    
    // If not in care home, select generic home location
    if (!foundLocation) {
        const homeLocation = locations.find(l => 
            l.name.toLowerCase().includes('home') ||
            l.name.toLowerCase().includes('client')
        );
        
        if (homeLocation) {
            locationSelect.value = homeLocation.id;
        }
    }
} 
function showOverlapTooltip(event, shiftId) {
    // Implementation for hover tooltip showing overlap details
    const tooltip = document.createElement('div');
    tooltip.className = 'overlap-tooltip';
    tooltip.id = 'overlapTooltip';
    
    const shift = shifts.find(s => s.id === shiftId);
    if (shift?.overlap_info) {
        tooltip.innerHTML = `
            <strong>${shift.overlap_info.ratio} Care Ratio</strong><br>
            ${shift.overlap_info.staff.map(s => 
                `${s.staff.first_name} ${s.staff.last_name}: ${s.time}`
            ).join('<br>')}
        `;
        
        tooltip.style.position = 'absolute';
        tooltip.style.left = event.pageX + 10 + 'px';
        tooltip.style.top = event.pageY + 10 + 'px';
        
        document.body.appendChild(tooltip);
    }
}

function hideOverlapTooltip() {
    const tooltip = document.getElementById('overlapTooltip');
    if (tooltip) tooltip.remove();
}

        function renderShiftActions(shift) {
            let actions = [];
            
            // Admin/Manager can edit any shift
            if (currentUserRole === 'admin' || currentUserRole === 'manager') {
                actions.push(`<button class="btn btn-outline btn-sm" onclick="editShift(${shift.id})">Edit</button>`);
                actions.push(`<button class="btn btn-danger btn-sm" onclick="deleteShiftConfirm(${shift.id})">Delete</button>`);
            }
            
            // All users can add notes
            actions.push(`<button class="btn btn-outline btn-sm" onclick="addNoteToShift(${shift.id})">Note</button>`);
            
            return actions.join('');
        }

        function groupShiftsByDate(shifts) {
            const groups = {};
            shifts.forEach(shift => {
                if (!groups[shift.date]) {
                    groups[shift.date] = [];
                }
                groups[shift.date].push(shift);
            });
            return groups;
        }

        function calculateDayStats(dayShifts) {
            return dayShifts.reduce((stats, shift) => {
                const hours = shift.calculated_hours || { total: 0 };
                stats.shifts++;
                stats.totalHours += hours.total;
                stats.totalPay += shift.calculated_pay || 0;
                return stats;
            }, { shifts: 0, totalHours: 0, totalPay: 0 });
        }

        function generateHourBreakdownTooltip(hours) {
            const parts = [];
            if (hours.weekdayDay > 0) parts.push(`Day: ${formatHours(hours.weekdayDay)}h`);
            if (hours.weekdayEvening > 0) parts.push(`Evening: ${formatHours(hours.weekdayEvening)}h`);
            if (hours.weekdayNight > 0) parts.push(`Night: ${formatHours(hours.weekdayNight)}h`);
            if (hours.saturday > 0) parts.push(`Saturday: ${formatHours(hours.saturday)}h`);
            if (hours.sunday > 0) parts.push(`Sunday: ${formatHours(hours.sunday)}h`);
            if (hours.publicHoliday > 0) parts.push(`Holiday: ${formatHours(hours.publicHoliday)}h`);
            if (hours.sleepover > 0) parts.push(`Sleepover: ${formatHours(hours.sleepover)}h`);
            
            return parts.join(' | ') || 'No breakdown available';
        }

        function generatePayBreakdownDisplay(hours) {
            const parts = [];
            if (hours.weekdayDay > 0) parts.push(`D:${formatHours(hours.weekdayDay)}`);
            if (hours.weekdayEvening > 0) parts.push(`E:${formatHours(hours.weekdayEvening)}`);
            if (hours.weekdayNight > 0) parts.push(`N:${formatHours(hours.weekdayNight)}`);
            if (hours.saturday > 0) parts.push(`Sa:${formatHours(hours.saturday)}`);
            if (hours.sunday > 0) parts.push(`Su:${formatHours(hours.sunday)}`);
            if (hours.publicHoliday > 0) parts.push(`PH:${formatHours(hours.publicHoliday)}`);
            if (hours.sleepover > 0) parts.push(`SL:${formatHours(hours.sleepover)}`);
            
            return parts.join(' • ') || '—';
        }


        function createSearchableDropdown(selectId, options = {}) {
    const select = document.getElementById(selectId);
    if (!select) return;
    
    // Create wrapper
    const wrapper = document.createElement('div');
    wrapper.className = 'searchable-dropdown-wrapper';
    wrapper.style.position = 'relative';
    
    // Create search input
    const searchInput = document.createElement('input');
    searchInput.type = 'text';
    searchInput.className = 'form-control searchable-input';
    searchInput.placeholder = options.placeholder || 'Type to search...';
    searchInput.style.cssText = `
        width: 100%;
        padding: 8px 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
    `;
    
    // Create dropdown list
    const dropdownList = document.createElement('div');
    dropdownList.className = 'searchable-dropdown-list';
    dropdownList.style.cssText = `
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        max-height: 200px;
        overflow-y: auto;
        background: white;
        border: 1px solid #ddd;
        border-top: none;
        border-radius: 0 0 4px 4px;
        display: none;
        z-index: 1000;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    `;
    
    // Store selected value
    let selectedValue = select.value;
    let selectedText = '';
    
    // Get options from original select
    const originalOptions = Array.from(select.options).map(opt => ({
        value: opt.value,
        text: opt.textContent,
        data: opt.dataset
    }));
    
    // Function to update dropdown list
    function updateDropdownList(searchTerm = '') {
        dropdownList.innerHTML = '';
        
        const filtered = originalOptions.filter(opt => 
            opt.text.toLowerCase().includes(searchTerm.toLowerCase())
        );
        
        if (filtered.length === 0) {
            dropdownList.innerHTML = '<div style="padding: 8px; color: #999;">No results found</div>';
            return;
        }
        
        filtered.forEach(opt => {
            const item = document.createElement('div');
            item.className = 'dropdown-item';
            item.style.cssText = `
                padding: 8px 12px;
                cursor: pointer;
                transition: background 0.2s;
            `;
            item.textContent = opt.text;
            item.dataset.value = opt.value;
            
            // Copy any data attributes
            Object.keys(opt.data || {}).forEach(key => {
                item.dataset[key] = opt.data[key];
            });
            
            item.onmouseover = () => item.style.background = '#f0f0f0';
            item.onmouseout = () => item.style.background = 'white';
            
            item.onclick = () => {
                selectedValue = opt.value;
                selectedText = opt.text;
                searchInput.value = opt.text;
                select.value = opt.value;
                
                // Trigger change event on original select
                const event = new Event('change', { bubbles: true });
                select.dispatchEvent(event);
                
                dropdownList.style.display = 'none';
            };
            
            dropdownList.appendChild(item);
        });
    }
    
    // Event handlers
    searchInput.onfocus = () => {
        updateDropdownList('');
        dropdownList.style.display = 'block';
    };
    
    searchInput.oninput = (e) => {
        updateDropdownList(e.target.value);
        dropdownList.style.display = 'block';
    };
    
    // Click outside to close
    document.addEventListener('click', (e) => {
        if (!wrapper.contains(e.target)) {
            dropdownList.style.display = 'none';
        }
    });
    
    // Set initial value
    if (select.value) {
        const initial = originalOptions.find(opt => opt.value === select.value);
        if (initial) {
            searchInput.value = initial.text;
            selectedText = initial.text;
        }
    }
    
    // Replace select with wrapper
    select.style.display = 'none';
    wrapper.appendChild(searchInput);
    wrapper.appendChild(dropdownList);
    select.parentNode.insertBefore(wrapper, select.nextSibling);
    
    // Store reference for later updates
    select._searchableDropdown = {
        update: () => updateDropdownList(''),
        setValue: (value) => {
            const opt = originalOptions.find(o => o.value === value);
            if (opt) {
                selectedValue = opt.value;
                selectedText = opt.text;
                searchInput.value = opt.text;
                select.value = opt.value;
            }
        },
        getValue: () => selectedValue
    };
    
    return select._searchableDropdown;
}

async function populateEditModalDropdowns(shift = null) {
    try {
        // Ensure reference data is loaded
        if (!participants.length || !staff.length) {
            await loadReferenceData();
        }
        
        // Staff dropdown
        const staffSelect = document.getElementById('editStaff');
        if (staffSelect) {
            staffSelect.innerHTML = '<option value="">Select Staff</option>';
            staff.forEach(s => {
                const option = document.createElement('option');
                option.value = s.id;
                option.textContent = `${s.first_name} ${s.last_name}`;
                if (shift && shift.staff_id === s.id) {
                    option.selected = true;
                }
                staffSelect.appendChild(option);
            });
            
            // Make it searchable
            createSearchableDropdown('editStaff', {
                placeholder: 'Type to search staff...'
            });
        }
        
        // Participant dropdown
        const participantSelect = document.getElementById('editParticipant');
        if (participantSelect) {
            participantSelect.innerHTML = '<option value="">Select Client</option>';
            participants.forEach(p => {
                const option = document.createElement('option');
                option.value = p.id;
                option.textContent = `${p.first_name} ${p.last_name}`;
                if (shift && shift.participant_id === p.id) {
                    option.selected = true;
                }
                participantSelect.appendChild(option);
            });
            
            // Make it searchable
            createSearchableDropdown('editParticipant', {
                placeholder: 'Type to search client...'
            });
        }
        
        // Location dropdown
        const locationSelect = document.getElementById('editLocation');
        if (locationSelect) {
            locationSelect.innerHTML = '<option value="">Select Location</option>';
            
            // Add default Client Home option
            const clientHome = document.createElement('option');
            clientHome.value = '00000000-0000-0000-0000-000000000001';
            clientHome.textContent = 'Client Home';
            locationSelect.appendChild(clientHome);
            
            locations.forEach(l => {
                if (l.id !== '00000000-0000-0000-0000-000000000001') {
                    const option = document.createElement('option');
                    option.value = l.id;
                    option.textContent = l.name;
                    if (shift && shift.location_id === l.id) {
                        option.selected = true;
                    }
                    locationSelect.appendChild(option);
                }
            });
            
            // Make it searchable
            createSearchableDropdown('editLocation', {
                placeholder: 'Type to search location...'
            });
        }
        
        // Duty Type dropdown
        const dutyTypeSelect = document.getElementById('editDutyType');
        if (dutyTypeSelect) {
            dutyTypeSelect.innerHTML = '<option value="">Select Duty Type</option>';
            dutyTypes.forEach(dt => {
                const option = document.createElement('option');
                option.value = dt.id;
                option.textContent = dt.name;
                if (shift && shift.duty_type_id === dt.id) {
                    option.selected = true;
                }
                dutyTypeSelect.appendChild(option);
            });
            
            // Make it searchable
            createSearchableDropdown('editDutyType', {
                placeholder: 'Type to search duty type...'
            });
        }
        
    } catch (error) {
        console.error('Error populating modal dropdowns:', error);
        showToast('Failed to load dropdown options', 'error');
    }
}

        // ========================================
        // SEARCHABLE DROPDOWNS - FIXED
        // ========================================

        function populateFilterDropdowns() {
            console.log('Populating filter dropdowns...');

            // Staff filter dropdown
            const staffList = document.getElementById('staffFilterList');
            if (staffList && staff.length > 0) {
                staffList.innerHTML = '';
                staff.forEach(s => {
                    const option = document.createElement('option');
                    option.value = `${s.first_name} ${s.last_name}`;
                    option.setAttribute('data-id', s.id);
                    staffList.appendChild(option);
                });
            }

            // Participant filter dropdown
            const participantList = document.getElementById('participantFilterList');
            if (participantList && participants.length > 0) {
                participantList.innerHTML = '';
                participants.forEach(p => {
                    const option = document.createElement('option');
                    option.value = `${p.first_name} ${p.last_name}`;
                    option.setAttribute('data-id', p.id);
                    participantList.appendChild(option);
                });
            }
        }

        function updateStaffFilter() {
            const input = document.getElementById('staffFilterInput');
            const selectedStaff = staff.find(s => `${s.first_name} ${s.last_name}` === input.value);
            staffFilterValue = selectedStaff ? selectedStaff.id : '';
            console.log('Staff filter updated:', staffFilterValue);
            applyFilters();
        }

        function updateParticipantFilter() {
    const input = document.getElementById('participantFilterInput');
    const selectedParticipant = participants.find(p => 
        `${p.first_name} ${p.last_name}` === input.value
    );
    participantFilterValue = selectedParticipant ? selectedParticipant.id : '';
    
    // Remove any existing care home filter
    const existingFilter = document.getElementById('careHomeResidentFilter');
    if (existingFilter) existingFilter.remove();
    
    // Check if selected participant is a care home
    if (selectedParticipant) {
        let foundCareHome = null;
        
        // Check if this participant ID is a main care home entity
        careHomes.forEach((ch, address) => {
            if (ch.mainEntityId === selectedParticipant.id) {
                foundCareHome = ch;
                activeCareHomeFilter = address;
            }
        });
        
        // If found, show the resident filter
        if (foundCareHome) {
            showCareHomeResidentFilter(foundCareHome);
        } else {
            activeCareHomeFilter = null;
        }
    } else {
        activeCareHomeFilter = null;
    }
    
    console.log('Participant filter updated:', participantFilterValue);
    applyFilters();
}

function showCareHomeResidentFilter(careHome) {
    const filterRow = document.querySelector('.filter-row');
    
    // Remove existing filter if present
    const existingFilter = document.getElementById('careHomeResidentFilter');
    if (existingFilter) existingFilter.remove();
    
    // Debug log
    console.log('Showing care home filter for:', careHome);
    console.log('Residents:', careHome.residents);
    
    // Create filter UI
    const careHomeFilter = document.createElement('div');
    careHomeFilter.className = 'filter-group';
    careHomeFilter.id = 'careHomeResidentFilter';
    
    const residentCount = careHome.residents.length;
    
    // Build the HTML
    let filterHTML = `
        <label>${careHome.name} Filter</label>
        <div style="
            background: var(--bg-light); 
            border: 1px solid var(--border-color); 
            border-radius: var(--radius-md);
            padding: 12px;
            max-height: 250px;
            overflow-y: auto;
        ">
    `;
    
    // Add general shifts checkbox if there's a main entity
    if (careHome.mainEntityId) {
        filterHTML += `
            <div style="margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid var(--border-color);">
                <label style="display: flex; align-items: center; cursor: pointer; font-weight: 600;">
                    <input type="checkbox" id="includeGeneralShifts" 
                           checked
                           onchange="applyCareHomeFilter()">
                    <span style="margin-left: 8px;">Include General ${careHome.name} Shifts</span>
                </label>
            </div>
        `;
    }
    
    // Add residents section
    if (residentCount > 0) {
        filterHTML += `
            <div style="margin-bottom: 8px;">
                <label style="display: flex; align-items: center; cursor: pointer; font-weight: 600;">
                    <input type="checkbox" id="selectAllResidents" 
                           onchange="toggleAllResidents(this)" checked>
                    <span style="margin-left: 8px;">All Residents (${residentCount})</span>
                </label>
            </div>
        `;
        
        // Add each resident
        careHome.residents.forEach(resident => {
            filterHTML += `
                <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 4px; padding-left: 20px;">
                    <input type="checkbox" class="resident-checkbox" 
                           value="${resident.id}" 
                           data-name="${resident.first_name} ${resident.last_name}"
                           checked
                           onchange="applyCareHomeFilter()">
                    <span style="margin-left: 8px;">${resident.first_name} ${resident.last_name}</span>
                </label>
            `;
        });
    } else {
        // No residents but show shifts for the care home entity
        filterHTML += `
            <p style="color: var(--text-muted); text-align: center; margin: 20px 0;">
                No individual residents found.<br>
                ${careHome.mainEntityId ? 'Showing general care home shifts only.' : 'No shifts to display.'}
            </p>
        `;
    }
    
    filterHTML += `
        </div>
        <button class="btn btn-outline btn-sm" onclick="clearCareHomeFilter()" style="margin-top: 8px; width: 100%;">
            Clear ${careHome.name} Filter
        </button>
    `;
    
    careHomeFilter.innerHTML = filterHTML;
    
    // Insert after participant filter
    const participantFilterGroup = document.getElementById('participantFilterInput').closest('.filter-group');
    participantFilterGroup.after(careHomeFilter);
    
    showNotification(`Filtering by ${careHome.name} (${residentCount} residents)`, 'info');
    applyCareHomeFilter();
}

// Apply care home filter (generic for any care home)
window.applyCareHomeFilter = function() {
    if (!activeCareHomeFilter) {
        applyFilters();
        return;
    }
    
    const careHome = careHomes.get(activeCareHomeFilter);
    if (!careHome) {
        applyFilters();
        return;
    }
    
    const includeGeneral = document.getElementById('includeGeneralShifts')?.checked ?? false;
    const selectedResidents = Array.from(document.querySelectorAll('.resident-checkbox:checked'))
        .map(cb => cb.value);
    
    // Get other filter values
    const startDate = document.getElementById('startDate').value;
    const endDate = document.getElementById('endDate').value;
    const statusFilter = document.getElementById('statusFilter').value;
    
    // Filter shifts
    filteredShifts = shifts.filter(shift => {
        // Apply standard filters
        if (startDate && shift.date < startDate) return false;
        if (endDate && shift.date > endDate) return false;
        if (statusFilter && shift.status !== statusFilter) return false;
        if (staffFilterValue && shift.staff_id !== staffFilterValue) return false;
        
        // Care home filter
        const isGeneralShift = careHome.mainEntityId && shift.participant_id === careHome.mainEntityId;
        const isResidentShift = selectedResidents.includes(shift.participant_id);
        
        if (includeGeneral && isGeneralShift) return true;
        if (isResidentShift) return true;
        
        return false;
    });
    
    // Update "All Residents" checkbox
    const allCheckbox = document.getElementById('selectAllResidents');
    const residentCheckboxes = document.querySelectorAll('.resident-checkbox');
    if (allCheckbox && residentCheckboxes.length > 0) {
        allCheckbox.checked = selectedResidents.length === residentCheckboxes.length;
    }
    
    console.log(`Filtered to ${filteredShifts.length} shifts for ${careHome.name}`);
    renderCurrentView();
}

// Clear care home filter
window.clearCareHomeFilter = function() {
    document.getElementById('participantFilterInput').value = '';
    participantFilterValue = '';
    activeCareHomeFilter = null;
    
    const careHomeFilter = document.getElementById('careHomeResidentFilter');
    if (careHomeFilter) careHomeFilter.remove();
    
    applyFilters();
}

// Toggle all residents
window.toggleAllResidents = function(checkbox) {
    const residentCheckboxes = document.querySelectorAll('.resident-checkbox');
    residentCheckboxes.forEach(cb => cb.checked = checkbox.checked);
    applyCareHomeFilter();
}
// FIX FOR MC-MANAGER.HTML MODAL DROPDOWNS
// Replace the existing populateModalDropdowns function with this corrected version

function populateModalDropdowns() {
    console.log('Populating modal dropdowns with data:', {
        staff: staff.length,
        participants: participants.length,
        locations: locations.length,
        dutyTypes: dutyTypes.length
    });
    
    // ===== POPULATE DATALISTS FOR STAFF (autocomplete inputs) =====
    const staffDataLists = [
        'staffDataList',        // For create shift modal
        'editStaffList'         // For edit shift modal
    ];
    
    staffDataLists.forEach(datalistId => {
        const datalist = document.getElementById(datalistId);
        if (datalist) {
            datalist.innerHTML = '';
            staff.forEach(s => {
                const option = document.createElement('option');
                option.value = `${s.first_name} ${s.last_name}`;
                option.setAttribute('data-id', s.id);
                datalist.appendChild(option);
            });
            console.log(`Populated ${datalistId} with ${staff.length} staff members`);
        } else {
            console.warn(`Datalist ${datalistId} not found`);
        }
    });
    
    // ===== POPULATE DATALISTS FOR PARTICIPANTS (autocomplete inputs) =====
    const participantDataLists = [
        'participantDataList',   // For create shift modal
        'editParticipantList'    // For edit shift modal
    ];
    
    participantDataLists.forEach(datalistId => {
        const datalist = document.getElementById(datalistId);
        if (datalist) {
            datalist.innerHTML = '';
            
            // Group participants by care home
            const careHomeParticipants = [];
            const homeParticipants = [];
            
            participants.forEach(p => {
                // Check if participant is in a care home
                const isCareHome = p.address && (
                    p.address.toLowerCase().includes('saunders') ||
                    locations.some(l => l.is_care_home && l.address && 
                        p.address.toLowerCase().includes(l.address.toLowerCase().split(',')[0])
                    )
                );
                
                if (isCareHome) {
                    careHomeParticipants.push(p);
                } else {
                    homeParticipants.push(p);
                }
            });
            
            // Add all participants to datalist (care home indicator in the display)
            participants.forEach(p => {
                const option = document.createElement('option');
                const isCareHome = careHomeParticipants.includes(p);
                const label = isCareHome ? ' (Care Home)' : '';
                option.value = `${p.first_name} ${p.last_name}${label}`;
                option.setAttribute('data-id', p.id);
                datalist.appendChild(option);
            });
            
            console.log(`Populated ${datalistId} with ${participants.length} participants`);
        } else {
            console.warn(`Datalist ${datalistId} not found`);
        }
    });

    // ===== POPULATE LOCATION DROPDOWNS (regular selects) =====
    const locationSelects = [
        document.getElementById('shiftLocation'),
        document.getElementById('editShiftLocation')
    ];
    
    locationSelects.forEach(select => {
        if (select) {
            select.innerHTML = '<option value="">Select Location</option>';
            
            // Group locations
            const careHomes = locations.filter(l => l.is_care_home);
            const otherLocations = locations.filter(l => !l.is_care_home);
            
            // Add care homes first
            if (careHomes.length > 0) {
                select.innerHTML += '<optgroup label="Care Homes">';
                careHomes.forEach(l => {
                    select.innerHTML += `<option value="${l.id}">${l.name}</option>`;
                });
                select.innerHTML += '</optgroup>';
            }
            
            // Add other locations
            if (otherLocations.length > 0) {
                select.innerHTML += '<optgroup label="Other Locations">';
                otherLocations.forEach(l => {
                    select.innerHTML += `<option value="${l.id}">${l.name}</option>`;
                });
                select.innerHTML += '</optgroup>';
            }
            
            console.log(`Populated location select with ${locations.length} locations`);
        }
    });

    // ===== POPULATE DUTY TYPE DROPDOWNS (regular selects) =====
    const dutyTypeSelects = [
        document.getElementById('shiftDutyType'),
        document.getElementById('editShiftDutyType')
    ];
    
    dutyTypeSelects.forEach(select => {
        if (select) {
            select.innerHTML = '<option value="">Select Duty Type</option>';
            dutyTypes.forEach(dt => {
                select.innerHTML += `<option value="${dt.id}">${dt.name}</option>`;
            });
            console.log(`Populated duty type select with ${dutyTypes.length} duty types`);
        }
    });

    // ===== POPULATE PAY RATE DROPDOWNS (if they exist) =====
    const payRateSelects = [
        document.getElementById('shiftPayRate'),
        document.getElementById('editShiftPayRate')
    ];
    
    payRateSelects.forEach(select => {
        if (select && payRates) {
            select.innerHTML = '<option value="">Use Staff Default</option>';
            
            // Group pay rates by category for better organization
            const groupedRates = {};
            payRates.forEach(pr => {
                const category = pr.category || 'Other';
                if (!groupedRates[category]) {
                    groupedRates[category] = [];
                }
                groupedRates[category].push(pr);
            });
            
            // Add grouped options
            Object.keys(groupedRates).sort().forEach(category => {
                if (groupedRates[category].length > 0) {
                    select.innerHTML += `<optgroup label="${category}">`;
                    groupedRates[category].forEach(pr => {
                        const label = payRateLabels?.get(pr.id) || 
                                    `${category} - Level ${pr.level || '?'} - Point ${pr.pay_point || '?'}`;
                        const rate = pr.hourly_pay_rate || pr.base_rate || 0;
                        select.innerHTML += `<option value="${pr.id}">${label} ($${rate}/hr)</option>`;
                    });
                    select.innerHTML += `</optgroup>`;
                }
            });
        }
    });

    // ===== POPULATE STATUS DROPDOWN (only for edit modal) =====
    const statusSelect = document.getElementById('editShiftStatus');
    if (statusSelect) {
        statusSelect.innerHTML = `
            <option value="pending">Pending</option>
            <option value="confirmed">Confirmed</option>
            <option value="completed">Completed</option>
            <option value="cancelled">Cancelled</option>
        `;
    }

    console.log('✅ Modal dropdowns populated successfully');
}

// ALSO ADD/UPDATE these helper functions if they don't exist:

function updateStaffSelection() {
    const input = document.getElementById('shiftStaffInput');
    const hiddenInput = document.getElementById('shiftStaff');
    
    // Remove any care home indicator for matching
    const inputValue = input.value.replace(' (Care Home)', '');
    const selectedStaff = staff.find(s => `${s.first_name} ${s.last_name}` === inputValue);
    
    if (selectedStaff) {
        hiddenInput.value = selectedStaff.id;
        if (typeof updateHourWarning === 'function') {
            updateHourWarning();
        }
    } else {
        hiddenInput.value = '';
    }
}

function updateParticipantSelection() {
    const input = document.getElementById('shiftParticipantInput');
    const hiddenInput = document.getElementById('shiftParticipant');
    const locationSelect = document.getElementById('shiftLocation');
    
    // Remove any care home indicator for matching
    const inputValue = input.value.replace(' (Care Home)', '');
    const selectedParticipant = participants.find(p => `${p.first_name} ${p.last_name}` === inputValue);
    
    if (selectedParticipant) {
        hiddenInput.value = selectedParticipant.id;
        
        // Auto-select location based on participant
        if (locationSelect && selectedParticipant.address) {
            const addressLower = selectedParticipant.address.toLowerCase();
            
            // Check for Saunders Care Home
            if (addressLower.includes('saunders')) {
                const saundersLocation = locations.find(l => 
                    l.name.toLowerCase().includes('saunders') || 
                    (l.address && l.address.toLowerCase().includes('saunders'))
                );
                if (saundersLocation) {
                    locationSelect.value = saundersLocation.id;
                    console.log('Auto-selected Saunders Care Home');
                }
            } 
            // Check for other care homes
            else {
                const careHomeLocation = locations.find(l => 
                    l.is_care_home && l.address && 
                    addressLower.includes(l.address.toLowerCase().split(',')[0])
                );
                if (careHomeLocation) {
                    locationSelect.value = careHomeLocation.id;
                    console.log('Auto-selected care home:', careHomeLocation.name);
                }
            }
            
            // If no care home found, select Client Home
            if (!locationSelect.value) {
                const clientHome = locations.find(l => 
                    l.name.toLowerCase().includes('client home') ||
                    l.id === '00000000-0000-0000-0000-000000000001'
                );
                if (clientHome) {
                    locationSelect.value = clientHome.id;
                    console.log('Auto-selected Client Home');
                }
            }
        }
    } else {
        hiddenInput.value = '';
    }
}


function updateEditStaffSelection() {
    const input = document.getElementById('editShiftStaffInput');
    const hiddenInput = document.getElementById('editShiftStaff');
    
    // Remove any care home indicator for matching
    const inputValue = input.value.replace(' (Care Home)', '');
    const selectedStaff = staff.find(s => `${s.first_name} ${s.last_name}` === inputValue);
    
    hiddenInput.value = selectedStaff ? selectedStaff.id : '';
}

function updateEditParticipantSelection() {
    const input = document.getElementById('editShiftParticipantInput');
    const hiddenInput = document.getElementById('editShiftParticipant');
    const locationSelect = document.getElementById('editShiftLocation');
    
    // Remove any care home indicator for matching
    const inputValue = input.value.replace(' (Care Home)', '');
    const selectedParticipant = participants.find(p => `${p.first_name} ${p.last_name}` === inputValue);
    
    if (selectedParticipant) {
        hiddenInput.value = selectedParticipant.id;
        
        // Auto-select location for edit modal too
        if (locationSelect && selectedParticipant.address) {
            const addressLower = selectedParticipant.address.toLowerCase();
            
            // Same logic as create modal
            if (addressLower.includes('saunders')) {
                const saundersLocation = locations.find(l => 
                    l.name.toLowerCase().includes('saunders') || 
                    (l.address && l.address.toLowerCase().includes('saunders'))
                );
                if (saundersLocation) {
                    locationSelect.value = saundersLocation.id;
                }
            } else {
                const careHomeLocation = locations.find(l => 
                    l.is_care_home && l.address && 
                    addressLower.includes(l.address.toLowerCase().split(',')[0])
                );
                if (careHomeLocation) {
                    locationSelect.value = careHomeLocation.id;
                } else {
                    const clientHome = locations.find(l => 
                        l.name.toLowerCase().includes('client home') ||
                        l.id === '00000000-0000-0000-0000-000000000001'
                    );
                    if (clientHome) {
                        locationSelect.value = clientHome.id;
                    }
                }
            }
        }
    } else {
        hiddenInput.value = '';
    }
}

async function createShift() {
    try {
        const date = document.getElementById('shiftDate').value;
        const startTime = document.getElementById('shiftStartTime').value;
        const endTime = document.getElementById('shiftEndTime').value;
        const staffId = document.getElementById('shiftStaff').value;
        const participantId = document.getElementById('shiftParticipant').value || null;
        const locationId = document.getElementById('shiftLocation').value || null;
        const dutyTypeId = document.getElementById('shiftDutyType').value;
        const payRateId = document.getElementById('shiftPayRate').value;

        // Basic validation
        if (!date || !staffId || !dutyTypeId) {
            showNotification('Please fill required fields (Date, Staff, Duty Type)', 'error');
            return;
        }

        if (!participantId && !locationId) {
            showNotification('Please select either participant or location', 'error');
            return;
        }

        // Get the staff member's default pay rate if no override selected
        const selectedStaff = staff.find(s => s.id === staffId);
        const effectivePayRateId = payRateId || selectedStaff?.pay_rate_id || '00000000-0000-0000-0000-000000000002';

        // Calculate duration
        let duration_hours = null;
        const selectedDutyType = dutyTypes.find(d => d.id === dutyTypeId);
        if (selectedDutyType?.name.toLowerCase().includes('sleepover')) {
            duration_hours = 2;
        } else if (startTime && endTime) {
            const start = new Date(`2000-01-01T${startTime}`);
            let end = new Date(`2000-01-01T${endTime}`);
            if (end <= start) end.setDate(end.getDate() + 1);
            duration_hours = (end - start) / (1000 * 60 * 60);
        }

        const shiftData = {
            date: date,
            start_time: startTime || null,
            end_time: endTime || null,
            staff_id: staffId,
            participant_id: participantId,
            location_id: locationId,
            duty_type_id: dutyTypeId,
            pay_override_id: effectivePayRateId, // FIXED: Using correct pay rate
            created_by: currentStaffData?.id || currentUser.id,
            status: 'confirmed',
            duration_hours: duration_hours
        };

        console.log('Creating shift with data:', shiftData);

        const { data: newShift, error } = await supabaseClient
            .from('shifts')
            .insert([shiftData])
            .select()
            .single();

        if (error) throw error;

        showNotification('Shift created successfully', 'success');
        closeModal('addShiftModal');
        await loadShifts();

    } catch (error) {
        console.error('Error creating shift:', error);
        showNotification('Failed to create shift: ' + error.message, 'error');
    }
}


function getParticipantColor(participantId) {
    if (!participantId) return 'transparent';
    
    const colors = [
        '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
        '#1abc9c', '#e67e22', '#16a085', '#f1c40f', '#e84393',
        '#00b894', '#6c5ce7', '#fdcb6e', '#fd79a8', '#a29bfe'
    ];
    
    // Use participant ID to consistently pick same color
    const hash = participantId.split('').reduce((acc, char) => 
        acc + char.charCodeAt(0), 0);
    
    return colors[hash % colors.length];
}
// Helper function to view a specific staff member's week
function viewStaffWeek(staffId, weekStart) {
    // Set filters
    document.getElementById('staffFilterInput').value = 
        staff.find(s => s.id === staffId)?.first_name + ' ' + 
        staff.find(s => s.id === staffId)?.last_name;
    updateStaffFilter();
    
    // Set week
    currentWeekStart = new Date(weekStart);
    updateWeekDisplay();
    loadShifts();
    
    // Switch to roster view
    switchView('table');
}


function editShift(shiftId) {
    const shift = shifts.find(s => s.id === shiftId);
    if (!shift) {
        console.error('Shift not found:', shiftId);
        return;
    }

    console.log('Editing shift:', shift);

    // Populate edit form
    document.getElementById('editShiftId').value = shift.id;
    document.getElementById('editShiftDate').value = shift.date;
    document.getElementById('editShiftStartTime').value = shift.start_time || '';
    document.getElementById('editShiftEndTime').value = shift.end_time || '';
    
    // Set staff selection
    if (shift.staff) {
        const staffName = `${shift.staff.first_name} ${shift.staff.last_name}`;
        document.getElementById('editShiftStaffInput').value = staffName;
        document.getElementById('editShiftStaff').value = shift.staff_id;
    } else {
        document.getElementById('editShiftStaffInput').value = '';
        document.getElementById('editShiftStaff').value = '';
    }
    
    // Set participant selection
    if (shift.participant) {
        const participantName = `${shift.participant.first_name} ${shift.participant.last_name}`;
        document.getElementById('editShiftParticipantInput').value = participantName;
        document.getElementById('editShiftParticipant').value = shift.participant_id;
    } else {
        document.getElementById('editShiftParticipantInput').value = '';
        document.getElementById('editShiftParticipant').value = '';
    }
    
    document.getElementById('editShiftLocation').value = shift.location_id || '';
    document.getElementById('editShiftDutyType').value = shift.duty_type_id || '';
    
    // Handle pay rate override - ensure the select has the value as an option
    const payRateSelect = document.getElementById('editShiftPayRate');
    if (payRateSelect) {
        // First, ensure the option exists
        if (shift.pay_override_id) {
            // Check if the option already exists
            let optionExists = false;
            for (let i = 0; i < payRateSelect.options.length; i++) {
                if (payRateSelect.options[i].value === shift.pay_override_id) {
                    optionExists = true;
                    break;
                }
            }
            
            // If the option doesn't exist, add it
            if (!optionExists && shift.pay_override) {
                const option = document.createElement('option');
                option.value = shift.pay_override_id;
                option.text = `Custom Rate - $${shift.pay_override.hourly_pay_rate || shift.pay_override.base_rate || 0}/hr`;
                payRateSelect.appendChild(option);
            }
            
            // Now set the value
            payRateSelect.value = shift.pay_override_id;
        } else {
            // No override, use empty value (Staff Default)
            payRateSelect.value = '';
        }
    }
    
    document.getElementById('editShiftStatus').value = shift.status || 'scheduled';
    document.getElementById('editShiftNotes').value = shift.notes || '';

    document.getElementById('editShiftModal').style.display = 'flex';
}
        
        function deleteShiftConfirm() {
            const shiftId = parseInt(document.getElementById('editShiftId').value);
            
            if (!confirm('Are you sure you want to delete this shift? This action cannot be undone.')) {
                return;
            }

            deleteShift(shiftId);
        }

        async function deleteShift(shiftId) {
    try {
        // Get the shift data before deletion for undo
        const shiftToDelete = shifts.find(s => s.id === shiftId);
        if (shiftToDelete) {
            // Save to undo stack
            UndoRedoManager.saveState('delete_shift', {
                id: parseInt(shiftId),
                shiftData: { ...shiftToDelete }
            });
        }
        
        // Soft delete - only use deleted_at (not deleted_by since it doesn't exist)
        const { error } = await supabaseClient
            .from('shifts')
            .update({ 
                deleted_at: new Date().toISOString()
            })
            .eq('id', shiftId);
        
        if (error) throw error;
        
        showNotification('Shift deleted successfully', 'success');
        
        // Close modal if open
        const modal = document.getElementById('editShiftModal');
        if (modal && modal.style.display !== 'none') {
            closeModal('editShiftModal');
        }
        
        await loadShifts();
        
        // Refresh conflicts view if it's active
        if (currentView === 'conflicts') {
            await renderConflicts();
        } else {
            renderCurrentView();
        }
        
    } catch (error) {
        console.error('Error deleting shift:', error);
        showNotification('Failed to delete shift', 'error');
    }
}

function deleteShiftConfirm() {
    const shiftId = parseInt(document.getElementById('editShiftId').value);
    
    if (!shiftId) {
        showNotification('No shift selected for deletion', 'error');
        return;
    }
    
    if (!confirm('Are you sure you want to delete this shift? This action cannot be undone.')) {
        return;
    }

    deleteShift(shiftId);
}

        function updateTimeFields() {
            const dutyTypeSelect = document.getElementById('shiftDutyType');
            const startTimeInput = document.getElementById('shiftStartTime');
            const endTimeInput = document.getElementById('shiftEndTime');
            
            if (!dutyTypeSelect || !startTimeInput || !endTimeInput) return;
            
            const selectedDutyType = dutyTypes.find(d => d.id === dutyTypeSelect.value);
            
            if (selectedDutyType && selectedDutyType.name.toLowerCase().includes('sleepover')) {
                startTimeInput.required = false;
                endTimeInput.required = false;
                startTimeInput.placeholder = "Optional for sleepovers";
                endTimeInput.placeholder = "Optional for sleepovers";
            } else {
                startTimeInput.required = true;
                endTimeInput.required = true;
                startTimeInput.placeholder = "";
                endTimeInput.placeholder = "";
            }
        }

        function updateEditTimeFields() {
            const dutyTypeSelect = document.getElementById('editShiftDutyType');
            const startTimeInput = document.getElementById('editShiftStartTime');
            const endTimeInput = document.getElementById('editShiftEndTime');
            
            if (!dutyTypeSelect || !startTimeInput || !endTimeInput) return;
            
            const selectedDutyType = dutyTypes.find(d => d.id === dutyTypeSelect.value);
            
            if (selectedDutyType && selectedDutyType.name.toLowerCase().includes('sleepover')) {
                startTimeInput.required = false;
                endTimeInput.required = false;
                startTimeInput.placeholder = "Optional for sleepovers";
                endTimeInput.placeholder = "Optional for sleepovers";
            } else {
                startTimeInput.required = true;
                endTimeInput.required = true;
                startTimeInput.placeholder = "";
                endTimeInput.placeholder = "";
            }
        }

        function updateHourWarning() {
            const staffId = document.getElementById('shiftStaff').value;
            const warningDiv = document.getElementById('hourWarningText');
            
            if (!staffId || !warningDiv) {
                if (warningDiv) warningDiv.style.display = 'none';
                return;
            }
            
            const selectedStaff = staff.find(s => s.id === staffId);
            if (!selectedStaff || selectedStaff.limits === undefined || selectedStaff.limits === null) {
                warningDiv.style.display = 'none';
                return;
            }

            // Calculate current week hours
            const weekStart = getWeekStart(new Date());
            const weekEnd = new Date(weekStart);
            weekEnd.setDate(weekEnd.getDate() + 6);
            
            const weekShifts = shifts.filter(shift => 
                shift.staff_id === selectedStaff.id &&
                shift.date >= weekStart.toISOString().split('T')[0] &&
                shift.date <= weekEnd.toISOString().split('T')[0]
            );
            
            const currentWeekHours = weekShifts.reduce((total, shift) => 
                total + (shift.calculated_hours?.total || 0), 0
            );
            
            const hourLimit = parseFloat(selectedStaff.limits);
            const remaining = hourLimit - currentWeekHours;
            
            if (remaining <= 10) {
                warningDiv.style.display = 'block';
                warningDiv.innerHTML = `WARNING: ${selectedStaff.first_name} has ${remaining.toFixed(1)}h remaining this week (${currentWeekHours.toFixed(1)}h/${hourLimit}h)`;
            } else {
                warningDiv.style.display = 'none';
            }
        }

        function validateSleepoverRules(shifts, newShift) {
    const violations = [];
    
    // If new shift is a sleepover
    if (newShift.duty_type?.toLowerCase().includes('sleepover')) {
        shifts.forEach(existing => {
            if (existing.start_time) {
                const startHour = parseInt(existing.start_time.split(':')[0]);
                const endHour = parseInt(existing.end_time?.split(':')[0]) || 0;
                
                // Check for late night shifts (10pm onwards)
                if (startHour >= 22 || startHour < 6) {
                    violations.push({
                        type: 'sleepover_conflict',
                        message: `Cannot have sleepover with late night shift (${existing.start_time} - ${existing.end_time})`,
                        shift: existing
                    });
                }
                
                // Check for early morning shifts (12am-6am)
                if (endHour > 0 && endHour <= 6) {
                    violations.push({
                        type: 'sleepover_conflict', 
                        message: `Cannot have sleepover with early morning shift ending at ${existing.end_time}`,
                        shift: existing
                    });
                }
            }
        });
    }
    
    // If new shift is active and there's a sleepover
    const hasSleepover = shifts.some(s => s.duty_type?.toLowerCase().includes('sleepover'));
    if (hasSleepover && newShift.start_time) {
        const startHour = parseInt(newShift.start_time.split(':')[0]);
        const endHour = parseInt(newShift.end_time?.split(':')[0]) || 0;
        
        if (startHour >= 22 || startHour < 6 || (endHour > 0 && endHour <= 6)) {
            violations.push({
                type: 'sleepover_conflict',
                message: 'Cannot roster 10pm-6am shifts when staff has sleepover',
                shift: null
            });
        }
    }
    
    return violations;
}

// Comprehensive overlap check
async function checkShiftConflicts(staffId, participantId, date, startTime, endTime, dutyType, excludeShiftId = null) {
    const conflicts = {
        overlaps: [],
        violations: [],
        warnings: [],
        participantOverlaps: []
    };
    
    try {
        // 1. Check staff availability/leave
        const { data: leaveData } = await supabaseClient
            .from('staff_availability')
            .select('*')
            .eq('staff_id', staffId)
            .eq('date', date)
            .eq('available', false)
            .single();
        
        if (leaveData) {
            conflicts.violations.push({
                type: 'on_leave',
                message: `Staff is on leave on ${formatDateFriendly(date)}`,
                blocking: true
            });
        }
        
        // 2. Get all shifts for this staff on this date
        let staffQuery = supabaseClient
            .from('shifts')
            .select('*, duty_type:duty_type_id(name)')
            .eq('staff_id', staffId)
            .eq('date', date)
            .is('deleted_at', null);
        
        if (excludeShiftId) {
            staffQuery = staffQuery.neq('id', excludeShiftId);
        }
        
        const { data: staffShifts } = await staffQuery;
        
        // 3. Check time overlaps for active shifts
        if (startTime && endTime && staffShifts) {
            const newStart = new Date(`2000-01-01T${startTime}`);
            const newEnd = new Date(`2000-01-01T${endTime}`);
            if (newEnd <= newStart) newEnd.setDate(newEnd.getDate() + 1);
            
            staffShifts.forEach(shift => {
                if (shift.start_time && shift.end_time) {
                    const existingStart = new Date(`2000-01-01T${shift.start_time}`);
                    const existingEnd = new Date(`2000-01-01T${shift.end_time}`);
                    if (existingEnd <= existingStart) existingEnd.setDate(existingEnd.getDate() + 1);
                    
                    // Check for overlap
                    if (!(newEnd <= existingStart || newStart >= existingEnd)) {
                        // Calculate overlap period
                        const overlapStart = new Date(Math.max(newStart, existingStart));
                        const overlapEnd = new Date(Math.min(newEnd, existingEnd));
                        
                        conflicts.overlaps.push({
                            type: 'time_overlap',
                            message: `Overlaps with shift ${formatTime12Hour(shift.start_time)}-${formatTime12Hour(shift.end_time)}`,
                            overlapPeriod: `${overlapStart.toTimeString().slice(0,5)}-${overlapEnd.toTimeString().slice(0,5)}`,
                            shift: shift,
                            blocking: true
                        });
                    }
                }
            });
        }
        
        // 4. Check sleepover business rules
        const sleepoverViolations = validateSleepoverRules(staffShifts || [], {
            start_time: startTime,
            end_time: endTime,
            duty_type: dutyType
        });
        
        conflicts.violations.push(...sleepoverViolations);
        
        // 5. Check participant overlaps (for information only)
        if (participantId && startTime && endTime) {
            const { data: participantShifts } = await supabaseClient
                .from('shifts')
                .select('*, staff:staff_id(first_name, last_name)')
                .eq('participant_id', participantId)
                .eq('date', date)
                .is('deleted_at', null)
                .neq('id', excludeShiftId || '00000000-0000-0000-0000-000000000000');
            
            if (participantShifts) {
                const overlappingStaff = [];
                
                participantShifts.forEach(shift => {
                    if (shift.start_time && shift.end_time) {
                        const existingStart = new Date(`2000-01-01T${shift.start_time}`);
                        const existingEnd = new Date(`2000-01-01T${shift.end_time}`);
                        const newStart = new Date(`2000-01-01T${startTime}`);
                        const newEnd = new Date(`2000-01-01T${endTime}`);
                        
                        if (existingEnd <= existingStart) existingEnd.setDate(existingEnd.getDate() + 1);
                        if (newEnd <= newStart) newEnd.setDate(newEnd.getDate() + 1);
                        
                        if (!(newEnd <= existingStart || newStart >= existingEnd)) {
                            overlappingStaff.push({
                                staff: shift.staff,
                                time: `${formatTime12Hour(shift.start_time)}-${formatTime12Hour(shift.end_time)}`
                            });
                        }
                    }
                });
                
                if (overlappingStaff.length > 0) {
                    conflicts.participantOverlaps = {
                        count: overlappingStaff.length + 1, // +1 for the new shift
                        ratio: `${overlappingStaff.length + 1}:1`,
                        staff: overlappingStaff,
                        message: `Participant will have ${overlappingStaff.length + 1} staff during this time`
                    };
                }
            }
        }
        
    } catch (error) {
        console.error('Error checking conflicts:', error);
    }
    
    return conflicts;
}
        // ========================================
        // SUMMARY AND TIMESHEET RENDERING - FIXED
        // ========================================

        function renderSummary() {
    const summaryGrid = document.getElementById('summaryGrid');
    if (!summaryGrid) return;
    
    console.log('Rendering summary with', filteredShifts.length, 'shifts');
    
    // Staff summary with proper calculations
    const staffSummary = staff.map(s => {
        const staffShifts = filteredShifts.filter(shift => shift.staff_id === s.id);
        
        if (staffShifts.length === 0) return null;
        
        const totals = staffShifts.reduce((acc, shift) => {
            const hours = shift.calculated_hours || {};
            const pay = shift.calculated_pay || 0;
            
            acc.total += hours.total || 0;
            acc.weekdayDay += hours.weekdayDay || 0;
            acc.weekdayEvening += hours.weekdayEvening || 0;
            acc.weekdayNight += hours.weekdayNight || 0;
            acc.saturday += hours.saturday || 0;
            acc.sunday += hours.sunday || 0;
            acc.publicHoliday += hours.publicHoliday || 0;
            acc.sleepover += hours.sleepover || 0;
            acc.pay += pay;
            
            // Count sleepovers
            if (hours.sleepover > 0) {
                acc.sleepoverCount++;
            }
            
            return acc;
        }, {
            total: 0, weekdayDay: 0, weekdayEvening: 0, weekdayNight: 0,
            saturday: 0, sunday: 0, publicHoliday: 0, sleepover: 0, pay: 0, sleepoverCount: 0
        });

        const hourLimit = parseFloat(s.limits) || 76;
        const overLimit = totals.total > hourLimit;

        return {
            name: `${s.first_name} ${s.last_name}`,
            shifts: staffShifts.length,
            hourLimit: hourLimit,
            overLimit: overLimit,
            deductedHours: Math.max(0, totals.total - hourLimit),
            ...totals
        };
    }).filter(Boolean);

    // Participant summary
    const participantSummary = participants.map(p => {
        const participantShifts = filteredShifts.filter(shift => shift.participant_id === p.id);
        if (participantShifts.length === 0) return null;
        
        const totals = participantShifts.reduce((acc, shift) => {
            acc.hours += shift.calculated_hours?.total || 0;
            acc.pay += shift.calculated_pay || 0;
            if (shift.calculated_hours?.sleepover > 0) acc.sleepovers++;
            return acc;
        }, { hours: 0, pay: 0, sleepovers: 0 });
        
        const uniqueStaff = new Set(participantShifts.map(shift => shift.staff_id)).size;

        return {
            name: `${p.first_name} ${p.last_name}`,
            shifts: participantShifts.length,
            hours: totals.hours,
            pay: totals.pay,
            sleepovers: totals.sleepovers,
            staffCount: uniqueStaff
        };
    }).filter(Boolean);

    summaryGrid.innerHTML = `
        <div class="summary-card">
            <h3>Staff Summary (${staffSummary.length} with shifts)</h3>
            ${staffSummary.map(s => `
                <div class="summary-item" style="flex-direction: column; align-items: flex-start;">
                    <div style="display: flex; justify-content: space-between; width: 100%; font-weight: 600;">
                        <span>${s.name}</span>
                        <span>${s.shifts} shifts • ${formatHours(s.total)}h • $${s.pay.toFixed(2)}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; width: 100%; margin-top: 4px;">
                        <span style="font-size: var(--font-size-xs); color: var(--text-muted);">
                            Limit: ${s.hourLimit}h ${s.overLimit ? '(EXCEEDED)' : ''}
                        </span>
                        ${s.overLimit ? `<span style="font-size: var(--font-size-xs); color: var(--danger-color);">Deducted: ${formatHours(s.deductedHours)}h</span>` : ''}
                    </div>
                    <div class="summary-item-details">
                        ${s.weekdayDay > 0 ? `Day: ${formatHours(s.weekdayDay)}h` : ''}
                        ${s.weekdayEvening > 0 ? ` • Eve: ${formatHours(s.weekdayEvening)}h` : ''}
                        ${s.weekdayNight > 0 ? ` • Night: ${formatHours(s.weekdayNight)}h` : ''}
                        ${s.saturday > 0 ? ` • Sat: ${formatHours(s.saturday)}h` : ''}
                        ${s.sunday > 0 ? ` • Sun: ${formatHours(s.sunday)}h` : ''}
                        ${s.publicHoliday > 0 ? ` • Holiday: ${formatHours(s.publicHoliday)}h` : ''}
                        ${s.sleepoverCount > 0 ? ` • Sleepovers: ${s.sleepoverCount}` : ''}
                    </div>
                </div>
            `).join('')}
        </div>
        <div class="summary-card">
            <h3>Participant Summary (${participantSummary.length} with shifts)</h3>
            ${participantSummary.map(p => `
                <div class="summary-item" style="flex-direction: column; align-items: flex-start;">
                    <div style="display: flex; justify-content: space-between; width: 100%; font-weight: 500;">
                        <span>${p.name}</span>
                        <span>${p.shifts} shifts • ${formatHours(p.hours)}h • $${p.pay.toFixed(2)}</span>
                    </div>
                    <div class="summary-item-details">
                        ${p.sleepovers > 0 ? `${p.sleepovers} sleepovers • ` : ''}
                        ${p.staffCount} staff assigned
                    </div>
                </div>
            `).join('')}
        </div>
    `;
}
        

function renderTimesheet() {
    const timesheetContent = document.getElementById('timesheetContent');
    if (!timesheetContent) return;
    
    console.log('Rendering timesheet...');
    
    // Group by staff
    const staffGroups = {};
    filteredShifts.forEach(shift => {
        const staffId = shift.staff_id;
        if (!staffGroups[staffId]) {
            staffGroups[staffId] = {
                staff: shift.staff,
                shifts: [],
                totalHours: { 
                    total: 0, weekdayDay: 0, weekdayEvening: 0, weekdayNight: 0, 
                    saturday: 0, sunday: 0, publicHoliday: 0, sleepover: 0,
                    overtime: 0 // Added overtime tracking
                },
                totalPay: 0,
                sleepoverCount: 0,
                weeklyHours: 0 // Track weekly hours for overtime calculation
            };
        }
        staffGroups[staffId].shifts.push(shift);
    });

    // Calculate totals for each staff member
    Object.values(staffGroups).forEach(group => {
        // First pass: calculate base hours
        group.shifts.forEach(shift => {
            const hours = shift.calculated_hours || {};
            const pay = shift.calculated_pay || 0;
            
            // Sum all hour categories
            Object.keys(hours).forEach(category => {
                if (group.totalHours[category] !== undefined) {
                    group.totalHours[category] += hours[category] || 0;
                }
            });
            
            // Count sleepovers (not hours)
            if (hours.sleepover > 0) {
                group.sleepoverCount++;
            }
            
            // Track public holiday hours - check the shift's is_public_holiday field
            if (shift.is_public_holiday === true) {
                group.totalHours.publicHoliday += hours.total || 0;
            }
            
            group.totalPay += pay;
        });
        
        // Calculate overtime (hours over 38 per week for full-time/part-time)
        const staff = group.staff;
        const payCategory = staff?.pay_category || 'casual';
        
        if (payCategory.toLowerCase().includes('full') || payCategory.toLowerCase().includes('part')) {
            // Only calculate overtime for full-time and part-time staff
            const standardWeeklyHours = 38;
            if (group.totalHours.total > standardWeeklyHours) {
                group.totalHours.overtime = group.totalHours.total - standardWeeklyHours;
            }
        }
        
        // Apply hour limits
        if (staff && staff.limits !== undefined && staff.limits !== null) {
            const hourLimit = parseFloat(staff.limits);
            group.overLimit = group.totalHours.total > hourLimit;
            group.hourLimit = hourLimit;
            group.finalHours = Math.min(group.totalHours.total, hourLimit);
            group.deductedHours = Math.max(0, group.totalHours.total - hourLimit);
        } else {
            group.overLimit = false;
            group.hourLimit = 76; // Default
            group.finalHours = group.totalHours.total;
            group.deductedHours = 0;
        }
        
        // Get pay rate label
        if (staff && staff.pay_rate_id) {
            group.payRateLabel = payRateLabels.get(staff.pay_rate_id) || 'Standard Rate';
        } else {
            group.payRateLabel = 'Standard Rate';
        }
    });

    // Calculate grand totals for footer
    let grandTotalHours = 0;
    let grandTotalPay = 0;
    let grandTotalOvertime = 0;
    let grandTotalPublicHoliday = 0;
    
    Object.values(staffGroups).forEach(group => {
        grandTotalHours += group.totalHours.total;
        grandTotalPay += group.totalPay;
        grandTotalOvertime += group.totalHours.overtime || 0;
        grandTotalPublicHoliday += group.totalHours.publicHoliday || 0;
    });

    let html = `
        <style>
            .timesheet-wrapper {
                background: white;
                border-radius: var(--radius-lg);
                overflow: hidden;
                box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            }
            
            .timesheet-table { 
                width: 100%; 
                border-collapse: separate;
                border-spacing: 0;
                background: white;
            }
            
            .timesheet-table thead {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            }
            
            .timesheet-table th { 
                padding: 16px 12px; 
                text-align: left; 
                font-weight: 600; 
                font-size: 11px; 
                text-transform: uppercase;
                letter-spacing: 1px;
                color: white;
                border: none;
            }
            
            .timesheet-table tfoot {
                background: #f8f9fa;
                border-top: 2px solid #dee2e6;
            }
            
            .timesheet-table tfoot td {
                padding: 16px 12px;
                font-weight: 700;
                color: var(--text-primary);
                font-size: 14px;
            }
            
            .timesheet-row { 
                cursor: pointer; 
                transition: all 0.2s ease;
                background: white;
                position: relative;
            }
            
            .timesheet-row:hover { 
                background: #f8f9fa;
                transform: translateX(2px);
            }
            
            .timesheet-row td { 
                padding: 16px 12px; 
                border-bottom: 1px solid #e9ecef; 
                font-size: 14px;
                vertical-align: middle;
            }
            
            .timesheet-row:hover td:first-child {
                border-left: 3px solid var(--primary-color);
                padding-left: 9px;
            }
            
            .accordion-content { 
                display: none; 
                background: #f8f9fa;
            }
            
            .accordion-content.active { 
                display: table-row;
                animation: slideDown 0.3s ease;
            }
            
            @keyframes slideDown {
                from {
                    opacity: 0;
                    transform: translateY(-10px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
            
            .accordion-arrow { 
                display: inline-block; 
                margin-right: 10px; 
                transition: transform 0.3s ease; 
                font-size: 12px;
                color: var(--primary-color);
                font-weight: bold;
            }
            
            .accordion-arrow.open { 
                transform: rotate(90deg); 
            }
            
            .staff-name {
                font-weight: 600;
                color: var(--text-primary);
                font-size: 15px;
            }
            
            .pay-rate-badge {
                display: inline-block;
                background: linear-gradient(135deg, #667eea, #764ba2);
                color: white;
                padding: 5px 12px;
                border-radius: 20px;
                font-size: 11px;
                font-weight: 500;
                letter-spacing: 0.5px;
            }
            
            .hours-display {
                font-weight: 500;
                font-size: 14px;
            }
            
            .hours-limit {
                color: var(--text-muted);
                font-weight: normal;
            }
            
            .hour-exceeded { 
                color: #e74c3c !important; 
                font-weight: 600; 
            }
            
            .exceeded-badge {
                display: inline-block;
                background: #e74c3c;
                color: white;
                padding: 2px 6px;
                border-radius: 4px;
                font-size: 10px;
                margin-left: 8px;
                font-weight: 600;
                animation: pulse 2s infinite;
            }
            
            @keyframes pulse {
                0%, 100% { opacity: 1; }
                50% { opacity: 0.7; }
            }
            
            .sleepover-badge {
                display: inline-block;
                background: #f39c12;
                color: white;
                padding: 6px 12px;
                border-radius: 20px;
                font-weight: 600;
                font-size: 13px;
            }
            
            .overtime-badge {
                display: inline-block;
                background: #e67e22;
                color: white;
                padding: 6px 12px;
                border-radius: 20px;
                font-weight: 600;
                font-size: 13px;
                margin-left: 6px;
            }
            
            .hour-breakdown-cell {
                font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
                font-size: 12px;
                line-height: 1.8;
                color: var(--text-secondary);
                background: #f8f9fa;
                padding: 8px 12px !important;
                border-radius: 6px;
            }
            
            .hour-breakdown-item {
                display: inline-block;
                padding: 3px 8px;
                background: white;
                border-radius: 4px;
                margin-right: 8px;
                margin-bottom: 4px;
                border: 1px solid #e9ecef;
            }
            
            .hour-breakdown-item.overtime {
                background: #fff4e4;
                border-color: #ffd6a5;
                color: #e67e22;
                font-weight: 600;
            }
            
            .hour-breakdown-item.public-holiday {
                background: #e3f2fd;
                border-color: #90caf9;
                color: #1976d2;
                font-weight: 600;
            }
            
            .final-hours {
                font-weight: 600;
                font-size: 15px;
                color: var(--text-primary);
            }
            
            .deducted { 
                color: #e67e22; 
                font-size: 11px;
                font-weight: 500;
                display: block;
                margin-top: 4px;
            }
            
            .total-pay {
                font-weight: 700;
                font-size: 16px;
                color: #27ae60;
            }
            
            .shifts-detail-container {
                padding: 24px;
                background: white;
                margin: 16px;
                border-radius: 8px;
                box-shadow: 0 1px 4px rgba(0,0,0,0.08);
            }
            
            .shifts-detail-header {
                margin-bottom: 16px;
                color: var(--text-secondary);
                font-size: 13px;
                font-weight: 600;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .shifts-detail-table { 
                width: 100%;
                font-size: 13px;
                border-collapse: separate;
                border-spacing: 0;
                overflow: hidden;
                border-radius: 6px;
                border: 1px solid #e9ecef;
            }
            
            .shifts-detail-table th { 
                background: #f8f9fa;
                padding: 10px 12px; 
                text-align: left;
                font-weight: 600;
                font-size: 11px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                color: var(--text-secondary);
                border-bottom: 1px solid #e9ecef;
            }
            
            .shifts-detail-table td { 
                padding: 12px; 
                border-bottom: 1px solid #f1f3f4;
                background: white;
            }
            
            .shifts-detail-table tbody tr:hover {
                background: #f8f9fa;
            }
            
            .shifts-detail-table tbody tr:last-child td {
                border-bottom: none;
            }
            
            .status-badge {
                padding: 4px 10px;
                border-radius: 12px;
                font-size: 11px;
                font-weight: 600;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .status-confirmed {
                background: #d4edda;
                color: #155724;
            }
            
            .status-pending {
                background: #fff3cd;
                color: #856404;
            }
            
            .status-completed {
                background: #cce5ff;
                color: #004085;
            }
            
            .public-holiday-indicator {
                display: inline-block;
                background: #1976d2;
                color: white;
                padding: 2px 6px;
                border-radius: 4px;
                font-size: 10px;
                margin-left: 6px;
                font-weight: 600;
                text-transform: uppercase;
            }
        </style>
        
        <div class="timesheet-wrapper">
            <table class="timesheet-table">
                <thead>
                    <tr>
                        <th style="width: 20%;">Staff Member</th>
                        <th style="width: 15%;">Pay Rate</th>
                        <th style="width: 12%;">Hours / Limit</th>
                        <th style="width: 8%; text-align: center;">Sleepovers</th>
                        <th style="width: 30%;">Hour Breakdown</th>
                        <th style="width: 10%;">Final Hours</th>
                        <th style="width: 10%; text-align: right;">Total Pay</th>
                    </tr>
                </thead>
                <tbody>
    `;

    // Add each staff member's row and accordion content
    let accordionIndex = 0;
    Object.values(staffGroups).forEach(group => {
        const staff = group.staff || { first_name: 'Unknown', last_name: 'Staff' };
        const staffName = `${staff.first_name} ${staff.last_name}`;
        
        // Build hour breakdown with styled items
        const hourBreakdown = [];
        if (group.totalHours.weekdayDay > 0) 
            hourBreakdown.push(`<span class="hour-breakdown-item">Day: ${formatHours(group.totalHours.weekdayDay)}h</span>`);
        if (group.totalHours.weekdayEvening > 0) 
            hourBreakdown.push(`<span class="hour-breakdown-item">Eve: ${formatHours(group.totalHours.weekdayEvening)}h</span>`);
        if (group.totalHours.weekdayNight > 0) 
            hourBreakdown.push(`<span class="hour-breakdown-item">Night: ${formatHours(group.totalHours.weekdayNight)}h</span>`);
        if (group.totalHours.saturday > 0) 
            hourBreakdown.push(`<span class="hour-breakdown-item">Sat: ${formatHours(group.totalHours.saturday)}h</span>`);
        if (group.totalHours.sunday > 0) 
            hourBreakdown.push(`<span class="hour-breakdown-item">Sun: ${formatHours(group.totalHours.sunday)}h</span>`);
        if (group.totalHours.publicHoliday > 0) 
            hourBreakdown.push(`<span class="hour-breakdown-item public-holiday">PH: ${formatHours(group.totalHours.publicHoliday)}h</span>`);
        if (group.totalHours.overtime > 0) 
            hourBreakdown.push(`<span class="hour-breakdown-item overtime">OT: ${formatHours(group.totalHours.overtime)}h</span>`);
        
        const hourBreakdownStr = hourBreakdown.join('') || '<span style="color: #aaa;">—</span>';
        
        // Main row
        html += `
            <tr class="timesheet-row" onclick="toggleAccordion(${accordionIndex})">
                <td>
                    <span class="accordion-arrow" id="arrow-${accordionIndex}">▶</span>
                    <span class="staff-name">${staffName}</span>
                </td>
                <td>
                    <span class="pay-rate-badge">${group.payRateLabel}</span>
                </td>
                <td>
                    <span class="hours-display ${group.overLimit ? 'hour-exceeded' : ''}">
                        ${formatHours(group.totalHours.total)}h 
                        <span class="hours-limit">/ ${group.hourLimit}h</span>
                        ${group.overLimit ? '<span class="exceeded-badge">EXCEEDED</span>' : ''}
                    </span>
                </td>
                <td style="text-align: center;">
                    ${group.sleepoverCount > 0 ? 
                        `<span class="sleepover-badge">${group.sleepoverCount}</span>` : 
                        '<span style="color: #ccc;">—</span>'}
                </td>
                <td class="hour-breakdown-cell">${hourBreakdownStr}</td>
                <td>
                    <span class="final-hours">${formatHours(group.finalHours)}h</span>
                    ${group.deductedHours > 0 ? 
                        `<span class="deducted">−${formatHours(group.deductedHours)}h deducted</span>` : ''}
                    ${group.totalHours.overtime > 0 ? 
                        `<span class="overtime-badge" title="Overtime hours">+${formatHours(group.totalHours.overtime)}h OT</span>` : ''}
                </td>
                <td style="text-align: right;">
                    <span class="total-pay">$${group.totalPay.toFixed(2)}</span>
                </td>
            </tr>
            <tr class="accordion-content" id="accordion-${accordionIndex}">
                <td colspan="7" style="padding: 0; background: #f8f9fa;">
                    <div class="shifts-detail-container">
                        <h4 class="shifts-detail-header">Individual Shifts (${group.shifts.length})</h4>
                        <table class="shifts-detail-table">
                            <thead>
                                <tr>
                                    <th>Date</th>
                                    <th>Time</th>
                                    <th>Participant</th>
                                    <th>Hours</th>
                                    <th>Type</th>
                                    <th>Pay</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody>
        `;
        
        // Sort shifts by date
        group.shifts.sort((a, b) => new Date(a.date) - new Date(b.date));
        
        // Add individual shifts
        group.shifts.forEach(shift => {
            const participant = shift.participant || {};
            const participantName = participant.first_name ? 
                `${participant.first_name} ${participant.last_name}` : 
                (shift.location?.name || 'Unassigned');
            
            const timeDisplay = shift.start_time && shift.end_time ? 
                `${formatTime12Hour(shift.start_time)} - ${formatTime12Hour(shift.end_time)}` : 
                'Sleepover';
            
            const shiftHours = shift.calculated_hours?.total || 0;
            const shiftPay = shift.calculated_pay || 0;
            const dutyType = dutyTypes.find(d => d.id === shift.duty_type_id);
            
            html += `
                <tr>
                    <td>
                        <strong>${formatDateFriendly(shift.date)}</strong>
                        ${shift.is_public_holiday === true ? '<span class="public-holiday-indicator">PH</span>' : ''}
                    </td>
                    <td>${timeDisplay}</td>
                    <td>${participantName}</td>
                    <td>${formatHours(shiftHours)}h</td>
                    <td>${dutyType?.name || 'Standard'}</td>
                    <td style="font-weight: 600; color: #27ae60;">$${shiftPay.toFixed(2)}</td>
                    <td><span class="status-badge status-${shift.status || 'pending'}">${shift.status || 'pending'}</span></td>
                </tr>
            `;
        });
        
        html += `
                            </tbody>
                        </table>
                    </div>
                </td>
            </tr>
        `;
        
        accordionIndex++;
    });

    // Add footer with totals
    html += `
                </tbody>
                <tfoot>
                    <tr>
                        <td colspan="2"><strong>TOTALS</strong></td>
                        <td><strong>${formatHours(grandTotalHours)}h</strong></td>
                        <td style="text-align: center;">—</td>
                        <td>
                            ${grandTotalOvertime > 0 ? `<span class="hour-breakdown-item overtime">OT: ${formatHours(grandTotalOvertime)}h</span>` : ''}
                            ${grandTotalPublicHoliday > 0 ? `<span class="hour-breakdown-item public-holiday">PH: ${formatHours(grandTotalPublicHoliday)}h</span>` : ''}
                        </td>
                        <td>—</td>
                        <td style="text-align: right;"><strong style="color: #27ae60;">$${grandTotalPay.toFixed(2)}</strong></td>
                    </tr>
                </tfoot>
            </table>
        </div>
    `;

    timesheetContent.innerHTML = html || '<div class="loading">No timesheet data available</div>';
}
// Add accordion toggle function to window scope
window.toggleAccordion = function(index) {
    // Close all other accordions
    document.querySelectorAll('.accordion-content').forEach((content, i) => {
        if (i !== index) {
            content.classList.remove('active');
            const arrow = document.getElementById(`arrow-${i}`);
            if (arrow) arrow.classList.remove('open');
        }
    });
    
    // Toggle current accordion
    const content = document.getElementById(`accordion-${index}`);
    const arrow = document.getElementById(`arrow-${index}`);
    
    if (content && arrow) {
        content.classList.toggle('active');
        arrow.classList.toggle('open');
    }
};

        // ========================================
        // NOTES MANAGEMENT - FIXED
        // ========================================

        async function renderNotes() {
    try {
        const notesContent = document.getElementById('notesContent');
        if (!notesContent) return;
        
        // Fixed query - just get the notes without joins
        const { data: notesData, error } = await supabaseClient
            .from('shift_notes')
            .select('*')
            .order('created_at', { ascending: false })
            .limit(50);
        
        if (error) throw error;
        
        // Manually enrich with related data
        const enrichedNotes = [];
        if (notesData) {
            for (const note of notesData) {
                const shift = shifts.find(s => s.id === note.shift_id) || {};
                const noteStaff = staff.find(s => s.id === note.staff_id) || {};
                const participant = shift.participant_id ? 
                    participants.find(p => p.id === shift.participant_id) : null;
                
                enrichedNotes.push({
                    ...note,
                    shift: shift,
                    staff: noteStaff,
                    participant: participant
                });
            }
        }
        
        let html = `
            <style>
                .notes-wrapper {
                    background: white;
                    border-radius: var(--radius-lg);
                    overflow: hidden;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
                }
                
                .note-item {
                    padding: 20px;
                    border-bottom: 1px solid #e9ecef;
                    transition: all 0.2s;
                }
                
                .note-item:hover {
                    background: #f8f9fa;
                }
                
                .note-header {
                    display: flex;
                    justify-content: space-between;
                    align-items: start;
                    margin-bottom: 12px;
                }
                
                .note-type-badge {
                    display: inline-block;
                    padding: 4px 10px;
                    border-radius: 12px;
                    font-size: 11px;
                    font-weight: 600;
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                    margin-right: 8px;
                }
                
                .note-type-shift {
                    background: #cce5ff;
                    color: #004085;
                }
                
                .note-type-handover {
                    background: #fff3cd;
                    color: #856404;
                }
                
                .note-type-incident {
                    background: #f8d7da;
                    color: #721c24;
                }
                
                .note-content {
                    background: #f8f9fa;
                    padding: 16px;
                    border-radius: 8px;
                    margin: 12px 0;
                    line-height: 1.6;
                    color: var(--text-secondary);
                }
                
                .note-meta {
                    font-size: 12px;
                    color: var(--text-muted);
                    display: flex;
                    gap: 16px;
                }
            </style>
            
            <div class="notes-wrapper">
        `;
        
        if (enrichedNotes && enrichedNotes.length > 0) {
            enrichedNotes.forEach(note => {
                html += `
                    <div class="note-item">
                        <div class="note-header">
                            <div>
                                <span class="note-type-badge note-type-${note.note_type || 'shift'}">${note.note_type || 'shift'}</span>
                                <strong>${note.staff?.first_name || 'Unknown'} ${note.staff?.last_name || ''}</strong>
                            </div>
                            <span style="font-size: 12px; color: var(--text-muted);">
                                ${formatDateTime(note.created_at)}
                            </span>
                        </div>
                        <div class="note-content">${note.note}</div>
                        <div class="note-meta">
                            <span>📅 ${note.shift?.date ? formatDateFriendly(note.shift.date) : 'No date'}</span>
                            ${note.shift?.start_time ? `
                                <span>⏰ ${formatTime12Hour(note.shift.start_time)} - ${formatTime12Hour(note.shift.end_time)}</span>
                            ` : ''}
                            ${note.participant ? `
                                <span>👤 ${note.participant.first_name} ${note.participant.last_name}</span>
                            ` : ''}
                        </div>
                    </div>
                `;
            });
        } else {
            html += `
                <div style="text-align: center; padding: 60px 20px; color: var(--text-muted);">
                    <div style="font-size: 48px; margin-bottom: 16px;">📝</div>
                    <h3>No notes found</h3>
                    <p>Shift notes and communications will appear here</p>
                    <button class="btn btn-primary" onclick="showAddNoteModal()" style="margin-top: 16px;">
                        Add First Note
                    </button>
                </div>
            `;
        }
        
        html += '</div>';
        notesContent.innerHTML = html;
        
    } catch (error) {
        console.error('Error loading notes:', error);
        document.getElementById('notesContent').innerHTML = 
            '<div class="error">Failed to load notes: ' + error.message + '</div>';
    }
}
// Enhanced Add Note Modal
function showAddNoteModal() {
    const modal = document.getElementById('addNoteModal');
    if (!modal) {
        // Create modal if it doesn't exist
        const modalHtml = `
            <div id="addNoteModal" class="modal-overlay" style="display: none;">
                <div class="modal">
                    <header class="modal-header">
                        <h3 class="modal-title">Add Shift Note</h3>
                        <button class="modal-close" onclick="closeModal('addNoteModal')">&times;</button>
                    </header>
                    <div class="modal-content">
                        <form id="addNoteForm">
                            <div class="form-group">
                                <label class="form-label">Shift *</label>
                                <select class="form-control" id="noteShift" required>
                                    <option value="">Select Shift</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Note Type *</label>
                                <select class="form-control" id="noteType" required>
                                    <option value="shift">Shift Note (Visible to All)</option>
                                    <option value="handover">Handover Note (Private)</option>
                                    <option value="incident">Incident Report</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Note *</label>
                                <textarea class="form-control" id="noteContent" required 
                                          placeholder="Enter your note..." rows="4"></textarea>
                            </div>
                        </form>
                    </div>
                    <footer class="modal-footer">
                        <div class="modal-actions">
                            <button class="btn btn-outline" onclick="closeModal('addNoteModal')">Cancel</button>
                            <button class="btn btn-primary" onclick="createNote()">Add Note</button>
                        </div>
                    </footer>
                </div>
            </div>
        `;
        document.body.insertAdjacentHTML('beforeend', modalHtml);
    }
    
    // Populate shifts dropdown
    const noteShiftSelect = document.getElementById('noteShift');
    noteShiftSelect.innerHTML = '<option value="">Select Shift</option>';
    
    // Get recent and upcoming shifts for notes
    const relevantShifts = shifts.filter(shift => {
        const shiftDate = new Date(shift.date);
        const today = new Date();
        const daysDiff = Math.abs((shiftDate - today) / (1000 * 60 * 60 * 24));
        return daysDiff <= 30; // Show shifts within 30 days
    });
    
    relevantShifts.forEach(shift => {
        const staff = shift.staff || {};
        const participant = shift.participant || {};
        const shiftLabel = `${formatDateFriendly(shift.date)} - ${staff.first_name} ${staff.last_name} / ${participant.first_name || 'Unassigned'} ${participant.last_name || ''}`;
        noteShiftSelect.innerHTML += `<option value="${shift.id}">${shiftLabel}</option>`;
    });
    
    document.getElementById('addNoteModal').style.display = 'flex';
}

        async function createNote() {
            try {
                const shiftId = parseInt(document.getElementById('noteShift').value); // SERIAL - use parseInt
                const noteType = document.getElementById('noteType').value;
                const noteContent = document.getElementById('noteContent').value;

                if (!shiftId || !noteType || !noteContent?.trim()) {
                    showNotification('Please fill in all fields', 'error');
                    return;
                }

                const { error } = await supabaseClient
                    .from('shift_notes')
                    .insert([{
                        shift_id: parseInt(shiftId),
                        staff_id: currentStaffData?.id || currentUser.id,
                        note_type: noteType,
                        note: noteContent.trim()
                    }]);

                if (error) throw error;

                showNotification('Note added successfully', 'success');
                closeModal('addNoteModal');
                if (currentView === 'notes') renderNotes();

            } catch (error) {
                console.error('Error creating note:', error);
                showNotification('Failed to add note: ' + error.message, 'error');
            }
        }

        function addNoteToShift(shiftId) {
            showAddNoteModal();
            setTimeout(() => {
                document.getElementById('noteShift').value = shiftId;
            }, 100);
        }

        // ========================================
        // PUBLIC HOLIDAYS MANAGEMENT
        // ========================================

        async function loadPublicHolidays() {
            try {
                const storedHolidays = localStorage.getItem('mcm_public_holidays');
                if (storedHolidays) {
                    const holidays = JSON.parse(storedHolidays);
                    Object.keys(holidays).forEach(date => publicHolidays.add(date));
                } else {
                    loadDefaultAustralianHolidays();
                }
                
                console.log('Loaded public holidays:', publicHolidays.size);
                
            } catch (error) {
                console.log('Loading default holidays due to error');
                loadDefaultAustralianHolidays();
            }
        }

        function loadDefaultAustralianHolidays() {
            const currentYear = new Date().getFullYear();
            const defaultHolidays = {
                [`${currentYear}-01-01`]: "New Year's Day",
                [`${currentYear}-01-26`]: "Australia Day", 
                [`${currentYear}-03-29`]: "Good Friday",
                [`${currentYear}-04-01`]: "Easter Monday",
                [`${currentYear}-04-25`]: "ANZAC Day",
                [`${currentYear}-12-25`]: "Christmas Day",
                [`${currentYear}-12-26`]: "Boxing Day"
            };
            
            Object.keys(defaultHolidays).forEach(date => publicHolidays.add(date));
            localStorage.setItem('mcm_public_holidays', JSON.stringify(defaultHolidays));
        }

        function showPublicHolidayModal() {
            document.getElementById('publicHolidayModal').style.display = 'flex';
            populateHolidayList();
        }

        function showAddHolidayForm() {
            document.getElementById('addHolidayForm').style.display = 'block';
        }

        function cancelAddHoliday() {
            document.getElementById('addHolidayForm').style.display = 'none';
            document.getElementById('holidayDate').value = '';
            document.getElementById('holidayName').value = '';
        }

        function addHoliday() {
            const date = document.getElementById('holidayDate').value;
            const name = document.getElementById('holidayName').value;
            
            if (!date || !name) {
                showNotification('Please enter both date and name', 'error');
                return;
            }
            
            publicHolidays.add(date);
            const holidays = JSON.parse(localStorage.getItem('mcm_public_holidays') || '{}');
            holidays[date] = name;
            localStorage.setItem('mcm_public_holidays', JSON.stringify(holidays));
            
            populateHolidayList();
            cancelAddHoliday();
            showNotification('Holiday added successfully', 'success');
            
            // Recalculate all shifts
            if (shifts.length > 0) {
                shifts.forEach(shift => {
                    shift.calculated_hours = calculateShiftHours(shift);
                    shift.calculated_pay = calculateShiftPay(shift, shift.calculated_hours);
                });
                renderCurrentView();
            }
        }

        function populateHolidayList() {
            const holidayList = document.getElementById('holidayList');
            const sortedHolidays = Array.from(publicHolidays).sort();
            const holidayNames = JSON.parse(localStorage.getItem('mcm_public_holidays') || '{}');
            
            if (sortedHolidays.length === 0) {
                holidayList.innerHTML = '<div class="empty-state"><p>No holidays configured</p></div>';
                return;
            }
            
            holidayList.innerHTML = sortedHolidays.map(date => `
                <div class="holiday-item">
                    <span>${formatDate(date)} - ${holidayNames[date] || 'Public Holiday'}</span>
                    <button class="btn btn-danger btn-sm" onclick="removeHoliday('${date}')">Remove</button>
                </div>
            `).join('');
        }

        function removeHoliday(date) {
            publicHolidays.delete(date);
            const holidays = JSON.parse(localStorage.getItem('mcm_public_holidays') || '{}');
            delete holidays[date];
            localStorage.setItem('mcm_public_holidays', JSON.stringify(holidays));
            populateHolidayList();
        }

        function loadAustralianHolidays() {
            loadDefaultAustralianHolidays();
            populateHolidayList();
            showNotification('Australian holidays loaded successfully', 'success');
        }

        // ========================================
        // EXPORT FUNCTIONS - FIXED
        // ========================================

        function exportShifts() {
    if (!filteredShifts || filteredShifts.length === 0) {
        showNotification('No shifts to export', 'error');
        return;
    }
    
    // FIX #6: Include complete data in export
    const exportData = filteredShifts.map(shift => {
        const staffMember = staff.find(s => s.id === shift.staff_id);
        const participant = participants.find(p => p.id === shift.participant_id);
        const location = locations.find(l => l.id === shift.location_id);
        const dutyType = dutyTypes.find(d => d.id === shift.duty_type_id);
        const hours = calculateShiftHours(shift);
        
        // Format date properly for Excel
        const shiftDate = new Date(shift.date + 'T12:00:00');
        const formattedDate = shiftDate.toLocaleDateString('en-AU');
        
        return {
            ID: shift.id,
            Date: formattedDate,
            DayOfWeek: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][shiftDate.getDay()],
            StaffCode: staffMember?.staff_code || '',
            StaffFirstName: staffMember?.first_name || '',
            StaffLastName: staffMember?.last_name || '',
            ParticipantFirstName: participant?.first_name || '',
            ParticipantLastName: participant?.last_name || '',
            ParticipantNDIS: participant?.ndis_number || '',
            Location: location?.name || participant ? 'Client Home' : 'Unassigned',
            LocationAddress: location?.address || '',
            StartTime: shift.start_time || '',
            EndTime: shift.end_time || '',
            DutyType: dutyType?.name || '',
            Status: shift.status || 'scheduled',
            
            // Hours breakdown
            TotalHours: hours.total.toFixed(2),
            WeekdayDayHours: (hours.weekdayDay || 0).toFixed(2),
            WeekdayEveningHours: (hours.weekdayEvening || 0).toFixed(2),
            WeekdayNightHours: (hours.weekdayNight || 0).toFixed(2),
            SaturdayHours: (hours.saturday || 0).toFixed(2),
            SundayHours: (hours.sunday || 0).toFixed(2),
            PublicHolidayHours: (hours.publicHoliday || 0).toFixed(2),
            SleepoverCount: hours.sleepover ? (hours.sleepover / 2) : 0,
            
            // Pay information
            BaseRate: staffMember?.base_pay_rate || 0,
            CalculatedPay: (shift.calculated_pay || 0).toFixed(2),
            PayOverride: shift.pay_override_id ? 'Yes' : 'No',
            
            // Additional info
            Notes: shift.notes || '',
            CreatedAt: formatDateTime(shift.created_at),
            UpdatedAt: shift.updated_at ? formatDateTime(shift.updated_at) : '',
            TransferStatus: shift.transfer_status || '',
            AdjustmentStatus: shift.adjustment_status || ''
        };
    });
    
    downloadCSV(exportData, `shifts-export-${formatDate(new Date().toISOString())}.csv`);
    showNotification('Shifts exported successfully', 'success');
}

async function checkBulkShiftConflicts(shiftsToImport) {
    const conflicts = [];
    const warnings = [];
    
    for (const shift of shiftsToImport) {
        // Check for existing shifts
        const { data: existingShifts } = await supabaseClient
            .from('shifts')
            .select('*')
            .eq('staff_id', shift.staff_id)
            .eq('date', shift.date)
            .is('deleted_at', null);
        
        if (existingShifts && existingShifts.length > 0) {
            for (const existing of existingShifts) {
                // Check for overlaps
                if (shift.start_time && shift.end_time && existing.start_time && existing.end_time) {
                    const newStart = new Date(`2000-01-01T${shift.start_time}`);
                    const newEnd = new Date(`2000-01-01T${shift.end_time}`);
                    const existStart = new Date(`2000-01-01T${existing.start_time}`);
                    const existEnd = new Date(`2000-01-01T${existing.end_time}`);
                    
                    if (newEnd <= newStart) newEnd.setDate(newEnd.getDate() + 1);
                    if (existEnd <= existStart) existEnd.setDate(existEnd.getDate() + 1);
                    
                    if (!(newEnd <= existStart || newStart >= existEnd)) {
                        conflicts.push({
                            importShift: shift,
                            existingShift: existing,
                            type: 'overlap',
                            message: `Staff ${shift.staff_name} has overlapping shifts on ${shift.date}`
                        });
                    }
                }
            }
        }
        
        // Check weekly hour limits
        const weekStart = getWeekStart(new Date(shift.date));
        const weekEnd = new Date(weekStart.getTime() + 7 * 24 * 60 * 60 * 1000);
        
        const { data: weekShifts } = await supabaseClient
            .from('shifts')
            .select('*')
            .eq('staff_id', shift.staff_id)
            .gte('date', weekStart.toISOString().split('T')[0])
            .lt('date', weekEnd.toISOString().split('T')[0])
            .is('deleted_at', null);
        
        let weekHours = 0;
        if (weekShifts) {
            weekShifts.forEach(s => {
                const hours = calculateShiftHours(s);
                weekHours += hours.total;
            });
        }
        
        const shiftHours = calculateShiftHours(shift);
        const staffMember = staff.find(s => s.id === shift.staff_id);
        const limit = staffMember?.weekly_hour_limit || 38;
        
        if (weekHours + shiftHours.total > limit) {
            warnings.push({
                shift: shift,
                type: 'hours',
                message: `Staff ${shift.staff_name} will exceed ${limit}h weekly limit (${weekHours + shiftHours.total}h total)`
            });
        }
    }
    
    return { conflicts, warnings };
}

async function createCareHomeBatchShifts() {
    const careHomeId = document.getElementById('batchCareHomeSelect')?.value;
    const date = document.getElementById('batchShiftDate')?.value;
    const startTime = document.getElementById('batchStartTime')?.value;
    const endTime = document.getElementById('batchEndTime')?.value;
    const selectedStaffId = document.getElementById('batchStaffSelect')?.value;
    const dutyTypeId = document.getElementById('batchDutyType')?.value;
    
    if (!careHomeId || !date || !selectedStaffId || !dutyTypeId) {
        showNotification('Please fill all required fields', 'error');
        return;
    }
    
    const careHome = careHomes.get(careHomeId);
    if (!careHome || !careHome.residents) {
        showNotification('No residents found for this care home', 'error');
        return;
    }
    
    try {
        // Check staff availability first
        const { data: existingShifts } = await supabaseClient
            .from('shifts')
            .select('*')
            .eq('staff_id', selectedStaffId)
            .eq('date', date)
            .is('deleted_at', null);
        
        if (existingShifts && existingShifts.length > 0) {
            const message = `⚠️ WARNING\n\n` +
                `Staff member already has ${existingShifts.length} shift(s) on ${date}.\n` +
                `Creating ${careHome.residents.length} additional shifts.\n\n` +
                `Continue?`;
            
            if (!confirm(message)) {
                return;
            }
        }
        
        // Calculate duration for each shift
        const selectedDutyType = dutyTypes.find(d => d.id === dutyTypeId);
        let duration = 0;
        
        if (selectedDutyType?.name.toLowerCase().includes('sleepover')) {
            duration = 2;
        } else if (startTime && endTime) {
            const start = new Date(`2000-01-01T${startTime}`);
            let end = new Date(`2000-01-01T${endTime}`);
            if (end <= start) end.setDate(end.getDate() + 1);
            duration = (end - start) / (1000 * 60 * 60);
        }
        
        // Create shifts for each resident
        const shiftsToCreate = careHome.residents.map(resident => ({
            date,
            start_time: startTime || null,
            end_time: endTime || null,
            staff_id: selectedStaffId,
            participant_id: resident.id,
            location_id: careHomeId,
            duty_type_id: dutyTypeId,
            status: 'confirmed',
            duration_hours: duration || null,
            notes: `Batch created for ${careHome.name}`,
            created_at: new Date().toISOString(),
            created_by: currentUser?.id || currentStaffData?.id
        }));
        
        // Batch insert
        const { data: createdShifts, error } = await supabaseClient
            .from('shifts')
            .insert(shiftsToCreate)
            .select();
        
        if (error) throw error;
        
        showNotification(`Created ${createdShifts.length} shifts for ${careHome.name}`, 'success');
        
        // Close modal if exists
        const modal = document.getElementById('batchCreateModal');
        if (modal) closeModal('batchCreateModal');
        
        await loadShifts();
        
        if (currentView === 'conflicts') {
            await renderConflicts();
        } else {
            renderCurrentView();
        }
        
    } catch (error) {
        console.error('Error creating batch shifts:', error);
        showNotification('Failed to create batch shifts: ' + error.message, 'error');
    }
}

function addStaffSwitcher() {
    // Check if switcher already exists
    if (document.getElementById('staffSwitcher')) return;
    
    const headerContent = document.querySelector('.header-content');
    if (!headerContent) return;
    
    const switcherHTML = `
        <div id="staffSwitcher" style="display: flex; align-items: center; gap: 10px;">
            <label style="font-size: 14px;">View as:</label>
            <select id="staffSwitcherSelect" style="padding: 5px; border-radius: 4px;">
                <option value="">Current User</option>
            </select>
        </div>
    `;
    
    headerContent.insertAdjacentHTML('beforeend', switcherHTML);
    
    // Populate with staff
    const select = document.getElementById('staffSwitcherSelect');
    if (select && staff && staff.length > 0) {
        staff.forEach(s => {
            const option = document.createElement('option');
            option.value = s.id;
            option.textContent = `${s.first_name} ${s.last_name}`;
            if (s.id === currentStaffData?.id) {
                option.selected = true;
            }
            select.appendChild(option);
        });
        
        // Add change handler
        select.addEventListener('change', async (e) => {
            const staffId = e.target.value;
            if (staffId) {
                currentStaffData = staff.find(s => s.id === staffId);
                await loadShifts();
                renderCurrentView();
            }
        });
    }
}

async function createCareHomeShifts() {
    const careHomeId = document.getElementById('batchCareHomeSelect')?.value;
    const date = document.getElementById('batchShiftDate')?.value;
    const startTime = document.getElementById('batchStartTime')?.value;
    const endTime = document.getElementById('batchEndTime')?.value;
    const selectedStaffId = document.getElementById('batchStaffSelect')?.value;
    const dutyTypeId = document.getElementById('batchDutyType')?.value;
    
    if (!careHomeId || !date || !selectedStaffId || !dutyTypeId) {
        showNotification('Please fill all required fields', 'error');
        return;
    }
    
    const careHome = careHomes.get(careHomeId);
    if (!careHome) {
        showNotification('Care home not found', 'error');
        return;
    }
    
    try {
        // Check for conflicts first
        const { data: existingShifts } = await supabaseClient
            .from('shifts')
            .select('*')
            .eq('staff_id', selectedStaffId)
            .eq('date', date)
            .is('deleted_at', null);
        
        if (existingShifts && existingShifts.length > 0) {
            if (!confirm(`Staff member already has ${existingShifts.length} shift(s) on this date. Continue?`)) {
                return;
            }
        }
        
        const shiftsToCreate = careHome.residents.map(resident => ({
            date: shiftDate,
        staff_id: selectedStaffId,
        participant_id: resident.id,
        location_id: careHome.location_id,
        duty_type_id: template.duty_type_id,
        start_time: template.start_time,
        end_time: template.end_time,
        status: 'scheduled',
        // FIX: Add pay_override_id
        pay_override_id: staff.find(s => s.id === selectedStaffId)?.pay_rate_id || null,
        created_by: currentStaffData.id,
        created_at: new Date().toISOString()
    }));
    
        
        // Calculate duration for each shift
        shiftsToCreate.forEach(shift => {
            const dutyType = dutyTypes.find(d => d.id === dutyTypeId);
            if (dutyType?.name.toLowerCase().includes('sleepover')) {
                shift.duration_hours = 2;
            } else if (startTime && endTime) {
                const start = new Date(`2000-01-01T${startTime}`);
                let end = new Date(`2000-01-01T${endTime}`);
                if (end <= start) end.setDate(end.getDate() + 1);
                shift.duration_hours = (end - start) / (1000 * 60 * 60);
            }
        });
        
        // Batch insert
        const { error } = await supabaseClient
            .from('shifts')
            .insert(shiftsToCreate);
        
        if (error) throw error;
        
        showNotification(`Created ${shiftsToCreate.length} shifts for ${careHome.name}`, 'success');
        closeModal('batchCreateModal');
        await loadShifts();
        
        if (currentView === 'conflicts') {
            await renderConflicts();
        } else {
            renderCurrentView();
        }
        
    } catch (error) {
        console.error('Error creating batch shifts:', error);
        showNotification('Failed to create batch shifts: ' + error.message, 'error');
    }
}

function generatePayrollSummary() {
   const startDate = document.getElementById('startDate').value;
   const endDate = document.getElementById('endDate').value;
   
   if (!startDate || !endDate) {
       showNotification('Please set date range for payroll', 'error');
       return;
   }
   
   const staffPayroll = {};
   
   // Group by staff and track hours by pay rate
   filteredShifts.forEach(shift => {
       const staffId = shift.staff_id;
       if (!staffId) return;
       
       if (!staffPayroll[staffId]) {
           staffPayroll[staffId] = {
               staff: shift.staff,
               // Hours at staff's default rate
               defaultRateHours: { 
                   total: 0, weekdayDay: 0, weekdayEvening: 0, weekdayNight: 0, 
                   saturday: 0, sunday: 0, publicHoliday: 0
               },
               defaultRateSleepoverCount: 0,
               // Hours at override rates - max 3 overrides
               override1Hours: null,
               override2Hours: null,
               override3Hours: null,
               // Track all hours for limit calculation
               allHours: {
                   total: 0, weekdayDay: 0, weekdayEvening: 0, weekdayNight: 0, 
                   saturday: 0, sunday: 0, publicHoliday: 0
               },
               totalPay: 0,
               shifts: [],
               totalSleepoverCount: 0,
               overrideRatesMap: new Map() // Map override ID to override index
           };
       }
       
       const entry = staffPayroll[staffId];
       const hours = shift.calculated_hours || {};
       
       entry.shifts.push(shift);
       entry.totalPay += shift.calculated_pay || 0;
       
       // Add to total hours regardless of rate
       entry.allHours.total += hours.total || 0;
       entry.allHours.weekdayDay += hours.weekdayDay || 0;
       entry.allHours.weekdayEvening += hours.weekdayEvening || 0;
       entry.allHours.weekdayNight += hours.weekdayNight || 0;
       entry.allHours.saturday += hours.saturday || 0;
       entry.allHours.sunday += hours.sunday || 0;
       entry.allHours.publicHoliday += hours.publicHoliday || 0;
       
       // Count total sleepovers
       if (hours.sleepover > 0) {
           entry.totalSleepoverCount++;
       }
       
       // Determine which rate bucket to add hours to
       if (shift.pay_override_id && shift.pay_override_id !== '00000000-0000-0000-0000-000000000002') {
           // This is an override rate (not the default UUID)
           let overrideIndex = entry.overrideRatesMap.get(shift.pay_override_id);
           
           if (overrideIndex === undefined) {
               // Assign new override slot
               if (!entry.override1Hours) {
                   overrideIndex = 1;
                   entry.override1Hours = {
                       rateId: shift.pay_override_id,
                       rate: payRates.find(pr => pr.id === shift.pay_override_id) || {},
                       label: payRateLabels.get(shift.pay_override_id) || 'Override 1',
                       hours: { total: 0, weekdayDay: 0, weekdayEvening: 0, weekdayNight: 0, 
                               saturday: 0, sunday: 0, publicHoliday: 0 },
                       sleepoverCount: 0
                   };
               } else if (!entry.override2Hours) {
                   overrideIndex = 2;
                   entry.override2Hours = {
                       rateId: shift.pay_override_id,
                       rate: payRates.find(pr => pr.id === shift.pay_override_id) || {},
                       label: payRateLabels.get(shift.pay_override_id) || 'Override 2',
                       hours: { total: 0, weekdayDay: 0, weekdayEvening: 0, weekdayNight: 0, 
                               saturday: 0, sunday: 0, publicHoliday: 0 },
                       sleepoverCount: 0
                   };
               } else if (!entry.override3Hours) {
                   overrideIndex = 3;
                   entry.override3Hours = {
                       rateId: shift.pay_override_id,
                       rate: payRates.find(pr => pr.id === shift.pay_override_id) || {},
                       label: payRateLabels.get(shift.pay_override_id) || 'Override 3',
                       hours: { total: 0, weekdayDay: 0, weekdayEvening: 0, weekdayNight: 0, 
                               saturday: 0, sunday: 0, publicHoliday: 0 },
                       sleepoverCount: 0
                   };
               } else {
                   console.warn(`Staff ${entry.staff.first_name} ${entry.staff.last_name} has more than 3 override rates`);
                   overrideIndex = 3; // Add to override 3 if exceeded
               }
               entry.overrideRatesMap.set(shift.pay_override_id, overrideIndex);
           }
           
           // Add hours to the appropriate override bucket
           const overrideBucket = overrideIndex === 1 ? entry.override1Hours : 
                                 overrideIndex === 2 ? entry.override2Hours : 
                                 entry.override3Hours;
           
           overrideBucket.hours.total += hours.total || 0;
           overrideBucket.hours.weekdayDay += hours.weekdayDay || 0;
           overrideBucket.hours.weekdayEvening += hours.weekdayEvening || 0;
           overrideBucket.hours.weekdayNight += hours.weekdayNight || 0;
           overrideBucket.hours.saturday += hours.saturday || 0;
           overrideBucket.hours.sunday += hours.sunday || 0;
           overrideBucket.hours.publicHoliday += hours.publicHoliday || 0;
           
           if (hours.sleepover > 0) {
               overrideBucket.sleepoverCount++;
           }
       } else {
           // Default rate hours (null or default UUID)
           entry.defaultRateHours.total += hours.total || 0;
           entry.defaultRateHours.weekdayDay += hours.weekdayDay || 0;
           entry.defaultRateHours.weekdayEvening += hours.weekdayEvening || 0;
           entry.defaultRateHours.weekdayNight += hours.weekdayNight || 0;
           entry.defaultRateHours.saturday += hours.saturday || 0;
           entry.defaultRateHours.sunday += hours.sunday || 0;
           entry.defaultRateHours.publicHoliday += hours.publicHoliday || 0;
           
           if (hours.sleepover > 0) {
               entry.defaultRateSleepoverCount++;
           }
       }
   });
   
   // Generate export data
   const payrollData = Object.values(staffPayroll).map(entry => {
       const staff = entry.staff || { first_name: 'Unknown', last_name: 'Staff', staff_code: '', limits: 76 };
       const hourLimit = parseFloat(staff.limits) || 76;
       
       // Calculate total for limit check - sleepovers already included in total
       const totalForLimit = entry.allHours.total;
       const overLimit = totalForLimit > hourLimit;
       const hoursToDeduct = overLimit ? totalForLimit - hourLimit : 0;
       
       // Get default pay rate
       let defaultPayRate = null;
       if (staff.pay_rate_id) {
           defaultPayRate = payRates.find(pr => pr.id === staff.pay_rate_id);
       }
       if (!defaultPayRate) {
           defaultPayRate = {};
       }
       const defaultPayRateLabel = staff.pay_rate_id ? 
           (payRateLabels.get(staff.pay_rate_id) || 'Standard Rate') : 
           'Standard Rate';
       
       // Start building the row
       const row = {
           // === STAFF INFO ===
           StaffName: `${staff.first_name} ${staff.last_name}`,
           StaffCode: staff.staff_code || '',
           HourLimit: hourLimit.toFixed(0),
           TotalHoursRaw: formatHours(entry.allHours.total),
           TotalSleepovers: entry.totalSleepoverCount,
           TotalForLimit: formatHours(totalForLimit),
           OverLimit: overLimit ? 'YES' : 'NO',
           HoursToDeduct: formatHours(hoursToDeduct),
           
           // === DEFAULT PAY RATE INFO ===
           DefaultRateLabel: defaultPayRateLabel,
           DefaultDayRate: `$${(defaultPayRate.hourly_pay_rate || 0).toFixed(2)}`,
           DefaultEveningRate: `$${(defaultPayRate.afternoon || 0).toFixed(2)}`,
           DefaultNightRate: `$${(defaultPayRate.night || 0).toFixed(2)}`,
           DefaultSaturdayRate: `$${(defaultPayRate.saturday || 0).toFixed(2)}`,
           DefaultSundayRate: `$${(defaultPayRate.sunday || 0).toFixed(2)}`,
           DefaultPublicHolidayRate: `$${(defaultPayRate.public_holiday || 0).toFixed(2)}`,
           DefaultSleepoverRate: `$${(defaultPayRate.sleepover || 0).toFixed(2)}`,
           
           // === DEFAULT RATE HOURS ===
           DefaultWeekdayHours: formatHours(entry.defaultRateHours.weekdayDay),
           DefaultEveningHours: formatHours(entry.defaultRateHours.weekdayEvening),
           DefaultNightHours: formatHours(entry.defaultRateHours.weekdayNight),
           DefaultSaturdayHours: formatHours(entry.defaultRateHours.saturday),
           DefaultSundayHours: formatHours(entry.defaultRateHours.sunday),
           DefaultPublicHolidayHours: formatHours(entry.defaultRateHours.publicHoliday),
           DefaultSleepoverCount: entry.defaultRateSleepoverCount
       };
       
       // === OVERRIDE RATE 1 ===
       if (entry.override1Hours) {
           const o1 = entry.override1Hours;
           row['Override1_Label'] = o1.label;
           row['Override1_DayRate'] = `$${(o1.rate.hourly_pay_rate || 0).toFixed(2)}`;
           row['Override1_EveningRate'] = `$${(o1.rate.afternoon || 0).toFixed(2)}`;
           row['Override1_NightRate'] = `$${(o1.rate.night || 0).toFixed(2)}`;
           row['Override1_SaturdayRate'] = `$${(o1.rate.saturday || 0).toFixed(2)}`;
           row['Override1_SundayRate'] = `$${(o1.rate.sunday || 0).toFixed(2)}`;
           row['Override1_PublicHolidayRate'] = `$${(o1.rate.public_holiday || 0).toFixed(2)}`;
           row['Override1_SleepoverRate'] = `$${(o1.rate.sleepover || 0).toFixed(2)}`;
           row['Override1_WeekdayHours'] = formatHours(o1.hours.weekdayDay);
           row['Override1_EveningHours'] = formatHours(o1.hours.weekdayEvening);
           row['Override1_NightHours'] = formatHours(o1.hours.weekdayNight);
           row['Override1_SaturdayHours'] = formatHours(o1.hours.saturday);
           row['Override1_SundayHours'] = formatHours(o1.hours.sunday);
           row['Override1_PublicHolidayHours'] = formatHours(o1.hours.publicHoliday);
           row['Override1_SleepoverCount'] = o1.sleepoverCount;
       }
       
       // === OVERRIDE RATE 2 ===
       if (entry.override2Hours) {
           const o2 = entry.override2Hours;
           row['Override2_Label'] = o2.label;
           row['Override2_DayRate'] = `$${(o2.rate.hourly_pay_rate || 0).toFixed(2)}`;
           row['Override2_EveningRate'] = `$${(o2.rate.afternoon || 0).toFixed(2)}`;
           row['Override2_NightRate'] = `$${(o2.rate.night || 0).toFixed(2)}`;
           row['Override2_SaturdayRate'] = `$${(o2.rate.saturday || 0).toFixed(2)}`;
           row['Override2_SundayRate'] = `$${(o2.rate.sunday || 0).toFixed(2)}`;
           row['Override2_PublicHolidayRate'] = `$${(o2.rate.public_holiday || 0).toFixed(2)}`;
           row['Override2_SleepoverRate'] = `$${(o2.rate.sleepover || 0).toFixed(2)}`;
           row['Override2_WeekdayHours'] = formatHours(o2.hours.weekdayDay);
           row['Override2_EveningHours'] = formatHours(o2.hours.weekdayEvening);
           row['Override2_NightHours'] = formatHours(o2.hours.weekdayNight);
           row['Override2_SaturdayHours'] = formatHours(o2.hours.saturday);
           row['Override2_SundayHours'] = formatHours(o2.hours.sunday);
           row['Override2_PublicHolidayHours'] = formatHours(o2.hours.publicHoliday);
           row['Override2_SleepoverCount'] = o2.sleepoverCount;
       }
       
       // === OVERRIDE RATE 3 ===
       if (entry.override3Hours) {
           const o3 = entry.override3Hours;
           row['Override3_Label'] = o3.label;
           row['Override3_DayRate'] = `$${(o3.rate.hourly_pay_rate || 0).toFixed(2)}`;
           row['Override3_EveningRate'] = `$${(o3.rate.afternoon || 0).toFixed(2)}`;
           row['Override3_NightRate'] = `$${(o3.rate.night || 0).toFixed(2)}`;
           row['Override3_SaturdayRate'] = `$${(o3.rate.saturday || 0).toFixed(2)}`;
           row['Override3_SundayRate'] = `$${(o3.rate.sunday || 0).toFixed(2)}`;
           row['Override3_PublicHolidayRate'] = `$${(o3.rate.public_holiday || 0).toFixed(2)}`;
           row['Override3_SleepoverRate'] = `$${(o3.rate.sleepover || 0).toFixed(2)}`;
           row['Override3_WeekdayHours'] = formatHours(o3.hours.weekdayDay);
           row['Override3_EveningHours'] = formatHours(o3.hours.weekdayEvening);
           row['Override3_NightHours'] = formatHours(o3.hours.weekdayNight);
           row['Override3_SaturdayHours'] = formatHours(o3.hours.saturday);
           row['Override3_SundayHours'] = formatHours(o3.hours.sunday);
           row['Override3_PublicHolidayHours'] = formatHours(o3.hours.publicHoliday);
           row['Override3_SleepoverCount'] = o3.sleepoverCount;
       }
       
       // === DEDUCTIONS AND ADJUSTED HOURS ===
       // Initialize deductions (will be 0 if not over limit)
       const deductions = {
           default: { weekdayDay: 0, weekdayEvening: 0, weekdayNight: 0, saturday: 0, sunday: 0, publicHoliday: 0 },
           override1: { weekdayDay: 0, weekdayEvening: 0, weekdayNight: 0, saturday: 0, sunday: 0, publicHoliday: 0 },
           override2: { weekdayDay: 0, weekdayEvening: 0, weekdayNight: 0, saturday: 0, sunday: 0, publicHoliday: 0 },
           override3: { weekdayDay: 0, weekdayEvening: 0, weekdayNight: 0, saturday: 0, sunday: 0, publicHoliday: 0 }
       };
       
       if (overLimit) {
           // Build list of all hour buckets with their rates for prioritization
           const deductionPriority = [];
           
           // Add default rate hours
           ['weekdayDay', 'weekdayEvening', 'weekdayNight', 'saturday', 'sunday', 'publicHoliday'].forEach(cat => {
               if (entry.defaultRateHours[cat] > 0) {
                   const rateField = cat === 'weekdayDay' ? 'hourly_pay_rate' :
                                    cat === 'weekdayEvening' ? 'afternoon' :
                                    cat === 'weekdayNight' ? 'night' :
                                    cat === 'publicHoliday' ? 'public_holiday' : cat;
                   deductionPriority.push({
                       source: 'default',
                       category: cat,
                       hours: entry.defaultRateHours[cat],
                       rate: parseFloat(defaultPayRate[rateField]) || 0
                   });
               }
           });
           
           // Add override hours
           [entry.override1Hours, entry.override2Hours, entry.override3Hours].forEach((override, idx) => {
               if (override) {
                   ['weekdayDay', 'weekdayEvening', 'weekdayNight', 'saturday', 'sunday', 'publicHoliday'].forEach(cat => {
                       if (override.hours[cat] > 0) {
                           const rateField = cat === 'weekdayDay' ? 'hourly_pay_rate' :
                                            cat === 'weekdayEvening' ? 'afternoon' :
                                            cat === 'weekdayNight' ? 'night' :
                                            cat === 'publicHoliday' ? 'public_holiday' : cat;
                           deductionPriority.push({
                               source: `override${idx + 1}`,
                               category: cat,
                               hours: override.hours[cat],
                               rate: parseFloat(override.rate[rateField]) || 0
                           });
                       }
                   });
               }
           });
           
           // Sort by rate (lowest first)
           deductionPriority.sort((a, b) => a.rate - b.rate);
           
           // Apply deductions
           let remainingToDeduct = hoursToDeduct;
           
           for (const item of deductionPriority) {
               if (remainingToDeduct <= 0) break;
               const toDeduct = Math.min(item.hours, remainingToDeduct);
               deductions[item.source][item.category] = toDeduct;
               remainingToDeduct -= toDeduct;
           }
       }
       
       // === ADJUSTED HOURS COLUMNS (always included) ===
       // Default adjusted
       row['DefaultWeekdayAdjusted'] = formatHours(entry.defaultRateHours.weekdayDay - deductions.default.weekdayDay);
       row['DefaultEveningAdjusted'] = formatHours(entry.defaultRateHours.weekdayEvening - deductions.default.weekdayEvening);
       row['DefaultNightAdjusted'] = formatHours(entry.defaultRateHours.weekdayNight - deductions.default.weekdayNight);
       row['DefaultSaturdayAdjusted'] = formatHours(entry.defaultRateHours.saturday - deductions.default.saturday);
       row['DefaultSundayAdjusted'] = formatHours(entry.defaultRateHours.sunday - deductions.default.sunday);
       row['DefaultPublicHolidayAdjusted'] = formatHours(entry.defaultRateHours.publicHoliday - deductions.default.publicHoliday);
       
       // Override 1 adjusted
       if (entry.override1Hours) {
           row['Override1_WeekdayAdjusted'] = formatHours(entry.override1Hours.hours.weekdayDay - deductions.override1.weekdayDay);
           row['Override1_EveningAdjusted'] = formatHours(entry.override1Hours.hours.weekdayEvening - deductions.override1.weekdayEvening);
           row['Override1_NightAdjusted'] = formatHours(entry.override1Hours.hours.weekdayNight - deductions.override1.weekdayNight);
           row['Override1_SaturdayAdjusted'] = formatHours(entry.override1Hours.hours.saturday - deductions.override1.saturday);
           row['Override1_SundayAdjusted'] = formatHours(entry.override1Hours.hours.sunday - deductions.override1.sunday);
           row['Override1_PublicHolidayAdjusted'] = formatHours(entry.override1Hours.hours.publicHoliday - deductions.override1.publicHoliday);
       }
       
       // Override 2 adjusted
       if (entry.override2Hours) {
           row['Override2_WeekdayAdjusted'] = formatHours(entry.override2Hours.hours.weekdayDay - deductions.override2.weekdayDay);
           row['Override2_EveningAdjusted'] = formatHours(entry.override2Hours.hours.weekdayEvening - deductions.override2.weekdayEvening);
           row['Override2_NightAdjusted'] = formatHours(entry.override2Hours.hours.weekdayNight - deductions.override2.weekdayNight);
           row['Override2_SaturdayAdjusted'] = formatHours(entry.override2Hours.hours.saturday - deductions.override2.saturday);
           row['Override2_SundayAdjusted'] = formatHours(entry.override2Hours.hours.sunday - deductions.override2.sunday);
           row['Override2_PublicHolidayAdjusted'] = formatHours(entry.override2Hours.hours.publicHoliday - deductions.override2.publicHoliday);
       }
       
       // Override 3 adjusted
       if (entry.override3Hours) {
           row['Override3_WeekdayAdjusted'] = formatHours(entry.override3Hours.hours.weekdayDay - deductions.override3.weekdayDay);
           row['Override3_EveningAdjusted'] = formatHours(entry.override3Hours.hours.weekdayEvening - deductions.override3.weekdayEvening);
           row['Override3_NightAdjusted'] = formatHours(entry.override3Hours.hours.weekdayNight - deductions.override3.weekdayNight);
           row['Override3_SaturdayAdjusted'] = formatHours(entry.override3Hours.hours.saturday - deductions.override3.saturday);
           row['Override3_SundayAdjusted'] = formatHours(entry.override3Hours.hours.sunday - deductions.override3.sunday);
           row['Override3_PublicHolidayAdjusted'] = formatHours(entry.override3Hours.hours.publicHoliday - deductions.override3.publicHoliday);
       }
       
       // === AGGREGATE TOTALS ===
       // Simple calculation: original total minus deductions
       const adjustedTotal = entry.allHours.total - hoursToDeduct;
       
       row['AdjustedTotalHours'] = formatHours(adjustedTotal);
       row['GrossSalary'] = `$${entry.totalPay.toFixed(2)}`;
       row['ShiftCount'] = entry.shifts.length;
       row['DateRange'] = `${startDate} to ${endDate}`;
       
       return row;
   });
   
   downloadCSV(payrollData, `payroll-summary-${startDate}-to-${endDate}.csv`);
}
        function exportData() {
            // Fixed export with proper staff name handling
            const exportData = filteredShifts.map(shift => {
                const staff = shift.staff || { first_name: 'Unknown', last_name: 'Staff' };
                const participant = shift.participant || {};
                const location = shift.location || {};
                const dutyType = shift.duty_type || {};
                const hours = shift.calculated_hours || { total: 0 };
                
                return {
                    Date: formatDate(shift.date),
                    Staff: `${staff.first_name} ${staff.last_name}`,
                    Client: participant.first_name ? `${participant.first_name} ${participant.last_name}` : location.name || 'Unassigned',
                    StartTime: shift.start_time || '',
                    EndTime: shift.end_time || '',
                    DutyType: dutyType.name || '',
                    TotalHours: hours.total.toFixed(2),
                    TotalPay: (shift.calculated_pay || 0).toFixed(2),
                    Status: shift.status || 'pending'
                };
            });

            downloadCSV(exportData, 'shifts-export.csv');
        }

        function exportTimesheet() {
            generatePayrollSummary(); // Use detailed payroll export
        }

        // ========================================
        // UTILITY FUNCTIONS
        // ========================================

        function formatDate(dateString) {
            if (!dateString) return '';
            const date = new Date(dateString);
            return date.toLocaleDateString('en-AU', {
                day: '2-digit',
                month: '2-digit', 
                year: 'numeric'
            });
        }

        function formatDateLong(dateString) {
            if (!dateString) return '';
            const date = new Date(dateString);
            return date.toLocaleDateString('en-AU', {
                weekday: 'long',
                day: 'numeric',
                month: 'long',
                year: 'numeric'
            });
        }

        function formatDateTime(dateTimeString) {
            if (!dateTimeString) return '';
            const date = new Date(dateTimeString);
            return date.toLocaleString('en-AU', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function downloadCSV(data, filename) {
            if (!data || data.length === 0) {
                showNotification('No data to export', 'error');
                return;
            }

            const headers = Object.keys(data[0]);
            const csvContent = [
                headers.join(','),
                ...data.map(row => headers.map(header => 
                    `"${(row[header] || '').toString().replace(/"/g, '""')}"`
                ).join(','))
            ].join('\n');

            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            
            showNotification(`${filename} downloaded successfully`, 'success');
        }

        function showNotification(message, type = 'info') {
    // Use existing toast system or create notification
    if (typeof showToast === 'function') {
        showToast(message, type);
    } else {
        // Basic fallback
        const notification = document.createElement('div');
        notification.className = `notification ${type}`;
        notification.textContent = message;
        notification.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px;
            background: ${type === 'success' ? '#4caf50' : type === 'error' ? '#f44336' : '#2196f3'};
            color: white;
            border-radius: 4px;
            z-index: 9999;
        `;
        document.body.appendChild(notification);
        setTimeout(() => notification.remove(), 3000);
    }
}


        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.style.display = 'none';
                
                // Reset all forms in the modal
                const forms = modal.querySelectorAll('form');
                forms.forEach(form => form.reset());
                
                // Clear hidden inputs and searchable inputs
                const hiddenInputs = modal.querySelectorAll('input[type="hidden"]');
                hiddenInputs.forEach(input => input.value = '');
                
                const searchableInputs = modal.querySelectorAll('.searchable-input');
                searchableInputs.forEach(input => input.value = '');
                
                // Hide any warning elements
                const warnings = modal.querySelectorAll('.hour-warning');
                warnings.forEach(warning => warning.style.display = 'none');
            }
        }

        function clearAllFilters() {
            document.getElementById('staffFilterInput').value = '';
            document.getElementById('participantFilterInput').value = '';
            document.getElementById('statusFilter').value = '';
            
            staffFilterValue = '';
            participantFilterValue = '';
            
            // Reset to current week
            setCurrentWeek();
            
            showNotification('All filters cleared, showing current week', 'info');
            applyFilters();
        }

        async function loadInitialData() {
    try {
        console.log('=== LOADING REFERENCE DATA ===');
        
        // Load all reference data in parallel
        const [
            { data: staffData, error: staffError },
            { data: participantsData, error: participantsError },
            { data: locationsData, error: locationsError },
            { data: dutyTypesData, error: dutyTypesError },
            { data: payRatesData, error: payRatesError },
            { data: payRateLabelsData, error: payRateLabelsError }
        ] = await Promise.all([
            supabaseClient.from('staff').select('*').eq('is_active', true).is('deleted_at', null).order('first_name'),
            supabaseClient.from('participants').select('*').eq('is_active', true).is('deleted_at', null).order('first_name'),
            supabaseClient.from('locations').select('*').order('name'),
            supabaseClient.from('duty_types').select('*').order('name'),
            supabaseClient.from('pay_rates').select('*').order('category, level, pay_point'),
            supabaseClient.from('pay_rate_labels').select('*')
        ]);

        // Check for errors
        if (staffError) throw staffError;
        if (participantsError) throw participantsError;
        if (locationsError) throw locationsError;
        if (dutyTypesError) throw dutyTypesError;
        if (payRatesError) throw payRatesError;
        if (payRateLabelsError) console.warn('Pay rate labels error:', payRateLabelsError);
        
        // Assign to global variables
        staff = staffData || [];
        participants = participantsData || [];
        locations = locationsData || [];
        dutyTypes = dutyTypesData || [];
        payRates = payRatesData || [];
        
        // Create pay rate labels map
        payRateLabels = new Map();
        if (payRateLabelsData) {
            payRateLabelsData.forEach(label => {
                payRateLabels.set(label.id, label.label);
            });
        }
        
        // Detect all care homes based on shared addresses
        detectCareHomes();
        
        console.log('Reference data loaded:', {
            staff: staff.length,
            participants: participants.length,
            locations: locations.length,
            dutyTypes: dutyTypes.length,
            payRates: payRates.length,
            payRateLabels: payRateLabels.size,
            careHomes: careHomes.size
        });
        
        // Initialize undo/redo buttons if they exist
        if (typeof UndoRedoManager !== 'undefined') {
            UndoRedoManager.updateButtons();
        }
        
        populateFilterDropdowns();
        populateModalDropdowns();

    } catch (error) {
        console.error('Error loading initial data:', error);
        showNotification('Failed to load reference data: ' + error.message, 'error');
    }
}

        function refreshData() {
            showNotification('Refreshing data...', 'info');
            Promise.all([loadInitialData(), loadShifts()])
                .then(() => {
                    showNotification('Data refreshed successfully', 'success');
                })
                .catch(error => {
                    console.error('Refresh error:', error);
                    showNotification('Failed to refresh data: ' + error.message, 'error');
                });
        }

        async function logout() {
            try {
                const { error } = await supabaseClient.auth.signOut();
                if (error) throw error;
                window.location.href = 'index.html';
            } catch (error) {
                console.error('Logout error:', error);
                showNotification('Logout failed', 'error');
            }
        }

        // ========================================
        // DEBUG FUNCTIONS
        // ========================================

        async function debugDataLoading() {
            console.log('=== COMPREHENSIVE DEBUG ANALYSIS ===');
            
            try {
                // Database connectivity tests
                const { count: shiftCount } = await supabaseClient
                    .from('shifts')
                    .select('*', { count: 'exact', head: true });
                    
                const { count: staffCount } = await supabaseClient
                    .from('staff')
                    .select('*', { count: 'exact', head: true });

                // Sample data with detailed info
                const { data: sampleShifts } = await supabaseClient
                    .from('shifts')
                    .select('id, date, start_time, end_time, staff_id, status, duration_hours, deleted_at')
                    .is('deleted_at', null)
                    .limit(5);
                    
                const { data: sampleStaff } = await supabaseClient
                    .from('staff')
                    .select('id, first_name, last_name, limits, is_active')
                    .eq('is_active', true)
                    .limit(3);
                
                console.log('Debug results:', {
                    database: { shiftCount, staffCount },
                    loaded: { 
                        shifts: shifts.length, 
                        filtered: filteredShifts.length,
                        staff: staff.length,
                        participants: participants.length 
                    },
                    samples: { sampleShifts, sampleStaff }
                });
                
                // Calculate sample hours for debugging
                let calculationTest = '';
                if (sampleShifts && sampleShifts.length > 0) {
                    const testShift = sampleShifts[0];
                    calculationTest = `
HOUR CALCULATION TEST:
Shift ID: ${testShift.id}
Date: ${testShift.date}
Start: ${testShift.start_time}
End: ${testShift.end_time}
Duration DB: ${testShift.duration_hours}`;
                }
                
                const filters = {
                    startDate: document.getElementById('startDate').value,
                    endDate: document.getElementById('endDate').value,
                    staffFilter: staffFilterValue,
                    participantFilter: participantFilterValue
                };
                
                alert(`DEBUG RESULTS:

DATABASE:
• ${shiftCount || 0} total shifts
• ${staffCount || 0} total staff

LOADED DATA:
• ${shifts.length} shifts in memory
• ${filteredShifts.length} after filters
• ${staff.length} staff loaded
• ${participants.length} participants loaded
• ${publicHolidays.size} public holidays

CURRENT FILTERS:
• Date: ${filters.startDate} to ${filters.endDate}
• Staff: ${filters.staffFilter || 'all'}
• Participant: ${filters.participantFilter || 'all'}

SAMPLE SHIFTS IN DB:
${sampleShifts?.map(s => `• ${s.date} ${s.start_time}-${s.end_time} (${s.duration_hours}h)`).join('\n') || 'No shifts found'}

SAMPLE STAFF:
${sampleStaff?.map(s => `• ${s.first_name} ${s.last_name} (limit: ${s.limits}h)`).join('\n') || 'No staff found'}

${calculationTest}

NEXT STEPS:
1. If no data: Create test shifts
2. If data exists but filtered out: Clear filters
3. Check browser console for detailed logs`);
                
            } catch (error) {
                console.error('Debug error:', error);
                alert('Debug failed: ' + error.message);
            }
        }

        // ========================================
        // INITIALIZATION
        // ========================================

        document.addEventListener('DOMContentLoaded', async () => {
            try {
                console.log('=== MC MANAGER STARTING ===');
                await initializeApp();
                console.log('=== MC MANAGER READY ===');
            } catch (error) {
                console.error('Initialization failed:', error);
                showNotification('Initialization failed. Please refresh the page.', 'error');
            }
        });

        // Auth state monitoring
        supabaseClient.auth.onAuthStateChange((event, session) => {
            console.log('Auth state change:', event);
            if (event === 'SIGNED_OUT') {
                window.location.href = 'index.html';
            }
        });

        // Debug helper
        window.mcDebug = {
            shifts: () => shifts,
            filtered: () => filteredShifts,
            staff: () => staff,
            calculateHours: (shiftId) => {
                const shift = shifts.find(s => s.id === shiftId);
                return shift ? calculateShiftHours(shift) : null;
            },
            testCalculation: () => {
                if (shifts.length > 0) {
                    const testShift = shifts[0];
                    console.log('Test calculation for first shift:', {
                        shift: testShift,
                        calculatedHours: calculateShiftHours(testShift),
                        calculatedPay: calculateShiftPay(testShift, calculateShiftHours(testShift))
                    });
                }
            }
        };

        // ============================================
// ENHANCED FEATURES - ADD THIS ENTIRE BLOCK
// ============================================

// 1. Initialize Enhanced Features
function initializeEnhancements() {
    initializeDarkMode();
    resetSessionTimer();
    setupEnhancedKeyboardShortcuts();
    addEnhancedUIElements();
}

// 2. Dark Mode Implementation
function initializeDarkMode() {
    const savedMode = localStorage.getItem('darkMode') || 'light';
    document.body.setAttribute('data-theme', savedMode);
    
    // Add dark mode styles
    if (!document.getElementById('darkModeStyles')) {
        const styleSheet = document.createElement('style');
        styleSheet.id = 'darkModeStyles';
        styleSheet.innerHTML = `
            [data-theme="dark"] {
                --bg-primary: #1a1a1a;
                --bg-secondary: #2d2d2d;
                --bg-light: #3a3a3a;
                --text-primary: #e0e0e0;
                --text-secondary: #b0b0b0;
                --text-muted: #808080;
                --border-color: #404040;
                --border-light: #333333;
            }
            
            [data-theme="dark"] .modal {
                background: var(--bg-secondary);
                color: var(--text-primary);
            }
            
            [data-theme="dark"] .roster-table {
                background: var(--bg-secondary);
            }
            
            [data-theme="dark"] input, 
            [data-theme="dark"] select, 
            [data-theme="dark"] textarea {
                background: var(--bg-light);
                color: var(--text-primary);
                border-color: var(--border-color);
            }
            
            [data-theme="dark"] .card {
                background: var(--bg-secondary);
                border-color: var(--border-color);
            }
        `;
        document.head.appendChild(styleSheet);
    }
}

function toggleDarkMode() {
    const currentMode = document.body.getAttribute('data-theme') || 'light';
    const newMode = currentMode === 'light' ? 'dark' : 'light';
    document.body.setAttribute('data-theme', newMode);
    localStorage.setItem('darkMode', newMode);
    
    // Update button icon
    const btn = document.getElementById('darkModeBtn');
    if (btn) btn.innerHTML = newMode === 'dark' ? '☀️' : '🌙';
}

// 3. Enhanced Keyboard Shortcuts
function setupEnhancedKeyboardShortcuts() {
    document.addEventListener('keydown', function(e) {
        // Skip if typing in input
        if (document.activeElement.tagName === 'INPUT' || 
            document.activeElement.tagName === 'TEXTAREA' || 
            document.activeElement.tagName === 'SELECT') return;
        
        // N - New shift
        if (e.key === 'n' && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            showAddShiftModal();
        }
        
        // F - Focus search
        if (e.key === 'f' && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            document.getElementById('staffFilterInput')?.focus();
        }
        
        // T - Today
        if (e.key === 't' && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            setCurrentWeek();
            loadShifts();
        }
        
        // Arrow keys - Navigate weeks
        if (e.key === 'ArrowLeft' && !e.shiftKey && !e.ctrlKey) {
            e.preventDefault();
            previousWeek();
        }
        if (e.key === 'ArrowRight' && !e.shiftKey && !e.ctrlKey) {
            e.preventDefault();
            nextWeek();
        }
        
        // 1-5 - Quick view switches
        if (e.key >= '1' && e.key <= '5' && !e.ctrlKey) {
            const views = ['table', 'summary', 'timesheet', 'requests', 'notes'];
            const viewIndex = parseInt(e.key) - 1;
            if (views[viewIndex]) {
                e.preventDefault();
                switchView(views[viewIndex]);
            }
        }
        
        // Ctrl+K - Global search
        if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
            e.preventDefault();
            showGlobalSearch();
        }
        
        // Ctrl+P - Print
        if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
            e.preventDefault();
            printRoster();
        }
    });
}

async function copyShift(shiftId) {
    const shift = shifts.find(s => s.id === shiftId);
    if (!shift) return;
    
    const newDate = prompt('Enter date for copied shift (YYYY-MM-DD):', shift.date);
    if (!newDate) return;
    
    try {
        const shiftData = {
            date: newDate,
            start_time: shift.start_time,
            end_time: shift.end_time,
            staff_id: shift.staff_id,
            participant_id: shift.participant_id,
            location_id: shift.location_id,
            duty_type_id: shift.duty_type_id,
            pay_override_id: shift.pay_override_id || '00000000-0000-0000-0000-000000000002', // FIXED!
            status: 'pending',
            created_by: currentStaffData?.id || currentUser.id
        };
        
        const { error } = await supabaseClient
            .from('shifts')
            .insert([shiftData]);
        
        if (!error) {
            showNotification('Shift copied successfully', 'success');
            await loadShifts();
        } else {
            throw error;
        }
    } catch (error) {
        showNotification('Failed to copy shift: ' + error.message, 'error');
    }
}

async function duplicateWeek() {
    const confirmDupe = confirm('Duplicate all shifts from current week to next week?');
    if (!confirmDupe) return;
    
    try {
        const weekStart = getWeekStart(currentWeekStart);
        const weekEnd = new Date(weekStart);
        weekEnd.setDate(weekEnd.getDate() + 6);
        
        const weekShifts = shifts.filter(s => 
            s.date >= weekStart.toISOString().split('T')[0] &&
            s.date <= weekEnd.toISOString().split('T')[0]
        );
        
        if (weekShifts.length === 0) {
            showNotification('No shifts to duplicate in current week', 'warning');
            return;
        }
        
        const newShifts = weekShifts.map(shift => {
            const newDate = new Date(shift.date);
            newDate.setDate(newDate.getDate() + 7);
            
            return {
                date: newDate.toISOString().split('T')[0],
                start_time: shift.start_time,
                end_time: shift.end_time,
                staff_id: shift.staff_id,
                participant_id: shift.participant_id,
                location_id: shift.location_id,
                duty_type_id: shift.duty_type_id,
                pay_override_id: shift.pay_override_id || '00000000-0000-0000-0000-000000000002', // FIXED!
                status: 'pending',
                created_by: currentStaffData?.id || currentUser.id
            };
        });
        
        const { error } = await supabaseClient
            .from('shifts')
            .insert(newShifts);
        
        if (!error) {
            showNotification(`${newShifts.length} shifts duplicated to next week`, 'success');
            nextWeek();
        } else {
            throw error;
        }
    } catch (error) {
        showNotification('Failed to duplicate week: ' + error.message, 'error');
    }
}

// 5. Auto-save Indicator
function showSaving() {
    let indicator = document.getElementById('saveIndicator');
    
    if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'saveIndicator';
        indicator.style.cssText = `
            position: fixed;
            top: 70px;
            right: 20px;
            background: var(--success-color);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 9999;
            display: none;
            align-items: center;
            gap: 8px;
        `;
        document.body.appendChild(indicator);
    }
    
    indicator.innerHTML = '⏳ Saving...';
    indicator.style.display = 'flex';
    
    setTimeout(() => {
        indicator.innerHTML = '✓ Saved';
        setTimeout(() => {
            indicator.style.display = 'none';
        }, 2000);
    }, 500);
}


function performGlobalSearch() {
    const query = document.getElementById('globalSearchInput').value.toLowerCase();
    const results = document.getElementById('searchResults');
    
    if (query.length < 2) {
        results.innerHTML = '<p style="color: var(--text-muted);">Type at least 2 characters...</p>';
        return;
    }
    
    let html = '';
    
    // Search staff
    const matchingStaff = staff.filter(s => 
        `${s.first_name} ${s.last_name}`.toLowerCase().includes(query)
    );
    
    if (matchingStaff.length > 0) {
        html += '<h4>Staff</h4>';
        matchingStaff.forEach(s => {
            html += `
                <div style="padding: 8px; cursor: pointer; border-radius: 4px;" 
                     onmouseover="this.style.background='var(--bg-light)'"
                     onmouseout="this.style.background='transparent'"
                     onclick="document.getElementById('staffFilterInput').value='${s.first_name} ${s.last_name}'; 
                              updateStaffFilter(); closeModal('searchModal');">
                    👤 ${s.first_name} ${s.last_name}
                </div>`;
        });
    }
    
    // Search participants
    const matchingParticipants = participants.filter(p => 
        `${p.first_name} ${p.last_name}`.toLowerCase().includes(query)
    );
    
    if (matchingParticipants.length > 0) {
        html += '<h4 style="margin-top: 16px;">Participants</h4>';
        matchingParticipants.forEach(p => {
            html += `
                <div style="padding: 8px; cursor: pointer; border-radius: 4px;"
                     onmouseover="this.style.background='var(--bg-light)'"
                     onmouseout="this.style.background='transparent'"
                     onclick="document.getElementById('participantFilterInput').value='${p.first_name} ${p.last_name}'; 
                              updateParticipantFilter(); closeModal('searchModal');">
                    👥 ${p.first_name} ${p.last_name}
                </div>`;
        });
    }
    
    results.innerHTML = html || '<p style="text-align: center; color: var(--text-muted);">No results found</p>';
}

// 7. Print Function
function printRoster() {
    // Add print styles if not already added
    if (!document.getElementById('printStyles')) {
        const styleSheet = document.createElement('style');
        styleSheet.id = 'printStyles';
        styleSheet.innerHTML = `
            @media print {
                .header, .filters-section, .view-actions, .modal, .view-toggle, .btn { 
                    display: none !important; 
                }
                
                body { 
                    font-size: 10pt; 
                    color: black !important;
                    background: white !important;
                }
                
                .roster-table { 
                    width: 100%; 
                    border-collapse: collapse;
                    background: white !important;
                }
                
                .roster-table th, .roster-table td { 
                    border: 1px solid #000 !important; 
                    padding: 4px !important;
                    font-size: 9pt !important;
                    color: black !important;
                }
                
                @page { 
                    margin: 1cm;
                    size: landscape;
                }
            }
        `;
        document.head.appendChild(styleSheet);
    }
    
    window.print();
}

// 8. Quick Status Change
async function quickStatusChange(shiftId, newStatus) {
    if (!newStatus) return;
    
    try {
        const { error } = await supabaseClient
            .from('shifts')
            .update({ 
                status: newStatus,
                updated_at: new Date().toISOString()
            })
            .eq('id', shiftId);
        
        if (!error) {
            showSaving();
            showNotification(`Status updated to ${newStatus}`, 'success');
            await loadShifts();
        } else {
            throw error;
        }
    } catch (error) {
        showNotification('Failed to update status: ' + error.message, 'error');
    }
}

// 9. Session Management
let sessionTimer;
let warningTimer;
const SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes
const WARNING_TIME = 5 * 60 * 1000; // 5 minute warning

function resetSessionTimer() {
    clearTimeout(sessionTimer);
    clearTimeout(warningTimer);
    
    warningTimer = setTimeout(() => {
        if (confirm('Your session will expire in 5 minutes. Stay logged in?')) {
            resetSessionTimer();
        }
    }, SESSION_TIMEOUT - WARNING_TIME);
    
    sessionTimer = setTimeout(() => {
        alert('Session expired. Please log in again.');
        window.location.href = 'index.html';
    }, SESSION_TIMEOUT);
}

// Reset timer on activity
document.addEventListener('click', resetSessionTimer);
document.addEventListener('keypress', resetSessionTimer);

// 10. Export Functions
function exportJSON() {
    const dataStr = JSON.stringify(filteredShifts, null, 2);
    const dataBlob = new Blob([dataStr], {type: 'application/json'});
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `roster_${new Date().toISOString().split('T')[0]}.json`;
    link.click();
}

async function processCSVImport(csvData) {
    try {
        // Parse CSV data (assuming you have parsing logic)
        const shiftsToImport = parseCSVData(csvData);
        
        // FIX #2: Check conflicts before bulk import
        const conflictReport = {
            overlaps: [],
            sleepovers: [],
            weeklyLimits: [],
            skipped: 0,
            imported: 0
        };
        
        const validShifts = [];
        
        for (const importShift of shiftsToImport) {
            let hasConflict = false;
            
            // Check for existing shifts
            const { data: existingShifts } = await supabaseClient
                .from('shifts')
                .select('*')
                .eq('staff_id', importShift.staff_id)
                .eq('date', importShift.date)
                .is('deleted_at', null);
            
            // Check for sleepover conflicts
            const isImportSleepover = importShift.duty_type?.toLowerCase().includes('sleepover');
            const existingSleepover = (existingShifts || []).find(s => {
                const dt = dutyTypes.find(d => d.id === s.duty_type_id);
                return dt?.name?.toLowerCase().includes('sleepover');
            });
            
            if (isImportSleepover && existingSleepover) {
                conflictReport.sleepovers.push({
                    shift: importShift,
                    reason: 'Staff already has sleepover on this date'
                });
                hasConflict = true;
                continue;
            }
            
            // Check for time overlaps
            if (importShift.start_time && importShift.end_time && !isImportSleepover) {
                const newStart = new Date(`2000-01-01T${importShift.start_time}`);
                let newEnd = new Date(`2000-01-01T${importShift.end_time}`);
                if (newEnd <= newStart) newEnd.setDate(newEnd.getDate() + 1);
                
                for (const existing of (existingShifts || [])) {
                    if (existing.start_time && existing.end_time) {
                        const existingStart = new Date(`2000-01-01T${existing.start_time}`);
                        let existingEnd = new Date(`2000-01-01T${existing.end_time}`);
                        if (existingEnd <= existingStart) existingEnd.setDate(existingEnd.getDate() + 1);
                        
                        if (!(newEnd <= existingStart || newStart >= existingEnd)) {
                            conflictReport.overlaps.push({
                                importShift,
                                existingShift: existing,
                                overlapHours: ((Math.min(newEnd, existingEnd) - Math.max(newStart, existingStart)) / (1000 * 60 * 60)).toFixed(1)
                            });
                            hasConflict = true;
                            break;
                        }
                    }
                }
            }
            
            // Check weekly hours
            const weekStart = new Date(importShift.date);
            weekStart.setDate(weekStart.getDate() - weekStart.getDay());
            const weekEnd = new Date(weekStart);
            weekEnd.setDate(weekEnd.getDate() + 6);
            
            const { data: weekShifts } = await supabaseClient
                .from('shifts')
                .select('*')
                .eq('staff_id', importShift.staff_id)
                .gte('date', weekStart.toISOString().split('T')[0])
                .lte('date', weekEnd.toISOString().split('T')[0])
                .is('deleted_at', null);
            
            let totalWeekHours = 0;
            (weekShifts || []).forEach(s => {
                totalWeekHours += s.duration_hours || 0;
            });
            
            const staffMember = staff.find(s => s.id === importShift.staff_id);
            const weeklyLimit = staffMember?.weekly_hour_limit || 38;
            const importHours = importShift.duration_hours || 0;
            
            if (totalWeekHours + importHours > weeklyLimit) {
                conflictReport.weeklyLimits.push({
                    shift: importShift,
                    currentHours: totalWeekHours,
                    newTotal: totalWeekHours + importHours,
                    limit: weeklyLimit
                });
            }
            
            if (!hasConflict) {
                validShifts.push(importShift);
            } else {
                conflictReport.skipped++;
            }
        }
        
        // Show conflict report if there are issues
        if (conflictReport.overlaps.length > 0 || 
            conflictReport.sleepovers.length > 0 || 
            conflictReport.weeklyLimits.length > 0) {
            
            let message = 'IMPORT CONFLICTS DETECTED\n\n';
            
            if (conflictReport.overlaps.length > 0) {
                message += `⚠️ ${conflictReport.overlaps.length} overlapping shifts\n`;
            }
            if (conflictReport.sleepovers.length > 0) {
                message += `🛏️ ${conflictReport.sleepovers.length} sleepover conflicts\n`;
            }
            if (conflictReport.weeklyLimits.length > 0) {
                message += `⏰ ${conflictReport.weeklyLimits.length} weekly hour limit warnings\n`;
            }
            
            message += `\n✓ ${validShifts.length} shifts ready to import\n`;
            message += `✗ ${conflictReport.skipped} shifts will be skipped\n\n`;
            message += 'Do you want to proceed with importing valid shifts only?';
            
            if (!confirm(message)) {
                showNotification('Import cancelled', 'info');
                return;
            }
        }
        
        // Import valid shifts
        if (validShifts.length > 0) {
            const { error } = await supabaseClient
                .from('shifts')
                .insert(validShifts);
            
            if (error) throw error;
            
            showNotification(`Successfully imported ${validShifts.length} shifts`, 'success');
            conflictReport.imported = validShifts.length;
        } else {
            showNotification('No valid shifts to import', 'warning');
        }
        
        // Generate detailed report
        generateImportReport(conflictReport);
        
        await loadShifts();
        if (currentView === 'conflicts') {
            await renderConflicts();
        } else {
            renderCurrentView();
        }
        
    } catch (error) {
        console.error('Error processing CSV import:', error);
        showNotification('Failed to import shifts: ' + error.message, 'error');
    }
}

function generateImportReport(report) {
    // Create a detailed CSV report of conflicts
    let csvContent = 'Type,Date,Staff,Details,Status\n';
    
    report.overlaps.forEach(item => {
        const staffName = staff.find(s => s.id === item.importShift.staff_id)?.first_name || 'Unknown';
        csvContent += `Overlap,${item.importShift.date},${staffName},"${item.overlapHours}h overlap",Skipped\n`;
    });
    
    report.sleepovers.forEach(item => {
        const staffName = staff.find(s => s.id === item.shift.staff_id)?.first_name || 'Unknown';
        csvContent += `Sleepover,${item.shift.date},${staffName},"${item.reason}",Skipped\n`;
    });
    
    report.weeklyLimits.forEach(item => {
        const staffName = staff.find(s => s.id === item.shift.staff_id)?.first_name || 'Unknown';
        csvContent += `Hours,Week of ${item.shift.date},${staffName},"${item.newTotal}h exceeds ${item.limit}h limit",Warning\n`;
    });
    
    // Download the report
    downloadCSV(csvContent, `import-report-${new Date().toISOString().split('T')[0]}.csv`);
}

function exportDetailedCSV() {
    let csv = 'Date,Day,Start Time,End Time,Staff Name,Participant,Location,Duty Type,Hours,Status,Pay Rate,Total Pay\n';
    
    filteredShifts.forEach(shift => {
        const row = [
            shift.date,
            new Date(shift.date).toLocaleDateString('en-AU', {weekday: 'short'}),
            shift.start_time || 'N/A',
            shift.end_time || 'N/A',
            `${shift.staff?.first_name || ''} ${shift.staff?.last_name || ''}`,
            shift.participant ? `${shift.participant.first_name} ${shift.participant.last_name}` : '',
            shift.location?.name || '',
            shift.duty_type?.name || '',
            shift.calculated_hours?.total?.toFixed(2) || '0',
            shift.status || 'pending',
            payRateLabels.get(shift.staff?.pay_rate_id) || 'Standard',
            shift.calculated_pay?.toFixed(2) || '0'
        ];
        csv += row.map(cell => `"${cell}"`).join(',') + '\n';
    });
    
    downloadCSV(csv, `roster_detailed_${new Date().toISOString().split('T')[0]}.csv`);
}

// 11. Add UI Enhancement Buttons
function addEnhancedUIElements() {
    // Add buttons to view-actions if they don't exist
    const viewActions = document.querySelector('.view-actions');
    if (viewActions && !document.getElementById('enhancedButtons')) {
        const enhancedButtons = document.createElement('div');
        enhancedButtons.id = 'enhancedButtons';
        enhancedButtons.style.display = 'inline-flex';
        enhancedButtons.style.gap = '8px';
        enhancedButtons.style.marginLeft = '8px';
        enhancedButtons.innerHTML = `
            <span style="border-left: 1px solid var(--border-color); margin: 0 8px; height: 24px;"></span>
            <button class="btn btn-outline btn-sm" id="darkModeBtn" onclick="toggleDarkMode()" title="Toggle Dark Mode">
                ${document.body.getAttribute('data-theme') === 'dark' ? '☀️' : '🌙'}
            </button>
            <button class="btn btn-outline btn-sm" onclick="showGlobalSearch()" title="Search (Ctrl+K)">🔍</button>
            <button class="btn btn-outline btn-sm" onclick="duplicateWeek()" title="Duplicate Week">📋</button>
            <button class="btn btn-outline btn-sm" onclick="printRoster()" title="Print (Ctrl+P)">🖨️</button>
            <button class="btn btn-outline btn-sm" onclick="exportDetailedCSV()" title="Export Detailed CSV">📊</button>
            <button class="btn btn-outline btn-sm" onclick="showKeyboardShortcuts()" title="Keyboard Shortcuts">⌨️</button>
        `;
        viewActions.appendChild(enhancedButtons);
    }
}

// 12. Keyboard Shortcuts Help
function showKeyboardShortcuts() {
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.style.display = 'flex';
    modal.innerHTML = `
        <div class="modal" style="max-width: 500px;">
            <header class="modal-header">
                <h3 class="modal-title">Keyboard Shortcuts</h3>
                <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">&times;</button>
            </header>
            <div class="modal-content">
                <table style="width: 100%;">
                    <tr><td><kbd>N</kbd></td><td>New Shift</td></tr>
                    <tr><td><kbd>F</kbd></td><td>Focus Search</td></tr>
                    <tr><td><kbd>T</kbd></td><td>Go to Today</td></tr>
                    <tr><td><kbd>←</kbd> <kbd>→</kbd></td><td>Navigate Weeks</td></tr>
                    <tr><td><kbd>1-5</kbd></td><td>Switch Views</td></tr>
                    <tr><td><kbd>Ctrl+K</kbd></td><td>Global Search</td></tr>
                    <tr><td><kbd>Ctrl+Z</kbd></td><td>Undo</td></tr>
                    <tr><td><kbd>Ctrl+Y</kbd></td><td>Redo</td></tr>
                    <tr><td><kbd>Ctrl+P</kbd></td><td>Print</td></tr>
                </table>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
}

async function renderConflicts() {
    const conflictsContent = document.getElementById('conflictsContent');
    if (!conflictsContent) {
        // Create the view if it doesn't exist
        const conflictsView = document.getElementById('conflictsView');
        if (conflictsView) {
            conflictsView.innerHTML = `
                <div class="table-container">
                    <header class="table-header">
                        <h2 class="table-title">⚠️ Scheduling Conflicts & Issues</h2>
                        <div class="table-actions">
                            <button class="btn btn-outline btn-sm" onclick="renderConflicts()">
                                <span style="margin-right: 4px;">🔄</span> Refresh
                            </button>
                            <button class="btn btn-warning btn-sm" onclick="autoResolveConflicts()" style="margin-left: 8px;">
                                <span style="margin-right: 4px;">🔧</span> Auto-Resolve
                            </button>
                            <button class="btn btn-success btn-sm" onclick="exportConflictsReport()" style="margin-left: 8px;">
                                <span style="margin-right: 4px;">📊</span> Export Report
                            </button>
                        </div>
                    </header>
                    <div class="card-content" id="conflictsContent">
                        <div class="loading">
                            <div class="spinner"></div>
                            <span>Analyzing shifts for conflicts...</span>
                        </div>
                    </div>
                </div>
            `;
            conflictsContent = document.getElementById('conflictsContent');
        }
        return;
    }
    
    console.log('Analyzing conflicts in', shifts.length, 'shifts...');
    
    // Analyze all shifts for conflicts
    const conflicts = {
        staffDoubleBooking: [],
        sleepoverViolations: [],
        excessiveHours: [],
        missingTimes: [],
        unconfirmedShifts: [],
        noPayRate: [],
        participantOverlaps: []
    };
    
    // 1. Check for staff double-booking
    const staffShiftsByDate = {};
    shifts.forEach(shift => {
        const key = `${shift.staff_id}_${shift.date}`;
        if (!staffShiftsByDate[key]) {
            staffShiftsByDate[key] = [];
        }
        staffShiftsByDate[key].push(shift);
    });
    
    Object.entries(staffShiftsByDate).forEach(([key, dayShifts]) => {
        if (dayShifts.length > 1) {
            // Check for time overlaps
            for (let i = 0; i < dayShifts.length - 1; i++) {
                for (let j = i + 1; j < dayShifts.length; j++) {
                    const shift1 = dayShifts[i];
                    const shift2 = dayShifts[j];
                    
                    if (shift1.start_time && shift1.end_time && 
                        shift2.start_time && shift2.end_time) {
                        
                        const start1 = new Date(`2000-01-01T${shift1.start_time}`);
                        let end1 = new Date(`2000-01-01T${shift1.end_time}`);
                        const start2 = new Date(`2000-01-01T${shift2.start_time}`);
                        let end2 = new Date(`2000-01-01T${shift2.end_time}`);
                        
                        if (end1 <= start1) end1.setDate(end1.getDate() + 1);
                        if (end2 <= start2) end2.setDate(end2.getDate() + 1);
                        
                        // Check for overlap
                        if (!(end1 <= start2 || start1 >= end2)) {
                            const overlapStart = new Date(Math.max(start1, start2));
                            const overlapEnd = new Date(Math.min(end1, end2));
                            
                            conflicts.staffDoubleBooking.push({
                                staff: shift1.staff,
                                date: shift1.date,
                                shift1: shift1,
                                shift2: shift2,
                                overlapPeriod: {
                                    start: overlapStart.toTimeString().slice(0, 5),
                                    end: overlapEnd.toTimeString().slice(0, 5),
                                    hours: ((overlapEnd - overlapStart) / (1000 * 60 * 60)).toFixed(1)
                                }
                            });
                        }
                    }
                }
            }
            
            // Check for sleepover violations
            const sleepover = dayShifts.find(s => 
                s.duty_type?.name?.toLowerCase().includes('sleepover')
            );
            
            if (sleepover) {
                dayShifts.forEach(shift => {
                    if (shift.id !== sleepover.id && shift.start_time) {
                        const startHour = parseInt(shift.start_time.split(':')[0]);
                        const endHour = shift.end_time ? 
                            parseInt(shift.end_time.split(':')[0]) : 0;
                        
                        if (startHour >= 22 || startHour < 6 || 
                            (endHour > 0 && endHour <= 6)) {
                            conflicts.sleepoverViolations.push({
                                staff: shift.staff,
                                date: shift.date,
                                sleepoverShift: sleepover,
                                conflictingShift: shift,
                                reason: startHour >= 22 ? 
                                    'Late night shift (after 10pm) with sleepover' : 
                                    'Early morning shift (before 6am) with sleepover'
                            });
                        }
                    }
                });
            }
        }
    });
    
    // 2. Check for excessive hours (over limit in week)
    const weekGroups = {};
    shifts.forEach(shift => {
        const weekStart = getWeekStart(new Date(shift.date));
        const weekKey = `${shift.staff_id}_${weekStart.toISOString().split('T')[0]}`;
        
        if (!weekGroups[weekKey]) {
            weekGroups[weekKey] = {
                staff: shift.staff,
                weekStart: weekStart,
                shifts: [],
                totalHours: 0
            };
        }
        
        weekGroups[weekKey].shifts.push(shift);
        weekGroups[weekKey].totalHours += shift.calculated_hours?.total || 0;
    });
    
    Object.values(weekGroups).forEach(group => {
        const limit = group.staff?.limits || 76;
        if (group.totalHours > limit) {
            conflicts.excessiveHours.push({
                staff: group.staff,
                weekStart: group.weekStart,
                totalHours: group.totalHours,
                limit: limit,
                excess: group.totalHours - limit,
                shiftCount: group.shifts.length
            });
        }
    });
    
    // 3. Check for missing times
    shifts.forEach(shift => {
        const isSleepover = shift.duty_type?.name?.toLowerCase().includes('sleepover');
        
        if (!isSleepover && (!shift.start_time || !shift.end_time)) {
            conflicts.missingTimes.push({
                shift: shift,
                staff: shift.staff,
                participant: shift.participant,
                date: shift.date,
                missing: !shift.start_time && !shift.end_time ? 'both times' :
                        !shift.start_time ? 'start time' : 'end time'
            });
        }
    });
    
    // 4. Check for unconfirmed shifts
    shifts.forEach(shift => {
        if (shift.status === 'pending') {
            conflicts.unconfirmedShifts.push({
                shift: shift,
                staff: shift.staff,
                participant: shift.participant,
                date: shift.date,
                daysOld: Math.floor((new Date() - new Date(shift.created_at)) / (1000 * 60 * 60 * 24))
            });
        }
    });
    
    // 5. Check for missing pay rates
    shifts.forEach(shift => {
        if (!shift.pay_override_id && !shift.staff?.pay_rate_id) {
            conflicts.noPayRate.push({
                shift: shift,
                staff: shift.staff,
                date: shift.date,
                participant: shift.participant
            });
        }
    });
    
    // 6. Check participant overlaps (for info)
    const participantShiftsByDate = {};
    shifts.forEach(shift => {
        if (shift.participant_id) {
            const key = `${shift.participant_id}_${shift.date}`;
            if (!participantShiftsByDate[key]) {
                participantShiftsByDate[key] = [];
            }
            participantShiftsByDate[key].push(shift);
        }
    });
    
    Object.entries(participantShiftsByDate).forEach(([key, dayShifts]) => {
        if (dayShifts.length > 1) {
            // Check for overlapping times
            let maxConcurrent = 0;
            const overlaps = [];
            
            for (let i = 0; i < dayShifts.length; i++) {
                const shift = dayShifts[i];
                if (shift.start_time && shift.end_time) {
                    const concurrent = [];
                    
                    for (let j = 0; j < dayShifts.length; j++) {
                        if (i !== j && dayShifts[j].start_time && dayShifts[j].end_time) {
                            const start1 = new Date(`2000-01-01T${shift.start_time}`);
                            let end1 = new Date(`2000-01-01T${shift.end_time}`);
                            const start2 = new Date(`2000-01-01T${dayShifts[j].start_time}`);
                            let end2 = new Date(`2000-01-01T${dayShifts[j].end_time}`);
                            
                            if (end1 <= start1) end1.setDate(end1.getDate() + 1);
                            if (end2 <= start2) end2.setDate(end2.getDate() + 1);
                            
                            if (!(end1 <= start2 || start1 >= end2)) {
                                concurrent.push(dayShifts[j]);
                            }
                        }
                    }
                    
                    if (concurrent.length > 0 && concurrent.length + 1 > maxConcurrent) {
                        maxConcurrent = concurrent.length + 1;
                        overlaps.push({
                            participant: shift.participant,
                            date: shift.date,
                            ratio: `${concurrent.length + 1}:1`,
                            mainShift: shift,
                            overlappingShifts: concurrent
                        });
                    }
                }
            }
            
            if (maxConcurrent > 2) {
                // Only flag if more than 2:1 ratio
                conflicts.participantOverlaps.push(overlaps[0]);
            }
        }
    });
    
    // Build the HTML display
    let html = `
        <style>
            .conflicts-summary {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 16px;
                margin-bottom: 24px;
            }
            
            .conflict-stat {
                background: white;
                border: 1px solid var(--border-color);
                border-radius: 8px;
                padding: 16px;
                text-align: center;
            }
            
            .conflict-stat.error {
                border-color: var(--danger-color);
                background: var(--danger-color)10;
            }
            
            .conflict-stat.warning {
                border-color: var(--warning-color);
                background: var(--warning-color)10;
            }
            
            .conflict-stat.info {
                border-color: var(--info-color);
                background: var(--info-color)10;
            }
            
            .conflict-stat h3 {
                margin: 0 0 8px 0;
                font-size: 24px;
                font-weight: bold;
            }
            
            .conflict-stat p {
                margin: 0;
                font-size: 14px;
                color: var(--text-secondary);
            }
            
            .conflict-section {
                margin-bottom: 32px;
            }
            
            .conflict-section h3 {
                margin-bottom: 16px;
                display: flex;
                align-items: center;
                gap: 8px;
            }
            
            .conflict-item {
                background: white;
                border: 1px solid var(--border-color);
                border-radius: 8px;
                padding: 16px;
                margin-bottom: 12px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            
            .conflict-details {
                flex: 1;
            }
            
            .conflict-actions {
                display: flex;
                gap: 8px;
            }
            
            .overlap-visual {
                display: inline-block;
                background: var(--danger-color)20;
                color: var(--danger-color);
                padding: 4px 8px;
                border-radius: 4px;
                font-family: monospace;
                font-size: 12px;
                margin-left: 8px;
            }
        </style>
        
        <div class="conflicts-summary">
            <div class="conflict-stat ${conflicts.staffDoubleBooking.length > 0 ? 'error' : ''}">
                <h3>${conflicts.staffDoubleBooking.length}</h3>
                <p>Staff Double-Bookings</p>
            </div>
            <div class="conflict-stat ${conflicts.sleepoverViolations.length > 0 ? 'error' : ''}">
                <h3>${conflicts.sleepoverViolations.length}</h3>
                <p>Sleepover Violations</p>
            </div>
            <div class="conflict-stat ${conflicts.excessiveHours.length > 0 ? 'warning' : ''}">
                <h3>${conflicts.excessiveHours.length}</h3>
                <p>Excessive Hours</p>
            </div>
            <div class="conflict-stat ${conflicts.missingTimes.length > 0 ? 'warning' : ''}">
                <h3>${conflicts.missingTimes.length}</h3>
                <p>Missing Times</p>
            </div>
            <div class="conflict-stat ${conflicts.unconfirmedShifts.length > 0 ? 'info' : ''}">
                <h3>${conflicts.unconfirmedShifts.length}</h3>
                <p>Unconfirmed Shifts</p>
            </div>
            <div class="conflict-stat ${conflicts.noPayRate.length > 0 ? 'warning' : ''}">
                <h3>${conflicts.noPayRate.length}</h3>
                <p>No Pay Rate</p>
            </div>
        </div>
    `;
    
    // Staff Double-Booking Section
    if (conflicts.staffDoubleBooking.length > 0) {
        html += `
            <div class="conflict-section">
                <h3>
                    <span style="color: var(--danger-color);"></span> 
                    Staff Double-Bookings (${conflicts.staffDoubleBooking.length})
                </h3>
        `;
        
        conflicts.staffDoubleBooking.forEach(conflict => {
            const staff = conflict.staff || {};
            const part1 = conflict.shift1.participant || {};
            const part2 = conflict.shift2.participant || {};
            
            html += `
                <div class="conflict-item">
                    <div class="conflict-details">
                        <strong>${staff.first_name} ${staff.last_name}</strong> - 
                        ${formatDateFriendly(conflict.date)}
                        <br>
                        <span style="color: var(--text-secondary);">
                            Shift 1: ${formatTime12Hour(conflict.shift1.start_time)} - ${formatTime12Hour(conflict.shift1.end_time)} 
                            (${part1.first_name || 'Unknown'} ${part1.last_name || ''})
                        </span>
                        <br>
                        <span style="color: var(--text-secondary);">
                            Shift 2: ${formatTime12Hour(conflict.shift2.start_time)} - ${formatTime12Hour(conflict.shift2.end_time)} 
                            (${part2.first_name || 'Unknown'} ${part2.last_name || ''})
                        </span>
                        <span class="overlap-visual">
                            Overlap: ${conflict.overlapPeriod.start} - ${conflict.overlapPeriod.end} (${conflict.overlapPeriod.hours}h)
                        </span>
                    </div>
                    <div class="conflict-actions">
                        <button class="btn btn-sm btn-outline" onclick="editShift(${conflict.shift1.id})">
                            Edit Shift 1
                        </button>
                        <button class="btn btn-sm btn-outline" onclick="editShift(${conflict.shift2.id})">
                            Edit Shift 2
                        </button>
                        <button class="btn btn-sm btn-danger" onclick="deleteShift(${conflict.shift2.id})">
                            Delete Shift 2
                        </button>
                    </div>
                </div>
            `;
        });
        
        html += '</div>';
    }
    
    // Sleepover Violations Section
    if (conflicts.sleepoverViolations.length > 0) {
        html += `
            <div class="conflict-section">
                <h3>
                    <span style="color: var(--danger-color);">⚠️</span>
                    Sleepover Violations (${conflicts.sleepoverViolations.length})
                </h3>
        `;
        
        conflicts.sleepoverViolations.forEach(conflict => {
            const staff = conflict.staff || {};
            
            html += `
                <div class="conflict-item">
                    <div class="conflict-details">
                        <strong>${staff.first_name} ${staff.last_name}</strong> - 
                        ${formatDateFriendly(conflict.date)}
                        <br>
                        <span style="color: var(--danger-color);">${conflict.reason}</span>
                        <br>
                        <span style="color: var(--text-secondary);">
                            Sleepover + ${formatTime12Hour(conflict.conflictingShift.start_time)} - 
                            ${formatTime12Hour(conflict.conflictingShift.end_time)}
                        </span>
                    </div>
                    <div class="conflict-actions">
                        <button class="btn btn-sm btn-outline" onclick="editShift(${conflict.conflictingShift.id})">
                            Reschedule Shift
                        </button>
                        <button class="btn btn-sm btn-danger" onclick="deleteShift(${conflict.sleepoverShift.id})">
                            Remove Sleepover
                        </button>
                    </div>
                </div>
            `;
        });
        
        html += '</div>';
    }
    
    // Excessive Hours Section
    if (conflicts.excessiveHours.length > 0) {
        html += `
            <div class="conflict-section">
                <h3>
                    <span style="color: var(--warning-color);">⏰</span>
                    Excessive Hours (${conflicts.excessiveHours.length})
                </h3>
        `;
        
        conflicts.excessiveHours.forEach(conflict => {
            const staff = conflict.staff || {};
            
            html += `
                <div class="conflict-item">
                    <div class="conflict-details">
                        <strong>${staff.first_name} ${staff.last_name}</strong>
                        <br>
                        Week of ${formatDateFriendly(conflict.weekStart.toISOString().split('T')[0])}
                        <br>
                        <span style="color: var(--warning-color);">
                            ${conflict.totalHours.toFixed(1)}h / ${conflict.limit}h limit 
                            (${conflict.excess.toFixed(1)}h over)
                        </span>
                    </div>
                    <div class="conflict-actions">
                        <button class="btn btn-sm btn-outline" 
                                onclick="viewStaffWeek('${staff.id}', '${conflict.weekStart.toISOString().split('T')[0]}')">
                            View Week
                        </button>
                        <button class="btn btn-sm btn-warning" 
                                onclick="redistributeHours('${staff.id}', '${conflict.weekStart.toISOString().split('T')[0]}')">
                            Redistribute
                        </button>
                    </div>
                </div>
            `;
        });
        
        html += '</div>';
    }
    
    // Missing Times Section
    if (conflicts.missingTimes.length > 0) {
        html += `
            <div class="conflict-section">
                <h3>
                    <span style="color: var(--warning-color);">🕐</span>
                    Missing Times (${conflicts.missingTimes.length})
                </h3>
        `;
        
        conflicts.missingTimes.forEach(conflict => {
            const staff = conflict.staff || {};
            const participant = conflict.participant || {};
            
            html += `
                <div class="conflict-item">
                    <div class="conflict-details">
                        <strong>${formatDateFriendly(conflict.date)}</strong> - 
                        ${staff.first_name} ${staff.last_name}
                        <br>
                        <span style="color: var(--text-secondary);">
                            ${participant.first_name || 'Unknown'} ${participant.last_name || ''}
                        </span>
                        <br>
                        <span style="color: var(--warning-color);">Missing: ${conflict.missing}</span>
                    </div>
                    <div class="conflict-actions">
                        <button class="btn btn-sm btn-primary" onclick="editShift(${conflict.shift.id})">
                            Add Times
                        </button>
                    </div>
                </div>
            `;
        });
        
        html += '</div>';
    }
    
    if (Object.values(conflicts).every(arr => arr.length === 0)) {
        html = `
            <div style="text-align: center; padding: 60px 20px;">
                <div style="font-size: 64px; margin-bottom: 16px;">✅</div>
                <h3>No Conflicts Found!</h3>
                <p style="color: var(--text-secondary);">All shifts are properly scheduled with no overlaps or violations.</p>
            </div>
        `;
    }
    
    conflictsContent.innerHTML = html;
}


// Export conflicts report
function exportConflictsReport() {
    // Similar to renderConflicts but generates CSV
    let csv = 'Type,Staff,Date,Details,Action Required\n';
    
    // Add all conflicts to CSV...
    // (implementation similar to above but formatted for CSV)
    
    downloadCSV(csv, `conflicts_report_${new Date().toISOString().split('T')[0]}.csv`);
    showNotification('Conflicts report exported', 'success');
}

// Call initialization when document is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeEnhancements);
} else {
    initializeEnhancements();
}

async function switchStaffView(staffId) {
    try {
        // Get the selected staff member
        const { data: selectedStaff, error } = await supabaseClient
            .from('staff')
            .select('*')
            .eq('id', staffId)
            .single();
        
        if (error) throw error;
        
        // Store the original if this is the first switch
        if (!window.originalStaffData) {
            window.originalStaffData = currentStaffData;
        }
        
        // Switch current staff context
        currentStaffData = selectedStaff;
        
        // Update the display
        document.getElementById('userName').textContent = 
            `${selectedStaff.first_name} ${selectedStaff.last_name}`;
        
        // Add indicator that we're in test mode
        if (!document.getElementById('testModeIndicator')) {
            const indicator = document.createElement('div');
            indicator.id = 'testModeIndicator';
            indicator.style.cssText = 'background: #ff9800; color: white; padding: 5px 10px; text-align: center; position: fixed; top: 0; left: 0; right: 0; z-index: 10000; font-size: 12px;';
            indicator.innerHTML = `
                ⚠️ TEST MODE - Viewing as: ${selectedStaff.first_name} ${selectedStaff.last_name} 
                <button onclick="resetToOriginalStaff()" style="margin-left: 10px; padding: 2px 8px; background: white; color: #333; border: none; border-radius: 3px; cursor: pointer;">Exit Test Mode</button>
            `;
            document.body.prepend(indicator);
        } else {
            document.getElementById('testModeIndicator').innerHTML = `
                ⚠️ TEST MODE - Viewing as: ${selectedStaff.first_name} ${selectedStaff.last_name}
                <button onclick="resetToOriginalStaff()" style="margin-left: 10px; padding: 2px 8px; background: white; color: #333; border: none; border-radius: 3px; cursor: pointer;">Exit Test Mode</button>
            `;
        }
        
        // Reload all data for this staff member
        await loadShifts();  // This will load shifts for currentStaffData
        
        // Refresh the current view
        renderCurrentView();
        
        showNotification(`Now viewing as: ${selectedStaff.first_name} ${selectedStaff.last_name}`, 'info');
        
    } catch (error) {
        console.error('Error switching staff view:', error);
        showNotification('Failed to switch staff view', 'error');
    }
}

// 2. Reset back to original staff
function resetToOriginalStaff() {
    if (window.originalStaffData) {
        currentStaffData = window.originalStaffData;
        delete window.originalStaffData;
        
        // Update display
        document.getElementById('userName').textContent = 
            `${currentStaffData.first_name} ${currentStaffData.last_name}`;
        
        // Remove test mode indicator
        const indicator = document.getElementById('testModeIndicator');
        if (indicator) indicator.remove();
        
        // Reload data
        loadShifts();
        renderCurrentView();
        
        showNotification('Returned to your normal view', 'success');
    }
}

// 3. Add a dropdown to the header for quick staff switching
function addStaffSwitcher() {
    // Only show for admin/manager roles
    if (currentUserRole !== 'admin' && currentUserRole !== 'manager') return;
    
    const switcherHTML = `
        <div id="staffSwitcher" style="display: inline-block; margin-left: 20px;">
            <select id="staffViewSelect" onchange="if(this.value) switchStaffView(this.value)" style="
                padding: 5px 10px;
                border: 1px solid #ddd;
                border-radius: 4px;
                background: white;
                cursor: pointer;
            ">
                <option value="">👤 View as Staff...</option>
                ${staff.map(s => `
                    <option value="${s.id}" ${currentStaffData?.id === s.id ? 'selected' : ''}>
                        ${s.first_name} ${s.last_name}
                    </option>
                `).join('')}
            </select>
        </div>
    `;
    
    // Add to header
    const userInfo = document.querySelector('.user-info');
    if (userInfo) {
        userInfo.insertAdjacentHTML('beforeend', switcherHTML);
    }
}

// 4. For team.html - similar but simpler
async function switchStaffViewTeam(staffId) {
    try {
        const { data: selectedStaff, error } = await supabaseClient
            .from('staff')
            .select('*')
            .eq('id', staffId)
            .single();
        
        if (error) throw error;
        
        // Store original
        if (!window.originalStaff) {
            window.originalStaff = currentStaff;
        }
        
        // Switch context
        currentStaff = selectedStaff;
        
        // Update display
        document.getElementById('userName').textContent = 
            `${selectedStaff.first_name} ${selectedStaff.last_name}`;
        
        // Add test mode banner
        if (!document.getElementById('testModeBanner')) {
            const banner = document.createElement('div');
            banner.id = 'testModeBanner';
            banner.style.cssText = 'background: orange; color: white; padding: 8px; text-align: center; position: fixed; top: 0; left: 0; right: 0; z-index: 9999;';
            banner.innerHTML = `
                Testing as: ${selectedStaff.first_name} ${selectedStaff.last_name}
                <button onclick="exitTestMode()" style="margin-left: 10px; padding: 2px 8px;">Exit</button>
            `;
            document.body.prepend(banner);
        }
        
        // Reload their data
        await loadDashboard();
        await loadSchedule();
        await loadTransfers();
        
        showToast(`Viewing as: ${selectedStaff.first_name} ${selectedStaff.last_name}`, 'info');
        
    } catch (error) {
        console.error('Error:', error);
        showToast('Failed to switch view', 'error');
    }
}


function showToast(message, type = 'info') {
    // Simple toast notification
    const toast = document.createElement('div');
    toast.className = `toast toast-${type}`;
    toast.textContent = message;
    toast.style.cssText = `
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 12px 20px;
        background: ${type === 'error' ? '#dc3545' : type === 'success' ? '#28a745' : '#17a2b8'};
        color: white;
        border-radius: 4px;
        z-index: 10000;
        animation: slideIn 0.3s ease;
    `;
    
    document.body.appendChild(toast);
    
    setTimeout(() => {
        toast.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => toast.remove(), 300);
    }, 3000);
}

//PARTICIPANT ROSTERING TEMPLATE CODE!
async function loadTemplates() {
    try {
        const { data: templates, error } = await supabaseClient
            .from('roster_templates')
            .select(`
                *,
                participant:participant_id(first_name, last_name),
                creator:created_by(first_name, last_name),
                roster_template_shifts(*)
            `)
            .eq('is_active', true)
            .order('created_at', { ascending: false });

        if (error) throw error;
        
        rosterTemplates = templates || [];
        renderTemplates();
    } catch (error) {
        console.error('Error loading templates:', error);
        showNotification('Failed to load templates', 'error');
    }
}

function renderTemplates() {
    const container = document.getElementById('templatesContent');
    if (!container) return;
    
    if (rosterTemplates.length === 0) {
        container.innerHTML = `
            <div style="text-align: center; padding: 40px; color: var(--text-light);">
                <h3>No templates created yet</h3>
                <p>Create your first roster template to get started with auto-rostering</p>
            </div>
        `;
        return;
    }
    
    container.innerHTML = rosterTemplates.map(template => `
        <div class="template-item" style="border: 1px solid var(--border-color); border-radius: 8px; padding: 16px; margin-bottom: 16px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                <div>
                    <h3 style="margin: 0; color: var(--text-primary);">${template.name}</h3>
                    <p style="margin: 4px 0; color: var(--text-muted); font-size: 14px;">
                        ${template.participant ? `For: ${template.participant.first_name} ${template.participant.last_name}` : 'General Template'}
                    </p>
                    ${template.description ? `<p style="margin: 4px 0; color: var(--text-secondary); font-size: 14px;">${template.description}</p>` : ''}
                </div>
                <div style="display: flex; gap: 8px;">
                    <button class="btn btn-primary btn-sm" onclick="applyTemplate('${template.id}')">
                        Apply Template
                    </button>
                    <button class="btn btn-outline btn-sm" onclick="editTemplate('${template.id}')">
                        Edit
                    </button>
                    <button class="btn btn-outline btn-sm" onclick="duplicateTemplate('${template.id}')">
                        Duplicate
                    </button>
                    <button class="btn btn-danger btn-sm" onclick="deleteTemplate('${template.id}')">
                        Delete
                    </button>
                </div>
            </div>
            <div style="margin-top: 12px;">
                ${renderTemplateWeekPreview(template)}
            </div>
        </div>
    `).join('');
}

function uiDayToDbDay(uiDay) {
    // UI: 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat, 7=Sun
    // DB: 0=Sun, 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat
    if (uiDay === 7) return 0; // Sunday
    return uiDay; // Monday-Saturday map directly
}

// Helper function to convert DB day (0-6, Sun-Sat) to UI day (1-7, Mon-Sun)
function dbDayToUiDay(dbDay) {
    if (dbDay === 0) return 7; // Sunday
    return dbDay; // Monday-Saturday map directly
}


function renderTemplateWeekPreview(template) {
    const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    const shifts = template.roster_template_shifts || [];
    
    let preview = '<div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 8px; margin-top: 12px;">';
    
    days.forEach((day, index) => {
        const uiDay = index + 1; // 1-7 for Mon-Sun
        const dbDay = uiDayToDbDay(uiDay);
        const dayShifts = shifts.filter(s => s.day_of_week === dbDay);
        const isWeekend = index >= 5;
        
        preview += `
            <div style="background: ${isWeekend ? '#f8f9fa' : 'white'}; border: 1px solid var(--border-light); border-radius: 4px; padding: 8px;">
                <div style="font-weight: 600; font-size: 12px; margin-bottom: 4px; color: var(--text-muted);">${day}</div>
                ${dayShifts.length > 0 ? 
                    dayShifts.map(shift => `
                        <div style="background: var(--primary-color); color: white; padding: 2px 4px; border-radius: 2px; font-size: 11px; margin-bottom: 2px;">
                            ${shift.start_time ? formatTime(shift.start_time) : 'Sleepover'}-${shift.end_time ? formatTime(shift.end_time) : ''}
                        </div>
                    `).join('') : 
                    '<div style="color: var(--text-light); font-size: 11px;">No shifts</div>'
                }
            </div>
        `;
    });
    
    preview += '</div>';
    return preview;
}

function openCreateTemplateModal() {
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.style.display = 'flex';
    modal.innerHTML = `
        <div class="modal" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
            <header class="modal-header">
                <h3 class="modal-title">Create Roster Template</h3>
                <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">&times;</button>
            </header>
            <div class="modal-content">
                <div class="form-group">
                    <label>Template Name *</label>
                    <input type="text" id="templateName" class="form-control" placeholder="e.g., John's Weekly Schedule">
                </div>
                
                <div class="form-group">
                    <label>Participant</label>
                    <select id="templateParticipant" class="form-control">
                        <option value="">General Template (No specific participant)</option>
                        ${participants.map(p => `<option value="${p.id}">${p.first_name} ${p.last_name}</option>`).join('')}
                    </select>
                </div>
                
                <div class="form-group">
                    <label>Description</label>
                    <textarea id="templateDescription" class="form-control" rows="2" placeholder="Optional description"></textarea>
                </div>
                
                <h4 style="margin-top: 24px; margin-bottom: 16px;">Weekly Schedule</h4>
                <div id="templateWeekSchedule">
                    ${generateWeekScheduleBuilder()}
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
                <button class="btn btn-primary" onclick="saveTemplate()">Create Template</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
}

function generateWeekScheduleBuilder() {
    const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
    let html = '<div style="display: grid; gap: 16px;">';
    
    days.forEach((day, index) => {
        html += `
            <div style="border: 1px solid var(--border-color); border-radius: 8px; padding: 12px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <h5 style="margin: 0; color: var(--text-primary);">${day}</h5>
                    <button class="btn btn-outline btn-sm" onclick="duplicateDay(${index + 1})" title="Copy ${day}'s shifts to other days">
                        📋 Copy Day
                    </button>
                </div>
                <div id="day_${index + 1}_shifts">
                    <!-- Shifts for this day will be added here -->
                </div>
                <button class="btn btn-outline btn-sm" style="margin-top: 8px;" onclick="addShiftToDay(${index + 1})">
                    + Add Shift
                </button>
            </div>
        `;
    });
    
    html += '</div>';
    return html;
}

// ADD this new function for duplicating a day's shifts:
function duplicateDay(sourceDayOfWeek) {
    const days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
    const sourceDay = days[sourceDayOfWeek - 1];
    
    // Create modal for selecting target days
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.style.display = 'flex';
    modal.style.zIndex = '10000'; // Higher z-index since it's a modal over a modal
    modal.innerHTML = `
        <div class="modal" style="max-width: 400px;">
            <header class="modal-header">
                <h3 class="modal-title">Copy ${sourceDay}'s Shifts</h3>
                <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">&times;</button>
            </header>
            <div class="modal-content">
                <p style="margin-bottom: 16px;">Select which days to copy ${sourceDay}'s shifts to:</p>
                <div style="display: grid; gap: 8px;">
                    ${days.map((day, index) => {
                        const dayNum = index + 1;
                        if (dayNum === sourceDayOfWeek) return ''; // Skip source day
                        return `
                            <label style="display: flex; align-items: center; padding: 8px; border: 1px solid var(--border-light); border-radius: 4px; cursor: pointer;">
                                <input type="checkbox" value="${dayNum}" style="margin-right: 8px;">
                                ${day}
                            </label>
                        `;
                    }).join('')}
                </div>
                <div style="margin-top: 16px;">
                    <label style="display: flex; align-items: center;">
                        <input type="checkbox" id="clearExisting" style="margin-right: 8px;">
                        Clear existing shifts on target days
                    </label>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
                <button class="btn btn-primary" onclick="executeDayDuplication(${sourceDayOfWeek}, this)">Copy Shifts</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
}

// ADD this function to execute the day duplication:
function executeDayDuplication(sourceDayOfWeek, button) {
    const modal = button.closest('.modal-overlay');
    const checkboxes = modal.querySelectorAll('input[type="checkbox"]:not(#clearExisting):checked');
    const clearExisting = modal.querySelector('#clearExisting').checked;
    
    if (checkboxes.length === 0) {
        showNotification('Please select at least one day to copy to', 'warning');
        return;
    }
    
    // Get source day shifts
    const sourceContainer = document.getElementById(`day_${sourceDayOfWeek}_shifts`);
    const sourceShifts = sourceContainer.querySelectorAll('[id^="shift_"]');
    
    if (sourceShifts.length === 0) {
        showNotification('No shifts to copy', 'warning');
        modal.remove();
        return;
    }
    
    // Copy to each selected day
    checkboxes.forEach(checkbox => {
        const targetDay = parseInt(checkbox.value);
        const targetContainer = document.getElementById(`day_${targetDay}_shifts`);
        
        // Clear existing shifts if requested
        if (clearExisting) {
            targetContainer.innerHTML = '';
        }
        
        // Copy each shift
        sourceShifts.forEach(sourceShift => {
            // Add new shift to target day
            addShiftToDay(targetDay);
            
            // Get the last added shift (the new one)
            const targetShifts = targetContainer.querySelectorAll('[id^="shift_"]');
            const newShift = targetShifts[targetShifts.length - 1];
            
            // Copy values
            const fields = ['start_time', 'end_time', 'staff_id', 'duty_type_id', 'location_id'];
            fields.forEach(field => {
                const sourceValue = sourceShift.querySelector(`[data-field="${field}"]`).value;
                newShift.querySelector(`[data-field="${field}"]`).value = sourceValue;
            });
        });
    });
    
    showNotification('Shifts copied successfully', 'success');
    modal.remove();
}


function addShiftToDay(dayOfWeek) {
    const container = document.getElementById(`day_${dayOfWeek}_shifts`);
    const shiftId = `shift_${dayOfWeek}_${Date.now()}`;
    
    const shiftHtml = `
        <div id="${shiftId}" style="background: var(--bg-light); padding: 12px; border-radius: 4px; margin-bottom: 8px;">
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px;">
                <div>
                    <label style="font-size: 12px;">Start Time</label>
                    <input type="time" class="form-control" data-field="start_time">
                </div>
                <div>
                    <label style="font-size: 12px;">End Time</label>
                    <input type="time" class="form-control" data-field="end_time">
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px;">
                <div>
                    <label style="font-size: 12px;">Staff Member</label>
                    <select class="form-control" data-field="staff_id">
                        <option value="">Unassigned</option>
                        ${staff.map(s => `<option value="${s.id}">${s.first_name} ${s.last_name}</option>`).join('')}
                    </select>
                </div>
                <div>
                    <label style="font-size: 12px;">Duty Type</label>
                    <select class="form-control" data-field="duty_type_id">
                        <option value="">Standard</option>
                        ${dutyTypes.map(dt => `<option value="${dt.id}">${dt.name}</option>`).join('')}
                    </select>
                </div>
            </div>
            
            <div style="margin-bottom: 8px;">
                <label style="font-size: 12px;">Location</label>
                <select class="form-control" data-field="location_id">
                    <option value="">Client Home</option>
                    ${locations.map(l => `<option value="${l.id}">${l.name}</option>`).join('')}
                </select>
            </div>
            
            <button class="btn btn-danger btn-sm" onclick="document.getElementById('${shiftId}').remove()">
                Remove Shift
            </button>
        </div>
    `;
    
    container.insertAdjacentHTML('beforeend', shiftHtml);
}

async function saveTemplate() {
    try {
        const name = document.getElementById('templateName').value;
        const participantId = document.getElementById('templateParticipant').value;
        const description = document.getElementById('templateDescription').value;
        
        if (!name) {
            showNotification('Please enter a template name', 'warning');
            return;
        }
        
        const { data: template, error: templateError } = await supabaseClient
            .from('roster_templates')
            .insert({
                name: name,
                participant_id: participantId || null,
                description: description || null,
                created_by: currentStaffData?.id || null,
                is_active: true
            })
            .select()
            .single();
        
        if (templateError) throw templateError;
        
        const shiftsToInsert = [];
        for (let uiDay = 1; uiDay <= 7; uiDay++) {
            const dayContainer = document.getElementById(`day_${uiDay}_shifts`);
            const shiftElements = dayContainer.querySelectorAll('[id^="shift_"]');
            
            shiftElements.forEach(shiftEl => {
                const startTime = shiftEl.querySelector('[data-field="start_time"]').value;
                const endTime = shiftEl.querySelector('[data-field="end_time"]').value;
                const staffId = shiftEl.querySelector('[data-field="staff_id"]').value;
                const dutyTypeId = shiftEl.querySelector('[data-field="duty_type_id"]').value;
                const locationId = shiftEl.querySelector('[data-field="location_id"]').value;
                
                if (startTime || endTime) {
                    shiftsToInsert.push({
                        template_id: template.id,
                        day_of_week: uiDayToDbDay(uiDay), // Use conversion helper
                        start_time: startTime || null,
                        end_time: endTime || null,
                        staff_id: staffId || null,
                        duty_type_id: dutyTypeId || null,
                        location_id: locationId || null
                    });
                }
            });
        }
        
        if (shiftsToInsert.length > 0) {
            const { error: shiftsError } = await supabaseClient
                .from('roster_template_shifts')
                .insert(shiftsToInsert);
            
            if (shiftsError) throw shiftsError;
        }
        
        showNotification('Template created successfully', 'success');
        document.querySelector('.modal-overlay').remove();
        loadTemplates();
        
    } catch (error) {
        console.error('Error saving template:', error);
        showNotification('Failed to save template', 'error');
    }
}

function applyTemplate(templateId) {
    const template = rosterTemplates.find(t => t.id === templateId);
    if (!template) return;
    
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.style.display = 'flex';
    modal.innerHTML = `
        <div class="modal" style="max-width: 500px;">
            <header class="modal-header">
                <h3 class="modal-title">Apply Template: ${template.name}</h3>
                <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">&times;</button>
            </header>
            <div class="modal-content">
                <div class="form-group">
                    <label>Start Date *</label>
                    <input type="date" id="applyStartDate" class="form-control" value="${new Date().toISOString().split('T')[0]}">
                </div>
                
                <div class="form-group">
                    <label>End Date *</label>
                    <input type="date" id="applyEndDate" class="form-control" value="${new Date(Date.now() + 7*24*60*60*1000).toISOString().split('T')[0]}">
                </div>
                
                <div class="form-group">
                    <label>Apply To Participant</label>
                    <select id="applyParticipant" class="form-control">
                        ${template.participant_id ? 
                            `<option value="${template.participant_id}" selected>${template.participant.first_name} ${template.participant.last_name}</option>` :
                            `<option value="">Select Participant</option>`
                        }
                        ${participants.filter(p => p.id !== template.participant_id).map(p => 
                            `<option value="${p.id}">${p.first_name} ${p.last_name}</option>`
                        ).join('')}
                    </select>
                </div>
                
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="skipExisting" checked>
                        Skip dates that already have shifts
                    </label>
                </div>
                
                <div class="alert alert-info" style="margin-top: 16px;">
                    This will create shifts based on the template pattern for the selected date range.
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
                <button class="btn btn-primary" onclick="executeTemplateApplication('${templateId}')">Apply Template</button>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
}

async function executeTemplateApplication(templateId) {
    try {
        const template = rosterTemplates.find(t => t.id === templateId);
        if (!template) throw new Error('Template not found');
        
        const startDate = new Date(document.getElementById('applyStartDate').value);
        const endDate = new Date(document.getElementById('applyEndDate').value);
        const participantId = document.getElementById('applyParticipant').value;
        const skipExisting = document.getElementById('skipExisting').checked;
        
        if (!participantId) {
            showNotification('Please select a participant', 'warning');
            return;
        }
        
        const shiftsToCreate = [];
        const currentDate = new Date(startDate);
        
        // Iterate through each day in the range
        while (currentDate <= endDate) {
            const dayOfWeek = currentDate.getDay(); // This returns 0-6 (Sunday=0)
            const dateStr = currentDate.toISOString().split('T')[0];
            
            // Check if shifts already exist for this date if skipExisting is true
            if (skipExisting) {
                const { data: existing } = await supabaseClient
                    .from('shifts')
                    .select('id')
                    .eq('participant_id', participantId)
                    .eq('date', dateStr)
                    .limit(1);
                
                if (existing && existing.length > 0) {
                    currentDate.setDate(currentDate.getDate() + 1);
                    continue;
                }
            }
            
            // Find template shifts for this day of week
            // FIXED: dayOfWeek is already 0-6, matching the database
            const dayShifts = template.roster_template_shifts.filter(s => s.day_of_week === dayOfWeek);
            
            dayShifts.forEach(shift => {
                shiftsToCreate.push({
                    date: dateStr,
                    participant_id: participantId,
                    staff_id: shift.staff_id,
                    start_time: shift.start_time,
                    end_time: shift.end_time,
                    duty_type_id: shift.duty_type_id,
                    location_id: shift.location_id,
                    status: 'pending',
                    created_at: new Date().toISOString()
                });
            });
            
            currentDate.setDate(currentDate.getDate() + 1);
        }
        
        // Insert all shifts
        if (shiftsToCreate.length > 0) {
            const { error } = await supabaseClient
                .from('shifts')
                .insert(shiftsToCreate);
            
            if (error) throw error;
            
            showNotification(`Created ${shiftsToCreate.length} shifts from template`, 'success');
        } else {
            showNotification('No shifts to create', 'info');
        }
        
        document.querySelector('.modal-overlay').remove();
        loadShifts(); // Refresh the main shifts view
        
    } catch (error) {
        console.error('Error applying template:', error);
        showNotification('Failed to apply template', 'error');
    }
}



async function editTemplate(templateId) {
    const template = rosterTemplates.find(t => t.id === templateId);
    if (!template) return;
    
    openCreateTemplateModal();
    
    setTimeout(() => {
        document.getElementById('templateName').value = template.name;
        document.getElementById('templateParticipant').value = template.participant_id || '';
        document.getElementById('templateDescription').value = template.description || '';
        
        // Populate existing shifts with proper day conversion
        template.roster_template_shifts.forEach(shift => {
            const uiDay = dbDayToUiDay(shift.day_of_week);
            addShiftToDay(uiDay);
            
            const dayContainer = document.getElementById(`day_${uiDay}_shifts`);
            const lastShift = dayContainer.lastElementChild;
            if (lastShift) {
                lastShift.querySelector('[data-field="start_time"]').value = shift.start_time || '';
                lastShift.querySelector('[data-field="end_time"]').value = shift.end_time || '';
                lastShift.querySelector('[data-field="staff_id"]').value = shift.staff_id || '';
                lastShift.querySelector('[data-field="duty_type_id"]').value = shift.duty_type_id || '';
                lastShift.querySelector('[data-field="location_id"]').value = shift.location_id || '';
            }
        });
        
        const saveBtn = document.querySelector('.modal-footer .btn-primary');
        saveBtn.textContent = 'Update Template';
        saveBtn.onclick = () => updateTemplate(templateId);
    }, 100);
}

async function updateTemplate(templateId) {
    try {
        const name = document.getElementById('templateName').value;
        const participantId = document.getElementById('templateParticipant').value;
        const description = document.getElementById('templateDescription').value;
        
        // Update template
        const { error: updateError } = await supabaseClient
            .from('roster_templates')
            .update({
                name: name,
                participant_id: participantId || null,
                description: description || null,
                updated_at: new Date().toISOString()
            })
            .eq('id', templateId);
        
        if (updateError) throw updateError;
        
        // Delete existing shifts and recreate
        await supabaseClient
            .from('roster_template_shifts')
            .delete()
            .eq('template_id', templateId);
        
        // Recreate shifts (same as save)
        const shiftsToInsert = [];
        for (let day = 1; day <= 7; day++) {
            const dayContainer = document.getElementById(`day_${day}_shifts`);
            const shiftElements = dayContainer.querySelectorAll('[id^="shift_"]');
            
            shiftElements.forEach(shiftEl => {
                const startTime = shiftEl.querySelector('[data-field="start_time"]').value;
                const endTime = shiftEl.querySelector('[data-field="end_time"]').value;
                const staffId = shiftEl.querySelector('[data-field="staff_id"]').value;
                const dutyTypeId = shiftEl.querySelector('[data-field="duty_type_id"]').value;
                const locationId = shiftEl.querySelector('[data-field="location_id"]').value;
                
                if (startTime || endTime) {
                    shiftsToInsert.push({
                        template_id: templateId,
                        day_of_week: day - 1, // FIXED: Convert 1-7 to 0-6
                        start_time: startTime || null,
                        end_time: endTime || null,
                        staff_id: staffId || null,
                        duty_type_id: dutyTypeId || null,
                        location_id: locationId || null
                    });
                }
            });
        }
        
        if (shiftsToInsert.length > 0) {
            const { error: shiftsError } = await supabaseClient
                .from('roster_template_shifts')
                .insert(shiftsToInsert);
            
            if (shiftsError) throw shiftsError;
        }
        
        showNotification('Template updated successfully', 'success');
        document.querySelector('.modal-overlay').remove();
        loadTemplates();
        
    } catch (error) {
        console.error('Error updating template:', error);
        showNotification('Failed to update template', 'error');
    }
}

async function confirmTemplateApplication(templateId) {
    try {
        const template = rosterTemplates.find(t => t.id === templateId);
        if (!template) throw new Error('Template not found');
        
        const startDate = document.getElementById('applyStartDate').value;
        const endDate = document.getElementById('applyEndDate').value;
        const participantId = document.getElementById('applyParticipant').value;
        
        if (!startDate || !endDate) {
            showNotification('Please select date range', 'warning');
            return;
        }
        
        // Generate shifts for date range
        const shiftsToCreate = [];
        const current = new Date(startDate);
        const end = new Date(endDate);
        
        while (current <= end) {
            const dayOfWeek = current.getDay(); // 0-6 (0=Sunday)
            const dayShifts = template.roster_template_shifts.filter(s => s.day_of_week === dayOfWeek);
            
            for (const templateShift of dayShifts) {
                // GET THE STAFF'S PAY RATE - THIS IS CRITICAL!
                let payRateId = null;
                
                if (templateShift.staff_id) {
                    const templateStaff = staff.find(s => s.id === templateShift.staff_id);
                    payRateId = templateStaff?.pay_rate_id;
                }
                
                // If no staff or no pay rate, use default
                if (!payRateId) {
                    payRateId = '00000000-0000-0000-0000-000000000002'; // Default pay rate UUID
                }
                
                shiftsToCreate.push({
                    date: current.toISOString().split('T')[0],
                    start_time: templateShift.start_time,
                    end_time: templateShift.end_time,
                    staff_id: templateShift.staff_id,
                    participant_id: participantId || template.participant_id,
                    location_id: templateShift.location_id,
                    duty_type_id: templateShift.duty_type_id,
                    pay_override_id: payRateId, // THIS WAS MISSING! NOW FIXED!
                    status: 'scheduled',
                    created_by: currentStaffData?.id || currentUser.id,
                    notes: templateShift.notes
                });
            }
            
            current.setDate(current.getDate() + 1);
        }
        
        if (shiftsToCreate.length === 0) {
            showNotification('No shifts to create from template', 'warning');
            return;
        }
        
        // Insert all shifts
        const { error } = await supabaseClient
            .from('shifts')
            .insert(shiftsToCreate);
        
        if (error) throw error;
        
        showNotification(`Created ${shiftsToCreate.length} shifts from template`, 'success');
        document.querySelector('.modal-overlay').remove();
        await loadShifts();
        
    } catch (error) {
        console.error('Error applying template:', error);
        showNotification('Failed to apply template: ' + error.message, 'error');
    }
}
function getCurrentStaffPayRate(staffId) {
    if (!staffId) return '00000000-0000-0000-0000-000000000002'; // Default UUID
    
    const staffMember = staff.find(s => s.id === staffId);
    if (!staffMember || !staffMember.pay_rate_id) {
        return '00000000-0000-0000-0000-000000000002'; // Default UUID
    }
    
    return staffMember.pay_rate_id;
}
async function deleteTemplate(templateId) {
    if (!confirm('Are you sure you want to delete this template? This cannot be undone.')) {
        return;
    }
    
    try {
        // This will cascade delete all related roster_template_shifts due to ON DELETE CASCADE
        const { error } = await supabaseClient
            .from('roster_templates')
            .delete()
            .eq('id', templateId);
        
        if (error) throw error;
        
        showNotification('Template deleted successfully', 'success');
        loadTemplates();
        
    } catch (error) {
        console.error('Error deleting template:', error);
        showNotification('Failed to delete template', 'error');
    }
}

async function duplicateTemplate(templateId) {
    try {
        const template = rosterTemplates.find(t => t.id === templateId);
        if (!template) return;
        
        // Create modal for duplicate options
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.style.display = 'flex';
        modal.innerHTML = `
            <div class="modal" style="max-width: 500px;">
                <header class="modal-header">
                    <h3 class="modal-title">Duplicate Template</h3>
                    <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">&times;</button>
                </header>
                <div class="modal-content">
                    <div class="form-group">
                        <label>New Template Name *</label>
                        <input type="text" id="duplicateName" class="form-control" 
                               value="${template.name} (Copy)" 
                               placeholder="Enter name for the duplicated template">
                    </div>
                    
                    <div class="form-group">
                        <label>Assign to Different Participant?</label>
                        <select id="duplicateParticipant" class="form-control">
                            <option value="${template.participant_id || ''}">
                                ${template.participant_id ? 
                                    `Keep same (${template.participant?.first_name} ${template.participant?.last_name})` : 
                                    'Keep as general template'}
                            </option>
                            <option value="">General Template (No specific participant)</option>
                            ${participants.map(p => 
                                `<option value="${p.id}">${p.first_name} ${p.last_name}</option>`
                            ).join('')}
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="duplicateModifyShifts">
                            Modify shifts after duplication
                        </label>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-outline" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
                    <button class="btn btn-primary" onclick="executeDuplicateTemplate('${templateId}', this)">
                        Create Duplicate
                    </button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        
    } catch (error) {
        console.error('Error in duplicateTemplate:', error);
        showNotification('Failed to duplicate template', 'error');
    }
}

// ADD this function to execute the template duplication:
async function executeDuplicateTemplate(templateId, button) {
    try {
        const modal = button.closest('.modal-overlay');
        const template = rosterTemplates.find(t => t.id === templateId);
        if (!template) throw new Error('Template not found');
        
        const newName = document.getElementById('duplicateName').value;
        const newParticipantId = document.getElementById('duplicateParticipant').value;
        const modifyAfter = document.getElementById('duplicateModifyShifts').checked;
        
        if (!newName) {
            showNotification('Please enter a name for the duplicated template', 'warning');
            return;
        }
        
        // Create a copy of the template
        const { data: newTemplate, error: templateError } = await supabaseClient
            .from('roster_templates')
            .insert({
                name: newName,
                participant_id: newParticipantId || null,
                description: template.description,
                created_by: currentStaffData?.id || null,
                is_active: true
            })
            .select()
            .single();
        
        if (templateError) throw templateError;
        
        // Copy all shifts
        const shiftsToInsert = template.roster_template_shifts.map(shift => ({
            template_id: newTemplate.id,
            day_of_week: shift.day_of_week,
            start_time: shift.start_time,
            end_time: shift.end_time,
            staff_id: shift.staff_id,
            duty_type_id: shift.duty_type_id,
            location_id: shift.location_id
        }));
        
        if (shiftsToInsert.length > 0) {
            const { error: shiftsError } = await supabaseClient
                .from('roster_template_shifts')
                .insert(shiftsToInsert);
            
            if (shiftsError) throw shiftsError;
        }
        
        showNotification('Template duplicated successfully', 'success');
        modal.remove();
        
        // If user wants to modify, open edit modal
        if (modifyAfter) {
            setTimeout(() => {
                editTemplate(newTemplate.id);
            }, 500);
        }
        
        loadTemplates();
        
    } catch (error) {
        console.error('Error duplicating template:', error);
        showNotification('Failed to duplicate template', 'error');
    }
}

// ADD this shortcut function to quickly duplicate entire weeks:
function addQuickActions() {
    // Add this to your template creation modal header
    const modalContent = document.querySelector('.modal-content');
    if (modalContent && document.getElementById('templateWeekSchedule')) {
        const quickActions = document.createElement('div');
        quickActions.style.cssText = 'margin-bottom: 16px; padding: 12px; background: var(--bg-light); border-radius: 8px;';
        quickActions.innerHTML = `
            <div style="display: flex; gap: 8px; align-items: center;">
                <span style="font-weight: 600; margin-right: 8px;">Quick Actions:</span>
                <button class="btn btn-outline btn-sm" onclick="copyWeekdaysToAll()">
                    Copy Monday to all weekdays
                </button>
                <button class="btn btn-outline btn-sm" onclick="clearAllDays()">
                    Clear all days
                </button>
                <button class="btn btn-outline btn-sm" onclick="loadSampleTemplate()">
                    Load sample schedule
                </button>
            </div>
        `;
        const scheduleElement = document.getElementById('templateWeekSchedule');
        scheduleElement.parentNode.insertBefore(quickActions, scheduleElement);
    }
}

// Helper functions for quick actions:
function copyWeekdaysToAll() {
    // Copy Monday's shifts to Tuesday-Friday
    const mondayContainer = document.getElementById('day_1_shifts');
    const mondayShifts = mondayContainer.querySelectorAll('[id^="shift_"]');
    
    if (mondayShifts.length === 0) {
        showNotification('No shifts on Monday to copy', 'warning');
        return;
    }
    
    // Copy to weekdays only (2-5 = Tue-Fri)
    for (let day = 2; day <= 5; day++) {
        const targetContainer = document.getElementById(`day_${day}_shifts`);
        targetContainer.innerHTML = ''; // Clear existing
        
        mondayShifts.forEach(sourceShift => {
            addShiftToDay(day);
            const targetShifts = targetContainer.querySelectorAll('[id^="shift_"]');
            const newShift = targetShifts[targetShifts.length - 1];
            
            // Copy values
            ['start_time', 'end_time', 'staff_id', 'duty_type_id', 'location_id'].forEach(field => {
                const sourceValue = sourceShift.querySelector(`[data-field="${field}"]`).value;
                newShift.querySelector(`[data-field="${field}"]`).value = sourceValue;
            });
        });
    }
    
    showNotification('Monday shifts copied to all weekdays', 'success');
}

function loadSampleTemplate() {
    // Load a sample morning/evening shift pattern
    const sampleShifts = [
        { days: [1,2,3,4,5], start: '07:00', end: '15:00' }, // Weekday morning
        { days: [1,2,3,4,5], start: '15:00', end: '23:00' }, // Weekday evening
        { days: [6,7], start: '09:00', end: '21:00' } // Weekend
    ];
    
    // Clear existing
    for (let day = 1; day <= 7; day++) {
        document.getElementById(`day_${day}_shifts`).innerHTML = '';
    }
    
    // Add sample shifts
    sampleShifts.forEach(shift => {
        shift.days.forEach(day => {
            addShiftToDay(day);
            const container = document.getElementById(`day_${day}_shifts`);
            const lastShift = container.lastElementChild;
            lastShift.querySelector('[data-field="start_time"]').value = shift.start;
            lastShift.querySelector('[data-field="end_time"]').value = shift.end;
        });
    });
    
    showNotification('Sample schedule loaded', 'success');
}

function clearAllDays() {
    if (!confirm('Clear all shifts from all days?')) return;
    
    for (let day = 1; day <= 7; day++) {
        document.getElementById(`day_${day}_shifts`).innerHTML = '';
    }
    showNotification('All days cleared', 'success');
}

// 7. INITIALIZE ON LOAD:
// Add this to your DOMContentLoaded or initialization function
document.addEventListener('DOMContentLoaded', async () => {
    // Your existing initialization...
    
    // Add templates view if it doesn't exist
    if (!document.getElementById('templatesView')) {
        const mainContent = document.querySelector('.main-content') || document.body;
        mainContent.insertAdjacentHTML('beforeend', rosterTemplatesHTML);
    }
});

// 5. Add to initialization in mc-manager.html
// After loading staff data in initializeApp(), add:
if (currentUserRole === 'admin' || currentUserRole === 'manager') {
    // Add the staff switcher after staff data is loaded
    setTimeout(() => addStaffSwitcher(), 100);
}

// 6. Quick keyboard shortcut for switching (optional)
document.addEventListener('keydown', function(e) {
    // Alt+S to open staff switcher
    if (e.altKey && e.key === 's') {
        e.preventDefault();
        const select = document.getElementById('staffViewSelect');
        if (select) select.focus();
    }
    
    // Escape to exit test mode
    if (e.key === 'Escape' && window.originalStaffData) {
        resetToOriginalStaff();
    }
});
    </script>
</body>
</html>

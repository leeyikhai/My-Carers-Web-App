<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MC Manager - Complete System</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <title>My Carers</title>
  
    <!-- favicon links -->
    <link rel="icon" type="image/png" sizes="16x16" href="https://gqchhsayqxttewthcsah.supabase.co/storage/v1/object/public/Branding/mc-favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://gqchhsayqxttewthcsah.supabase.co/storage/v1/object/public/Branding/mc-favicon-32x32.png">

    <style>

      
        :root {
          

          /* Add to your existing styles */
@media (max-width: 768px) {
    /* Header adjustments */
    .header-content {
        flex-direction: column;
        padding: 12px;
        gap: 8px;
    }
    
    /* View toggle stack vertically */
    .view-toggle {
        flex-direction: column;
        width: 100%;
    }
    
    .view-toggle button {
        width: 100%;
        padding: 12px;
    }
    
    /* Table responsive */
    .roster-table {
        font-size: 11px;
    }
    
    .roster-table th,
    .roster-table td {
        padding: 8px 4px;
    }
    
    /* Hide less important columns on mobile */
    .roster-table th:nth-child(5),
    .roster-table td:nth-child(5) {
        display: none; /* Hide location column */
    }
    
    /* Timesheet responsive */
    .timesheet-table {
        font-size: 11px;
    }
    
    .timesheet-table th,
    .timesheet-table td {
        padding: 8px 4px;
    }
    
    /* Stack hour breakdown vertically */
    .hour-breakdown-item {
        display: block;
        margin-bottom: 4px;
    }
    
    /* Modal full screen on mobile */
    .modal {
        max-width: 100%;
        width: 100%;
        height: 100vh;
        border-radius: 0;
    }
    
    /* Filters stack vertically */
    .filter-row {
        grid-template-columns: 1fr;
    }
    
    /* Week navigation stack */
    .week-nav {
        flex-direction: column;
        gap: 12px;
    }
    
    .week-nav button {
        width: 100%;
    }
    
    /* Cards full width */
    .card {
        margin: 8px;
    }
    
    /* Request items stack content */
    .request-item {
        font-size: 13px;
    }
    
    .request-actions {
        flex-direction: column;
    }
    
    .request-actions .btn {
        width: 100%;
    }
    
    /* Summary cards stack */
    .summary-grid {
        grid-template-columns: 1fr;
    }
    
    /* Availability grid smaller */
    .availability-grid {
        font-size: 10px;
        grid-template-columns: 80px repeat(7, 1fr);
    }
    
    .availability-cell {
        padding: 6px;
        min-height: 35px;
    }
}

@media (max-width: 480px) {
    /* Even smaller screens */
    .roster-table {
        font-size: 10px;
    }
    
    /* Show only essential columns */
    .roster-table th:nth-child(6),
    .roster-table td:nth-child(6) {
        display: none; /* Hide duty type */
    }
    
    /* Compact timesheet */
    .timesheet-wrapper {
        margin: 0;
        border-radius: 0;
    }
    
    /* Smaller buttons */
    .btn {
        padding: 6px 12px;
        font-size: 12px;
    }
    
    .btn-sm {
        padding: 4px 8px;
        font-size: 11px;
    }
}
            --primary-color: #004990;
            --primary-hover: #003d75;
            --success-color: #88a542;
            --success-hover: #7a9339;
            --info-color: #359dca;
            --info-hover: #2e8bb5;
            --warning-color: #f39c12;
            --warning-hover: #e67e22;
            --danger-color: #e74c3c;
            --danger-hover: #c0392b;
            
            --text-primary: #2c3e50;
            --text-secondary: #34495e;
            --text-muted: #7f8c8d;
            --text-light: #95a5a6;
            
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-light: #ecf0f1;
            
            --border-color: #bdc3c7;
            --border-light: #ecf0f1;
            
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.1);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 15px rgba(0,0,0,0.1);
            
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 12px;
            
            --transition: all 0.2s ease-in-out;
            --font-size-xs: 0.75rem;
            --font-size-sm: 0.875rem;
            --font-size-base: 1rem;
            --font-size-lg: 1.125rem;
            --font-size-xl: 1.25rem;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            line-height: 1.6;
            font-size: var(--font-size-base);
        }

        /* Header Styles */
        .header {
            background: var(--bg-primary);
            box-shadow: var(--shadow-sm);
            position: sticky;
            top: 0;
            z-index: 1000;
            border-bottom: 1px solid var(--border-light);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 64px;
        }

        .logo {
            font-size: var(--font-size-xl);
            font-weight: 700;
            color: var(--primary-color);
            letter-spacing: -0.5px;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .user-name {
            font-weight: 500;
            color: var(--text-secondary);
            font-size: var(--font-size-base);
        }

        .user-role {
            background: var(--primary-color);
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: var(--font-size-xs);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Container */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 24px;
        }

        /* Button System */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 8px 16px;
            border: none;
            border-radius: var(--radius-md);
            font-size: var(--font-size-sm);
            font-weight: 500;
            line-height: 1.4;
            cursor: pointer;
            transition: var(--transition);
            text-decoration: none;
            white-space: nowrap;
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-primary {
            background: var(--primary-color);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--primary-hover);
            transform: translateY(-1px);
        }

        .btn-success {
            background: var(--success-color);
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: var(--success-hover);
            transform: translateY(-1px);
        }

        .btn-warning {
            background: var(--warning-color);
            color: white;
        }

        .btn-warning:hover:not(:disabled) {
            background: var(--warning-hover);
            transform: translateY(-1px);
        }

        .btn-danger {
            background: var(--danger-color);
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: var(--danger-hover);
            transform: translateY(-1px);
        }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        .btn-outline:hover:not(:disabled) {
            background: var(--bg-light);
            border-color: var(--text-secondary);
        }

        .btn-sm {
            padding: 4px 12px;
            font-size: var(--font-size-xs);
        }

        .btn-lg {
            padding: 12px 24px;
            font-size: var(--font-size-base);
        }

        /* Card System */
        .card {
            background: var(--bg-primary);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-light);
            overflow: hidden;
            transition: var(--transition);
        }

        .card:hover {
            box-shadow: var(--shadow-md);
        }

        .card-header {
            padding: 20px 24px;
            border-bottom: 1px solid var(--border-light);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-secondary);
        }

        .card-title {
            font-size: var(--font-size-lg);
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }

        .card-content {
            padding: 24px;
        }

        /* View Controls */
        .view-controls {
            background: var(--bg-primary);
            padding: 24px;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            margin-bottom: 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 16px;
        }

        .view-toggle {
            display: flex;
            background: var(--bg-light);
            border-radius: var(--radius-md);
            padding: 4px;
            gap: 2px;
        }

        .view-toggle button {
            padding: 10px 16px;
            border: none;
            background: transparent;
            border-radius: var(--radius-sm);
            font-size: var(--font-size-sm);
            font-weight: 500;
            color: var(--text-muted);
            cursor: pointer;
            transition: var(--transition);
        }

        .view-toggle button.active {
            background: var(--bg-primary);
            color: var(--text-primary);
            box-shadow: var(--shadow-sm);
        }

        .view-toggle button:hover:not(.active) {
            color: var(--text-secondary);
        }

        .view-actions {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        /* Week Navigation */
        .week-nav {
            background: var(--bg-primary);
            padding: 20px 24px;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            margin-bottom: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 24px;
        }

        .week-display {
            font-size: var(--font-size-lg);
            font-weight: 600;
            color: var(--text-primary);
            min-width: 250px;
            text-align: center;
        }

        /* Filters */
        .filters {
            background: var(--bg-primary);
            padding: 24px;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            margin-bottom: 24px;
        }

        .filter-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            align-items: end;
        }

        .filter-group {
            display: flex;
            flex-direction: column;
        }

        .filter-group label {
            font-weight: 500;
            margin-bottom: 8px;
            color: var(--text-secondary);
            font-size: var(--font-size-sm);
        }

        .filter-group input, 
        .filter-group select {
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            font-size: var(--font-size-sm);
            background: var(--bg-primary);
            transition: var(--transition);
        }

        .filter-group input:focus, 
        .filter-group select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0, 73, 144, 0.1);
        }

        .searchable-dropdown {
            position: relative;
        }

        .searchable-input {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            font-size: var(--font-size-sm);
            background: var(--bg-primary);
            transition: var(--transition);
        }

        .searchable-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0, 73, 144, 0.1);
        }

        /* Table System */
        .table-container {
            background: var(--bg-primary);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            overflow: hidden;
            margin-bottom: 24px;
            border: 1px solid var(--border-light);
        }

        .table-header {
            padding: 24px;
            border-bottom: 1px solid var(--border-light);
            background: var(--bg-secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 16px;
        }

        .table-title {
            font-size: var(--font-size-xl);
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }

        .table-actions {
            display: flex;
            gap: 12px;
        }

        .roster-table {
            width: 100%;
            border-collapse: collapse;
            font-size: var(--font-size-sm);
        }

        .roster-table th {
            background: var(--bg-light);
            padding: 16px 12px;
            text-align: left;
            font-weight: 600;
            font-size: var(--font-size-xs);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            border-bottom: 2px solid var(--border-color);
        }

        .roster-table td {
            padding: 16px 12px;
            border-bottom: 1px solid var(--border-light);
            vertical-align: top;
            line-height: 1.4;
        }

        .roster-table tr:hover:not(.day-header) {
            background: var(--bg-secondary);
        }

        /* Day Color Coding - Subtle Left Border */
        .monday-shift { border-left: 4px solid #e91e63; }
        .tuesday-shift { border-left: 4px solid #ff9800; }
        .wednesday-shift { border-left: 4px solid #4caf50; }
        .thursday-shift { border-left: 4px solid #2196f3; }
        .friday-shift { border-left: 4px solid #9c27b0; }
        .saturday-shift { border-left: 4px solid #673ab7; }
        .sunday-shift { border-left: 4px solid #f44336; }

        /* Day Headers */
        .day-header {
            background: linear-gradient(135deg, var(--primary-color), var(--info-color)) !important;
        }

        .day-header td {
            color: white !important;
            font-weight: 600;
            padding: 12px 16px;
        }

        .day-stats {
            float: right;
            background: rgba(255,255,255,0.2);
            padding: 4px 12px;
            border-radius: 20px;
            font-size: var(--font-size-xs);
            font-weight: 500;
        }

        /* Status System */
        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: var(--font-size-xs);
            font-weight: 500;
            text-transform: capitalize;
        }

        .status-scheduled, .status-confirmed {
            background: #e3f2fd;
            color: #1565c0;
        }

        .status-completed {
            background: #e8f5e8;
            color: #2e7d32;
        }

        .status-no_show, .status-cancelled {
            background: #ffebee;
            color: #c62828;
        }

        .status-pending {
            background: #fff8e1;
            color: #f57c00;
        }

        /* Hour and Pay Display */
        .hour-breakdown {
            cursor: help;
            border-bottom: 1px dotted var(--text-muted);
            position: relative;
            font-weight: 600;
        }

        .pay-breakdown {
            font-size: var(--font-size-xs);
            color: var(--text-muted);
            margin-top: 4px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
            line-height: 1.3;
        }

        .pay-override {
            background: #fff3cd;
            border-left: 3px solid var(--warning-color);
            padding: 4px 8px;
            font-size: var(--font-size-xs);
            border-radius: var(--radius-sm);
            margin-top: 4px;
            color: #856404;
        }

        .transfer-pending, .adjustment-pending {
            display: inline-block;
            padding: 2px 8px;
            border-radius: var(--radius-sm);
            font-size: var(--font-size-xs);
            font-weight: 500;
            margin-top: 4px;
        }

        .transfer-pending {
            background: #fff3cd;
            color: #856404;
        }

        .adjustment-pending {
            background: #e1d5ff;
            color: #5b21b6;
        }

        .hour-warning {
            background: #f8d7da;
            color: #721c24;
            padding: 12px 16px;
            border-radius: var(--radius-md);
            font-size: var(--font-size-sm);
            font-weight: 500;
            margin-top: 12px;
            border: 1px solid #f5c6cb;
        }

        /* Modal System */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(4px);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal {
            background: var(--bg-primary);
            border-radius: var(--radius-lg);
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow-lg);
        }

        .modal.large {
            max-width: 800px;
        }

        .modal-header {
            padding: 24px;
            border-bottom: 1px solid var(--border-light);
            background: var(--bg-secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: var(--font-size-lg);
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-muted);
            padding: 4px;
            border-radius: var(--radius-sm);
            transition: var(--transition);
        }

        .modal-close:hover {
            background: var(--bg-light);
            color: var(--text-primary);
        }

        .modal-content {
            padding: 24px;
            overflow: auto;
            flex: 1;
        }

        .modal-footer {
            padding: 20px 24px;
            border-top: 1px solid var(--border-light);
            background: var(--bg-secondary);
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
        }

        .modal-footer .btn-danger {
            margin-right: auto;
        }

        .modal-footer .modal-actions {
            display: flex;
            gap: 12px;
        }

        /* Form System */
        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-secondary);
            font-size: var(--font-size-sm);
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            font-size: var(--font-size-sm);
            background: var(--bg-primary);
            transition: var(--transition);
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0, 73, 144, 0.1);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 100px;
            line-height: 1.5;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        /* View Content */
        .view-content {
            display: none;
        }

        .view-content.active {
            display: block;
        }

        /* Summary Grid */
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 24px;
            margin-bottom: 24px;
        }

        .summary-card {
            background: var(--bg-primary);
            padding: 24px;
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-light);
        }

        .summary-card h3 {
            margin-bottom: 20px;
            color: var(--text-primary);
            font-size: var(--font-size-lg);
            font-weight: 600;
            border-bottom: 1px solid var(--border-light);
            padding-bottom: 12px;
        }

        .summary-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-light);
        }

        .summary-item:last-child {
            border-bottom: none;
        }

        .summary-item-details {
            font-size: var(--font-size-xs);
            color: var(--text-muted);
            margin-top: 4px;
            line-height: 1.4;
        }

        /* Loading States */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            color: var(--text-muted);
            flex-direction: column;
            gap: 12px;
        }

        .spinner {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border-light);
            border-top: 2px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Notification System */
        .notification {
            position: fixed;
            top: 24px;
            right: 24px;
            padding: 16px 20px;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-lg);
            z-index: 10000;
            max-width: 400px;
            animation: slideIn 0.3s ease-out;
            border: 1px solid transparent;
        }

        .notification.success {
            background: var(--success-color);
            color: white;
            border-color: var(--success-hover);
        }

        .notification.error {
            background: var(--danger-color);
            color: white;
            border-color: var(--danger-hover);
        }

        .notification.info {
            background: var(--info-color);
            color: white;
            border-color: var(--info-hover);
        }

        .notification.warning {
            background: var(--warning-color);
            color: white;
            border-color: var(--warning-hover);
        }

        @keyframes slideIn {
            from { 
                transform: translateX(100%); 
                opacity: 0; 
            }
            to { 
                transform: translateX(0); 
                opacity: 1; 
            }
        }

        /* Empty States */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-muted);
        }

        .empty-state h3 {
            color: var(--text-secondary);
            margin-bottom: 12px;
        }

        .empty-state p {
            margin-bottom: 20px;
            line-height: 1.5;
        }

        /* Holiday Management */
        .holiday-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            margin-bottom: 8px;
            border: 1px solid var(--border-light);
        }

        .holiday-form {
            padding: 20px;
            background: var(--bg-light);
            border-radius: var(--radius-md);
            margin-bottom: 20px;
            border: 1px solid var(--border-light);
        }

        .overlap-indicator {
    display: inline-block;
    background: #ffc107;
    color: #000;
    padding: 2px 6px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: bold;
    margin-left: 8px;
    cursor: help;
}

.overlap-tooltip {
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 12px;
    z-index: 10000;
    max-width: 300px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

.status-pending {
    background: #fff3cd;
    color: #856404;
}

.status-confirmed {
    background: #d4edda;
    color: #155724;
}

.status-completed {
    background: #cce5ff;
    color: #004085;
}
        /* Responsive Design */
        @media (max-width: 768px) {
            .container {
                padding: 16px;
            }
            
            .header-content {
                padding: 0 16px;
                flex-direction: column;
                height: auto;
                gap: 12px;
                padding-top: 12px;
                padding-bottom: 12px;
            }
            
            .view-controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .view-toggle {
                justify-content: center;
            }
            
            .view-actions {
                justify-content: center;
            }
            
            .week-nav {
                flex-direction: column;
                gap: 16px;
            }
            
            .filter-row {
                grid-template-columns: 1fr;
                gap: 16px;
            }
            
            .table-header {
                flex-direction: column;
                align-items: stretch;
            }
            
            .table-actions {
                justify-content: center;
            }
            
            .roster-table {
                font-size: var(--font-size-xs);
            }

            .roster-table th,
            .roster-table td {
                padding: 12px 8px;
            }
            
            .modal {
                max-width: 95%;
                margin: 0 auto;
            }
            
            .modal-footer {
                flex-direction: column;
                gap: 12px;
            }
            
            .modal-footer .btn-danger {
                margin-right: 0;
                order: 2;
            }
            
            .modal-footer .modal-actions {
                order: 1;
                width: 100%;
                justify-content: stretch;
            }
            
            .modal-actions .btn {
                flex: 1;
            }
        }

        @media (max-width: 480px) {
            .summary-grid {
                grid-template-columns: 1fr;
            }
            
            .roster-table th,
            .roster-table td {
                padding: 8px 4px;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <div class="logo">MC Manager</div>
            <div class="user-info">
                <span class="user-name" id="userName">Loading...</span>
                <span class="user-role" id="userRole">Staff</span>
                <button class="btn btn-outline btn-sm" onclick="logout()">Logout</button>
            </div>
        </div>
    </header>

    <main class="container">
        <!-- View Controls -->
        <section class="view-controls">
          <div class="view-toggle">
            <button onclick="switchView('table')" class="active" id="tableViewBtn">Roster</button>
            <button onclick="switchView('requests')" id="requestsViewBtn">Requests</button>
<button onclick="switchView('conflicts')" id="conflictsViewBtn" class="btn btn-danger btn-sm">Conflicts</button>        
<button onclick="switchView('summary')" id="summaryViewBtn">Summary</button>
            <button onclick="switchView('timesheet')" id="timesheetViewBtn">Timesheet</button>
            <button onclick="switchView('notes')" id="notesViewBtn">Notes</button>
            <button onclick="switchView('availability')" id="availabilityViewBtn">Availability</button>
        </div>        
            <div class="view-actions">
              <button class="btn btn-outline btn-sm" id="undoBtn" onclick="UndoRedoManager.undo()" disabled title="Nothing to undo (Ctrl+Z)">‚Ü∂ Undo</button>
              <button class="btn btn-outline btn-sm" id="redoBtn" onclick="UndoRedoManager.redo()" disabled title="Nothing to redo (Ctrl+Y)">‚Ü∑ Redo</button>
              <span style="border-left: 1px solid var(--border-color); margin: 0 8px; height: 24px;"></span>
              <button class="btn btn-primary" onclick="showAddShiftModal()">Add Shift</button>
              <button class="btn btn-warning" onclick="showPublicHolidayModal()">Holidays</button>
              <button class="btn btn-success btn-sm" onclick="generatePayrollSummary()">Payroll</button>
              <button class="btn btn-success btn-sm" onclick="exportData()">Export</button>
              <button class="btn btn-outline btn-sm" onclick="debugDataLoading()" style="background: #ff6b6b; color: white;">Debug</button>
          </div>
          
        </section>

        <!-- Week Navigation -->
        <section class="week-nav">
            <button class="btn btn-outline" onclick="previousWeek">Previous Week</button>
            <div class="week-display" id="weekDisplay">Loading...</div>
            <button class="btn btn-outline" onclick="nextWeek">Next Week</button>
            <button class="btn btn-primary btn-sm" onclick="goToCurrentWeek()">This Week</button>
        </section>

        <!-- Filters -->
        <section class="filters">
            <div class="filter-row">
                <div class="filter-group">
                    <label>Start Date</label>
                    <input type="date" id="startDate" onchange="applyFilters()">
                </div>
                <div class="filter-group">
                    <label>End Date</label>
                    <input type="date" id="endDate" onchange="applyFilters()">
                </div>
                <div class="filter-group">
                    <label>Staff</label>
                    <input type="text" class="searchable-input" id="staffFilterInput" 
                           placeholder="Type to search staff..." 
                           list="staffFilterList" onchange="updateStaffFilter()">
                    <datalist id="staffFilterList"></datalist>
                </div>
                <div class="filter-group">
                    <label>Participant</label>
                    <input type="text" class="searchable-input" id="participantFilterInput" 
                           placeholder="Type to search participants..." 
                           list="participantFilterList" onchange="updateParticipantFilter()">
                    <datalist id="participantFilterList"></datalist>
                </div>
                <div class="filter-group">
                    <label>Status</label>
                    <select id="statusFilter" onchange="applyFilters()">
                        <option value="">All Status</option>
                        <option value="scheduled">Scheduled</option>
                        <option value="confirmed">Confirmed</option>
                        <option value="completed">Completed</option>
                        <option value="no_show">No Show</option>
                        <option value="cancelled">Cancelled</option>
                    </select>
                </div>
                <div class="filter-group">
                    <label>Actions</label>
                    <button class="btn btn-outline btn-sm" onclick="clearAllFilters()" style="width: 100%;">Clear Filters</button>
                </div>
            </div>
        </section>

        <!-- Table View -->
        <div id="tableView" class="view-content active">
            <div class="table-container">
                <header class="table-header">
                    <h2 class="table-title">Shift Roster</h2>
                    <div class="table-actions">
                        <button class="btn btn-outline btn-sm" onclick="refreshData()">Refresh</button>
                    </div>
                </header>
                <div style="overflow-x: auto;">
                  <table class="roster-table">
                    <thead>
                        <tr>
                            <th>Date</th>
                            <th>Time</th>
                            <th>Staff</th>
                            <th>Client</th>
                            <th>Location</th>
                            <th>Duty Type</th>
                            <th>Status</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="shiftsTableBody">
                        <tr>
                            <td colspan="8" class="loading">
                                <div class="spinner"></div>
                                <span>Loading shifts...</span>
                            </td>
                        </tr>
                    </tbody>
                </table>                
                </div>
            </div>
        </div>
       <div id="requestsView" class="view-content">
    <div class="table-container">
        <header class="table-header">
            <h2 class="table-title">Shift Requests Management</h2>
            <div class="table-actions">
                <button class="btn btn-outline btn-sm" onclick="renderRequests()">
                    <span style="margin-right: 4px;">üîÑ</span> Refresh
                </button>
                <button class="btn btn-primary btn-sm" onclick="showRequestTransferModal()" style="margin-left: 8px;">
                    <span style="margin-right: 4px;">‚û°Ô∏è</span> Request Transfer
                </button>
                <button class="btn btn-info btn-sm" onclick="showRequestAdjustmentModal()" style="margin-left: 8px;">
                    <span style="margin-right: 4px;">‚è∞</span> Request Adjustment
                </button>
            </div>
        </header>
        <div class="card-content" id="requestsContent">
            <div class="loading">
                <div class="spinner"></div>
                <span>Loading requests...</span>
            </div>
        </div>
    </div>
</div>
        <!-- Summary View -->
        <div id="summaryView" class="view-content">
            <div class="summary-grid" id="summaryGrid">
                <div class="loading">
                    <div class="spinner"></div>
                    <span>Loading summary...</span>
                </div>
            </div>
        </div>

        

        <!-- Timesheet View -->
        <div id="timesheetView" class="view-content">
            <div class="table-container">
                <header class="table-header">
                    <h2 class="table-title">Detailed Timesheet</h2>
                    <div class="table-actions">
                        <button class="btn btn-success btn-sm" onclick="exportTimesheet()">Export Timesheet</button>
                    </div>
                </header>
                <div class="card-content" id="timesheetContent">
                    <div class="loading">
                        <div class="spinner"></div>
                        <span>Loading timesheet...</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="conflictsView" class="view-content">
          <div id="conflictsContent"></div>
      </div>

        <!-- Notes View -->
        <div id="notesView" class="view-content">
            <div class="table-container">
                <header class="table-header">
                    <h2 class="table-title">Shift Notes</h2>
                    <div class="table-actions">
                        <button class="btn btn-primary btn-sm" onclick="showAddNoteModal()">Add Note</button>
                    </div>
                </header>
                <div class="card-content" id="notesContent">
                    <div class="loading">
                        <div class="spinner"></div>
                        <span>Loading notes...</span>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Edit Shift Modal -->
    <div id="editShiftModal" class="modal-overlay" style="display: none;">
        <div class="modal large">
            <header class="modal-header">
                <h3 class="modal-title">Edit Shift</h3>
                <button class="modal-close" onclick="closeModal('editShiftModal')">&times;</button>
            </header>
            <div class="modal-content">
                <form id="editShiftForm">
                    <input type="hidden" id="editShiftId">
                    <div class="form-group">
                        <label>Date *</label>
                        <input type="date" id="editShiftDate" required>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Start Time</label>
                            <input type="time" id="editShiftStartTime">
                        </div>
                        <div class="form-group">
                            <label>End Time</label>
                            <input type="time" id="editShiftEndTime">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Staff *</label>
                        <input type="text" class="searchable-input" id="editShiftStaffInput" 
                               placeholder="Type to search staff..." 
                               list="editStaffList" required onchange="updateEditStaffSelection()">
                        <datalist id="editStaffList"></datalist>
                        <input type="hidden" id="editShiftStaff">
                    </div>
                    <div class="form-group">
                        <label>Participant</label>
                        <input type="text" class="searchable-input" id="editShiftParticipantInput" 
                               placeholder="Type to search participants..." 
                               list="editParticipantList" onchange="updateEditParticipantSelection()">
                        <datalist id="editParticipantList"></datalist>
                        <input type="hidden" id="editShiftParticipant">
                    </div>
                    <div class="form-group">
                        <label>Location</label>
                        <select id="editShiftLocation">
                            <option value="">Select Location</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Duty Type *</label>
                        <select id="editShiftDutyType" required onchange="updateEditTimeFields()">
                            <option value="">Select Duty Type</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Pay Rate Override</label>
                        <select id="editShiftPayRate">
                            <option value="">Use Staff Default</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Status</label>
                        <select id="editShiftStatus">
                            <option value="scheduled">Scheduled</option>
                            <option value="confirmed">Confirmed</option>
                            <option value="completed">Completed</option>
                            <option value="no_show">No Show</option>
                            <option value="cancelled">Cancelled</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Notes</label>
                        <textarea id="editShiftNotes" placeholder="Shift notes..."></textarea>
                    </div>
                </form>
            </div>
            <footer class="modal-footer">
                <button class="btn btn-danger" onclick="deleteShiftConfirm()">Delete Shift</button>
                <div class="modal-actions">
                    <button class="btn btn-outline" onclick="closeModal('editShiftModal')">Cancel</button>
                    <button class="btn btn-primary" onclick="updateShift()">Save Changes</button>
                </div>
            </footer>
        </div>
    </div>

    <!-- Add Shift Modal -->
    <div id="addShiftModal" class="modal-overlay" style="display: none;">
        <div class="modal large">
            <header class="modal-header">
                <h3 class="modal-title">Add New Shift</h3>
                <button class="modal-close" onclick="closeModal('addShiftModal')">&times;</button>
            </header>
            <div class="modal-content">
                <form id="addShiftForm">
                    <div class="form-group">
                        <label>Date *</label>
                        <input type="date" id="shiftDate" required>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label>Start Time</label>
                            <input type="time" id="shiftStartTime">
                        </div>
                        <div class="form-group">
                            <label>End Time</label>
                            <input type="time" id="shiftEndTime">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Staff *</label>
                        <input type="text" class="searchable-input" id="shiftStaffInput" 
                               placeholder="Type to search staff..." 
                               list="staffDataList" required onchange="updateStaffSelection()">
                        <datalist id="staffDataList"></datalist>
                        <input type="hidden" id="shiftStaff">
                    </div>
                    <div class="form-group">
                        <label>Participant</label>
                        <input type="text" class="searchable-input" id="shiftParticipantInput" 
                               placeholder="Type to search participants..." 
                               list="participantDataList" onchange="updateParticipantSelection()">
                        <datalist id="participantDataList"></datalist>
                        <input type="hidden" id="shiftParticipant">
                    </div>
                    <div class="form-group">
                        <label>Location</label>
                        <select id="shiftLocation">
                            <option value="">Select Location</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Duty Type *</label>
                        <select id="shiftDutyType" required onchange="updateTimeFields()">
                            <option value="">Select Duty Type</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Pay Rate Override</label>
                        <select id="shiftPayRate">
                            <option value="">Use Staff Default</option>
                        </select>
                    </div>
                    <div id="hourWarningText" style="display: none;" class="hour-warning"></div>
                </form>
            </div>
            <footer class="modal-footer">
                <div class="modal-actions">
                    <button class="btn btn-outline" onclick="closeModal('addShiftModal')">Cancel</button>
                    <button class="btn btn-primary" onclick="createShift()">Create Shift</button>
                </div>
            </footer>
        </div>
    </div>

    <!-- Add Note Modal -->
    <div id="addNoteModal" class="modal-overlay" style="display: none;">
        <div class="modal">
            <header class="modal-header">
                <h3 class="modal-title">Add Shift Note</h3>
                <button class="modal-close" onclick="closeModal('addNoteModal')">&times;</button>
            </header>
            <div class="modal-content">
                <form id="addNoteForm">
                    <div class="form-group">
                        <label>Shift *</label>
                        <select id="noteShift" required>
                            <option value="">Select Shift</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Note Type *</label>
                        <select id="noteType" required>
                            <option value="shift">Shift Note (Visible to Managers)</option>
                            <option value="handover">Handover Note (Staff Only)</option>
                            <option value="incident">Incident Report</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Note *</label>
                        <textarea id="noteContent" required placeholder="Enter your note..."></textarea>
                    </div>
                </form>
            </div>
            <footer class="modal-footer">
                <div class="modal-actions">
                    <button class="btn btn-outline" onclick="closeModal('addNoteModal')">Cancel</button>
                    <button class="btn btn-primary" onclick="createNote()">Add Note</button>
                </div>
            </footer>
        </div>
    </div>

    <!-- Public Holiday Modal -->
    <div id="publicHolidayModal" class="modal-overlay" style="display: none;">
        <div class="modal large">
            <header class="modal-header">
                <h3 class="modal-title">Public Holidays Management</h3>
                <button class="modal-close" onclick="closeModal('publicHolidayModal')">&times;</button>
            </header>
            <div class="modal-content">
                <div style="margin-bottom: 24px;">
                    <button class="btn btn-primary btn-sm" onclick="showAddHolidayForm()">Add Holiday</button>
                    <button class="btn btn-outline btn-sm" onclick="loadAustralianHolidays()">Load AU Holidays</button>
                </div>
                
                <div id="addHolidayForm" class="holiday-form" style="display: none;">
                    <div class="form-row">
                        <div class="form-group">
                            <label>Holiday Date</label>
                            <input type="date" id="holidayDate">
                        </div>
                        <div class="form-group">
                            <label>Holiday Name</label>
                            <input type="text" id="holidayName" placeholder="e.g., Christmas Day">
                        </div>
                    </div>
                    <div style="display: flex; gap: 12px;">
                        <button class="btn btn-success btn-sm" onclick="addHoliday()">Add Holiday</button>
                        <button class="btn btn-outline btn-sm" onclick="cancelAddHoliday()">Cancel</button>
                    </div>
                </div>

                <div>
                    <h4 style="margin-bottom: 16px; color: var(--text-secondary);">Current Public Holidays</h4>
                    <div id="holidayList" style="max-height: 300px; overflow-y: auto;">
                        <div class="loading">
                            <div class="spinner"></div>
                            <span>Loading holidays...</span>
                        </div>
                    </div>
                </div>
            </div>
            <footer class="modal-footer">
                <div class="modal-actions">
                    <button class="btn btn-outline" onclick="closeModal('publicHolidayModal')">Close</button>
                </div>
            </footer>
        </div>
    </div>

    <script>
        // Initialize Supabase
        const supabaseUrl = 'https://gqchhsayqxttewthcsah.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImdxY2hoc2F5cXh0dGV3dGhjc2FoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTY2OTA0ODksImV4cCI6MjA3MjI2NjQ4OX0.iAGhrDZaHkpLwjJY07o-73l2OiePB2x1ZnnTEfUBd_M';
        const { createClient } = supabase;
        const supabaseClient = createClient(supabaseUrl, supabaseKey);

        // Global State
        let payRateLabels = new Map();
        let currentUser = null;
        let currentUserRole = 'staff';
        let currentStaffData = null;
        let shifts = [];
        let staff = [];
        let participants = [];
        let locations = [];
        let dutyTypes = [];
        let payRates = [];
        let filteredShifts = [];
        let currentView = 'table';
        let publicHolidays = new Set();
        let currentWeekStart = new Date();
        let staffFilterValue = '';
        let participantFilterValue = '';
        let undoStack = [];
let redoStack = [];
const MAX_UNDO_STACK = 20;
let careHomes = new Map(); 
let activeCareHomeFilter = null; 
const TIMEZONE = 'Australia/Sydney';
const LOCALE = 'en-AU';


async function initializeApp() {
    try {
        console.log('=== INITIALIZING MC MANAGER ===');
        
        // Check authentication
        const { data: { session }, error } = await supabaseClient.auth.getSession();
        
        if (error) throw error;
        
        if (!session) {
            window.location.href = 'index.html';
            return;
        }

        currentUser = session.user;
        
        // Check both possible locations for role
        currentUserRole = currentUser.user_metadata?.role || 
                         currentUser.raw_user_meta_data?.role || 
                         'staff';
        
        console.log('User authenticated:', currentUser.email);
        console.log('User role detected:', currentUserRole);
        
        // Get staff record if linked
        if (currentUser.id) {
            const { data: staffData, error: staffError } = await supabaseClient
                .from('staff')
                .select('*')
                .eq('user_id', currentUser.id)
                .maybeSingle();
            
            if (staffError) {
                console.error('Error loading staff data:', staffError);
            }
            
            currentStaffData = staffData;
            console.log('Current staff data loaded:', currentStaffData);
        }

        // Update UI
        let displayName = 'Unknown User';
        
        if (currentStaffData) {
            displayName = `${currentStaffData.first_name} ${currentStaffData.last_name}`;
        } else if (currentUser.user_metadata?.first_name) {
            displayName = `${currentUser.user_metadata.first_name} ${currentUser.user_metadata.last_name || ''}`;
        } else if (currentUser.email) {
            displayName = currentUser.email.split('@')[0];
        }
        
        // Update the UI elements
        document.getElementById('userName').textContent = displayName;
        document.getElementById('userRole').textContent = 
            currentUserRole.charAt(0).toUpperCase() + currentUserRole.slice(1);

        // Initialize week navigation
        setCurrentWeek();
        
        // Load all data - make sure these functions exist
        console.log('Loading initial data...');
        await loadInitialData();
        
        console.log('Loading public holidays...');
        await loadPublicHolidays();
        
        console.log('Loading shifts...');
        await loadShifts();

        console.log('=== INITIALIZATION COMPLETE ===');

    } catch (error) {
        console.error('CRITICAL: Initialization error:', error);
        document.getElementById('userName').textContent = 'Error Loading';
        document.getElementById('userRole').textContent = 'Error';
        showNotification('Failed to initialize: ' + error.message, 'error');
    }
}

async function refreshAfterChange() {
    await loadShifts(); // Reload base data
    
    // Refresh the current active view
    if (currentView === 'conflicts') {
        await renderConflicts();
    } else if (currentView === 'requests') {
        await renderRequests();
    } else if (currentView === 'timesheet') {
        await renderTimesheet();
    } else if (currentView === 'notes') {
        await renderNotes();
    } else if (currentView === 'summary') {
        await renderSummary();
    } else if (currentView === 'table') {
        renderTable();
    } else {
        renderCurrentView();
    }
}

async function renderRequests() {
    const requestsContent = document.getElementById('requestsContent');
    if (!requestsContent) return;
    
    try {
        // Load transfer requests
        const { data: transferRequests } = await supabaseClient
            .from('transfer_requests')
            .select('*')
            .order('created_at', { ascending: false });
        
        // Load adjustment requests
        const { data: adjustmentRequests } = await supabaseClient
            .from('shift_adjustment_requests')
            .select('*')
            .order('created_at', { ascending: false });
        
        // FIX #3: Properly enrich transfer requests with all related data
        const enrichedTransferRequests = await Promise.all((transferRequests || []).map(async req => {
            const shift = shifts.find(s => s.id === req.shift_id);
            const fromStaff = staff.find(s => s.id === req.from_staff_id);
            const toStaff = staff.find(s => s.id === req.to_staff_id);
            const participant = shift ? participants.find(p => p.id === shift.participant_id) : null;
            const location = shift ? locations.find(l => l.id === shift.location_id) : null;
            
            return {
                ...req,
                shift: shift ? {
                    ...shift,
                    participant,
                    location,
                    participantName: participant ? 
                        `${participant.first_name} ${participant.last_name}` : 
                        (location?.name || 'Unassigned')
                } : null,
                fromStaff,
                toStaff
            };
        }));
        
        // FIX #3: Properly enrich adjustment requests
        const enrichedAdjustmentRequests = await Promise.all((adjustmentRequests || []).map(async req => {
            const shift = shifts.find(s => s.id === req.shift_id);
            const staffMember = staff.find(s => s.id === req.staff_id);
            const participant = shift ? participants.find(p => p.id === shift.participant_id) : null;
            const location = shift ? locations.find(l => l.id === shift.location_id) : null;
            
            return {
                ...req,
                shift: shift ? {
                    ...shift,
                    participant,
                    location,
                    participantName: participant ? 
                        `${participant.first_name} ${participant.last_name}` : 
                        (location?.name || 'Unassigned')
                } : null,
                staff: staffMember
            };
        }));
        
        let html = '<div class="requests-grid">';
        
        // Transfer Requests Section
        html += `
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">Transfer Requests (${enrichedTransferRequests.filter(r => r.status === 'pending').length})</h3>
                </div>
                <div class="card-content">
        `;
        
        const pendingTransfers = enrichedTransferRequests.filter(r => r.status === 'pending');
        if (pendingTransfers.length > 0) {
            pendingTransfers.forEach(req => {
                html += `
                    <div class="request-item">
                        <div class="request-header">
                            <strong>${req.shift ? formatDateFriendly(req.shift.date) : 'Unknown Date'}</strong>
                            <span class="badge ${req.status === 'pending' ? 'badge-warning' : 'badge-info'}">${req.status}</span>
                        </div>
                        <div class="request-details">
                            ${req.shift ? `
                                <strong>Shift:</strong> ${req.shift.start_time ? formatTime12Hour(req.shift.start_time) : 'N/A'} - 
                                ${req.shift.end_time ? formatTime12Hour(req.shift.end_time) : 'N/A'}<br>
                                <strong>Client/Location:</strong> ${req.shift.participantName}<br>
                            ` : 'Shift details not found<br>'}
                            <strong>From:</strong> ${req.fromStaff ? `${req.fromStaff.first_name} ${req.fromStaff.last_name}` : 'Unknown'}<br>
                            ${req.to_staff_id ? 
                                `<strong>To:</strong> ${req.toStaff ? `${req.toStaff.first_name} ${req.toStaff.last_name}` : 'Unknown'}` : 
                                '<strong>To:</strong> <em>Open to all staff</em>'
                            }
                        </div>
                        ${req.reason ? `<div class="request-reason">${req.reason}</div>` : ''}
                        ${currentUserRole !== 'staff' ? `
                            <div class="request-actions">
                                <button class="btn btn-success btn-sm" onclick="approveTransfer('${req.id}')">Approve</button>
                                <button class="btn btn-danger btn-sm" onclick="denyTransfer('${req.id}')">Deny</button>
                            </div>
                        ` : ''}
                    </div>
                `;
            });
        } else {
            html += '<p style="text-align: center; color: var(--text-muted); padding: 20px;">No pending transfer requests</p>';
        }
        
        html += '</div></div>';
        
        // Adjustment Requests Section
        html += `
            <div class="card">
                <div class="card-header">
                    <h3 class="card-title">Time Adjustment Requests (${enrichedAdjustmentRequests.filter(r => r.status === 'pending').length})</h3>
                </div>
                <div class="card-content">
        `;
        
        const pendingAdjustments = enrichedAdjustmentRequests.filter(r => r.status === 'pending');
        if (pendingAdjustments.length > 0) {
            pendingAdjustments.forEach(req => {
                html += `
                    <div class="request-item">
                        <div class="request-header">
                            <strong>${req.shift ? formatDateFriendly(req.shift.date) : 'Unknown Date'}</strong>
                            <span class="badge badge-warning">Pending</span>
                        </div>
                        <div class="request-details">
                            <strong>Staff:</strong> ${req.staff ? `${req.staff.first_name} ${req.staff.last_name}` : 'Unknown'}<br>
                            ${req.shift ? `
                                <strong>Client/Location:</strong> ${req.shift.participantName}<br>
                                <strong>Current:</strong> ${req.shift.start_time ? formatTime12Hour(req.shift.start_time) : 'N/A'} - 
                                ${req.shift.end_time ? formatTime12Hour(req.shift.end_time) : 'N/A'}<br>
                            ` : ''}
                            <strong>Requested:</strong> ${formatTime12Hour(req.new_start_time)} - ${formatTime12Hour(req.new_end_time)}
                        </div>
                        ${req.reason ? `<div class="request-reason">${req.reason}</div>` : ''}
                        ${currentUserRole !== 'staff' ? `
                            <div class="request-actions">
                                <button class="btn btn-success btn-sm" onclick="approveAdjustment('${req.id}')">Approve</button>
                                <button class="btn btn-danger btn-sm" onclick="denyAdjustment('${req.id}')">Deny</button>
                            </div>
                        ` : ''}
                    </div>
                `;
            });
        } else {
            html += '<p style="text-align: center; color: var(--text-muted); padding: 20px;">No pending adjustment requests</p>';
        }
        
        html += '</div></div>';
        html += '</div>';
        
        requestsContent.innerHTML = html;
        
    } catch (error) {
        console.error('Error rendering requests:', error);
        requestsContent.innerHTML = '<div class="error">Failed to load requests</div>';
    }
}

function systemHealthCheck() {
    console.log('=== SYSTEM HEALTH CHECK ===');
    console.log('User:', currentUser?.email, '| Role:', currentUserRole);
    console.log('Staff Data:', currentStaffData ? `${currentStaffData.first_name} ${currentStaffData.last_name}` : 'Not linked');
    console.log('Shifts Loaded:', shifts.length);
    console.log('Staff Count:', staff.length);
    console.log('Participants:', participants.length);
    console.log('Care Homes Detected:', careHomes.size);
    console.log('Pay Rate Labels:', payRateLabels.size);
    console.log('Undo Stack:', undoStack.length, '| Redo Stack:', redoStack.length);
    
    // Check for any $0 pay issues
    const zeroPay = shifts.filter(s => s.calculated_pay === 0);
    if (zeroPay.length > 0) {
        console.warn(`Found ${zeroPay.length} shifts with $0 pay - check pay rate assignments`);
    }
    
    return {
        status: 'OK',
        issues: zeroPay.length > 0 ? ['Zero pay calculations found'] : []
    };
}

async function loadShifts() {
    try {
        console.log('=== LOADING SHIFTS ===');
        
        // Load shifts per schema - id is SERIAL
        let query = supabaseClient
            .from('shifts')
            .select('*')
            .is('deleted_at', null)
            .order('date', { ascending: false })
            .order('start_time', { ascending: true });

        const { data: basicShifts, error } = await query;
        
        if (error) {
            console.error('Shifts query error:', error);
            throw error;
        }
        
        console.log('Basic shifts loaded:', basicShifts?.length || 0);
        
        if (!basicShifts || basicShifts.length === 0) {
            console.log('No shifts found in database');
            shifts = [];
            filteredShifts = [];
            renderCurrentView();
            return;
        }
        
        // Enrich with related data and calculate hours
        shifts = await enrichShiftsData(basicShifts);
        console.log('Enriched shifts:', shifts.length);
        console.log('Sample enriched shift:', shifts[0]);
        
        // Calculate overlap information for each shift
        console.log('Calculating overlap information...');
        
        for (const shift of shifts) {
            // Only check overlaps for shifts with participants and times
            if (shift.participant_id && shift.start_time && shift.end_time) {
                // Find all other shifts for the same participant on the same date
                const sameParticipantShifts = shifts.filter(s => 
                    s.id !== shift.id &&
                    s.participant_id === shift.participant_id &&
                    s.date === shift.date &&
                    s.start_time && 
                    s.end_time
                );
                
                if (sameParticipantShifts.length > 0) {
                    const overlappingStaff = [];
                    
                    // Parse current shift times
                    const shiftStart = new Date(`2000-01-01T${shift.start_time}`);
                    let shiftEnd = new Date(`2000-01-01T${shift.end_time}`);
                    
                    // Handle overnight shifts
                    if (shiftEnd <= shiftStart) {
                        shiftEnd.setDate(shiftEnd.getDate() + 1);
                    }
                    
                    // Check each other shift for overlap
                    sameParticipantShifts.forEach(otherShift => {
                        const otherStart = new Date(`2000-01-01T${otherShift.start_time}`);
                        let otherEnd = new Date(`2000-01-01T${otherShift.end_time}`);
                        
                        // Handle overnight shifts
                        if (otherEnd <= otherStart) {
                            otherEnd.setDate(otherEnd.getDate() + 1);
                        }
                        
                        // Check for time overlap
                        const hasOverlap = !(shiftEnd <= otherStart || shiftStart >= otherEnd);
                        
                        if (hasOverlap) {
                            // Calculate the actual overlap period
                            const overlapStart = new Date(Math.max(shiftStart.getTime(), otherStart.getTime()));
                            const overlapEnd = new Date(Math.min(shiftEnd.getTime(), otherEnd.getTime()));
                            
                            overlappingStaff.push({
                                staff: otherShift.staff,
                                staff_id: otherShift.staff_id,
                                shift_id: otherShift.id,
                                time: `${formatTime12Hour(otherShift.start_time)}-${formatTime12Hour(otherShift.end_time)}`,
                                overlap_period: {
                                    start: overlapStart.toTimeString().slice(0, 5),
                                    end: overlapEnd.toTimeString().slice(0, 5),
                                    duration: ((overlapEnd - overlapStart) / (1000 * 60 * 60)).toFixed(1) + 'h'
                                }
                            });
                        }
                    });
                    
                    // If overlaps were found, add the information to the shift
                    if (overlappingStaff.length > 0) {
                        shift.overlap_info = {
                            count: overlappingStaff.length + 1, // +1 for current shift
                            ratio: `${overlappingStaff.length + 1}:1`,
                            staff: overlappingStaff,
                            message: `${overlappingStaff.length + 1} staff providing care simultaneously`,
                            details: overlappingStaff.map(s => 
                                `${s.staff?.first_name} ${s.staff?.last_name} (${s.overlap_period.start}-${s.overlap_period.end})`
                            ).join(', ')
                        };
                    }
                }
            }
            
            // Check for staff conflicts (overlapping shifts for same staff)
            if (shift.staff_id && shift.start_time && shift.end_time) {
                const staffConflicts = shifts.filter(s =>
                    s.id !== shift.id &&
                    s.staff_id === shift.staff_id &&
                    s.date === shift.date &&
                    s.start_time &&
                    s.end_time
                );
                
                if (staffConflicts.length > 0) {
                    const conflicts = [];
                    
                    const shiftStart = new Date(`2000-01-01T${shift.start_time}`);
                    let shiftEnd = new Date(`2000-01-01T${shift.end_time}`);
                    
                    if (shiftEnd <= shiftStart) {
                        shiftEnd.setDate(shiftEnd.getDate() + 1);
                    }
                    
                    staffConflicts.forEach(conflict => {
                        const conflictStart = new Date(`2000-01-01T${conflict.start_time}`);
                        let conflictEnd = new Date(`2000-01-01T${conflict.end_time}`);
                        
                        if (conflictEnd <= conflictStart) {
                            conflictEnd.setDate(conflictEnd.getDate() + 1);
                        }
                        
                        const hasOverlap = !(shiftEnd <= conflictStart || shiftStart >= conflictEnd);
                        
                        if (hasOverlap) {
                            conflicts.push({
                                shift_id: conflict.id,
                                participant: conflict.participant,
                                time: `${formatTime12Hour(conflict.start_time)}-${formatTime12Hour(conflict.end_time)}`,
                                participant_name: conflict.participant ? 
                                    `${conflict.participant.first_name} ${conflict.participant.last_name}` :
                                    'Unknown'
                            });
                        }
                    });
                    
                    if (conflicts.length > 0) {
                        shift.staff_conflict = {
                            has_conflict: true,
                            count: conflicts.length,
                            conflicts: conflicts,
                            message: `‚ö†Ô∏è Staff double-booked with ${conflicts.length} other shift(s)`
                        };
                    }
                }
            }
            
            // Check for sleepover + late shift violations
            if (shift.duty_type?.name?.toLowerCase().includes('sleepover')) {
                const otherShiftsToday = shifts.filter(s =>
                    s.id !== shift.id &&
                    s.staff_id === shift.staff_id &&
                    s.date === shift.date &&
                    s.start_time
                );
                
                const violations = [];
                otherShiftsToday.forEach(otherShift => {
                    if (otherShift.start_time) {
                        const startHour = parseInt(otherShift.start_time.split(':')[0]);
                        const endHour = otherShift.end_time ? 
                            parseInt(otherShift.end_time.split(':')[0]) : 0;
                        
                        // Check for 10pm+ starts or 12am-6am periods
                        if (startHour >= 22 || startHour < 6 || (endHour > 0 && endHour <= 6)) {
                            violations.push({
                                shift_id: otherShift.id,
                                time: `${formatTime12Hour(otherShift.start_time)}-${formatTime12Hour(otherShift.end_time || '00:00')}`,
                                reason: startHour >= 22 ? 'Late night shift (after 10pm)' : 'Early morning shift (before 6am)'
                            });
                        }
                    }
                });
                
                if (violations.length > 0) {
                    shift.sleepover_violation = {
                        has_violation: true,
                        violations: violations,
                        message: `‚ö†Ô∏è Sleepover conflicts with ${violations.length} shift(s)`
                    };
                }
            }
        }
        
        console.log('Overlap detection complete');
        
        // Check for any critical issues
        const shiftsWithStaffConflicts = shifts.filter(s => s.staff_conflict?.has_conflict);
        const shiftsWithSleepoverViolations = shifts.filter(s => s.sleepover_violation?.has_violation);
        
        if (shiftsWithStaffConflicts.length > 0) {
            console.warn(`Found ${shiftsWithStaffConflicts.length} shifts with staff double-booking`);
        }
        
        if (shiftsWithSleepoverViolations.length > 0) {
            console.warn(`Found ${shiftsWithSleepoverViolations.length} shifts with sleepover violations`);
        }
        
        // Apply filters after all calculations
        applyFilters();
        
        // Show warning notification if conflicts exist
        if (shiftsWithStaffConflicts.length > 0 || shiftsWithSleepoverViolations.length > 0) {
            const warningMessage = [];
            if (shiftsWithStaffConflicts.length > 0) {
                warningMessage.push(`${shiftsWithStaffConflicts.length} staff double-bookings`);
            }
            if (shiftsWithSleepoverViolations.length > 0) {
                warningMessage.push(`${shiftsWithSleepoverViolations.length} sleepover violations`);
            }
            
            showNotification(
                `‚ö†Ô∏è Scheduling conflicts detected: ${warningMessage.join(', ')}`,
                'warning'
            );
        }

    } catch (error) {
        console.error('Error loading shifts:', error);
        showNotification('Failed to load shifts: ' + error.message, 'error');
        
        const tbody = document.getElementById('shiftsTableBody');
        if (tbody) {
            tbody.innerHTML = `
                <tr>
                    <td colspan="9" style="text-align: center; padding: 40px; color: var(--danger-color);">
                        <strong>Error Loading Shifts</strong><br>
                        ${error.message}<br>
                        <button class="btn btn-primary btn-sm" onclick="loadShifts()" style="margin-top: 12px;">Retry</button>
                    </td>
                </tr>
            `;
        }
        
        // Also update other views if they're active
        const timesheetContent = document.getElementById('timesheetContent');
        if (timesheetContent && currentView === 'timesheet') {
            timesheetContent.innerHTML = `
                <div class="error" style="text-align: center; padding: 40px;">
                    <strong>Error Loading Shifts</strong><br>
                    ${error.message}<br>
                    <button class="btn btn-primary btn-sm" onclick="loadShifts()" style="margin-top: 12px;">Retry</button>
                </div>
            `;
        }
    }
}      

        function detectCareHomes() {
    console.log('Detecting care homes...');
    console.log('Total participants:', participants.length);
    
    // Clear previous data
    careHomes.clear();
    
    // Group participants by address (normalized)
    const addressGroups = {};
    
    participants.forEach(p => {
        // Skip if no address
        if (!p.address || p.address.trim() === '') return;
        
        // Normalize address for comparison (lowercase, trim)
        const normalizedAddress = p.address.trim().toLowerCase();
        
        // Also check if this is a care home entity itself (like "Saunders Care Home" participant)
        const isCareHomeEntity = (p.first_name && p.last_name && 
            (p.last_name.toLowerCase().includes('care') || 
             p.last_name.toLowerCase().includes('home') ||
             p.first_name.toLowerCase().includes('saunders')));
        
        // If it's a care home entity, skip adding it as a resident
        if (isCareHomeEntity) {
            console.log('Found care home entity:', p.first_name, p.last_name, p.id);
            // Store care home entity info
            if (!addressGroups[normalizedAddress]) {
                addressGroups[normalizedAddress] = {
                    residents: [],
                    careHomeEntity: p
                };
            } else {
                addressGroups[normalizedAddress].careHomeEntity = p;
            }
        } else {
            // This is a resident
            if (!addressGroups[normalizedAddress]) {
                addressGroups[normalizedAddress] = {
                    residents: [],
                    careHomeEntity: null
                };
            }
            addressGroups[normalizedAddress].residents.push(p);
            console.log('Added resident:', p.first_name, p.last_name, 'at', normalizedAddress);
        }
    });
    
    // Process each address group
    Object.entries(addressGroups).forEach(([address, data]) => {
        // Check if this looks like a care home (multiple residents OR has a care home entity OR contains "saunders")
        if (data.residents.length > 1 || data.careHomeEntity || address.includes('saunders')) {
            let careHomeName = 'Care Home';
            let mainEntityId = null;
            
            // Determine care home name and main entity
            if (data.careHomeEntity) {
                careHomeName = `${data.careHomeEntity.first_name} ${data.careHomeEntity.last_name}`;
                mainEntityId = data.careHomeEntity.id;
            } else if (address.includes('saunders')) {
                careHomeName = 'Saunders Care Home';
                // Find the Saunders Care Home participant entity if it exists
                const saundersEntity = participants.find(p => 
                    p.first_name === 'Saunders' && p.last_name === 'Care Home'
                );
                if (saundersEntity) {
                    mainEntityId = saundersEntity.id;
                }
            }
            
            careHomes.set(address, {
                name: careHomeName,
                address: address,
                residents: data.residents,
                mainEntityId: mainEntityId
            });
            
            console.log(`Care home detected: ${careHomeName} at ${address} with ${data.residents.length} residents`);
        }
    });
    
    // Also check for Saunders Care Home entity specifically
    const saundersEntity = participants.find(p => 
        (p.first_name === 'Saunders' && p.last_name === 'Care Home') ||
        (p.first_name === 'Saunders' && p.last_name === 'Carehome')
    );
    
    if (saundersEntity) {
        console.log('Found Saunders Care Home entity:', saundersEntity);
        
        // Find all participants with Saunders address
        const saundersAddress = '1 saunders avenue, liverpool';
        const saundersResidents = participants.filter(p => 
            p.address && 
            p.address.toLowerCase().includes('saunders') &&
            p.id !== saundersEntity.id // Don't include the care home entity itself
        );
        
        // Update or create Saunders care home entry
        careHomes.set(saundersAddress, {
            name: 'Saunders Care Home',
            address: saundersAddress,
            residents: saundersResidents,
            mainEntityId: saundersEntity.id
        });
        
        console.log(`Saunders Care Home: ${saundersResidents.length} residents found`);
        console.log('Residents:', saundersResidents.map(r => `${r.first_name} ${r.last_name}`));
    }
    
    console.log(`Total care homes detected: ${careHomes.size}`);
    console.log('Care homes:', Array.from(careHomes.entries()));
}
// Helper function to detect care home name
function detectCareHomeName(address, residents) {
    // Check if address contains common care home keywords
    if (address.includes('saunders')) return 'Saunders Care Home';
    if (address.includes('care') || address.includes('home')) {
        // Extract the name from address
        return address.split(',')[0].replace(/\d+/g, '').trim();
    }
    // Default: use the address
    return `Care Home at ${address.split(',')[0]}`;
}

// Helper to find if there's a care home entity (not a person)
function findCareHomeEntity(residents, address) {
    const careHomeEntity = participants.find(p => 
        (p.first_name?.includes('Care') || p.last_name?.includes('Care') ||
         p.first_name?.includes('Home') || p.last_name?.includes('Home')) &&
        p.address?.toLowerCase() === address
    );
    return careHomeEntity?.id || null;
}

        async function enrichShiftsData(basicShifts) {
            if (!basicShifts || basicShifts.length === 0) return [];
            
            try {
                console.log('Enriching shifts with related data...');
                
                // Get unique IDs for batch loading
                const staffIds = [...new Set(basicShifts.map(s => s.staff_id).filter(Boolean))];
                const participantIds = [...new Set(basicShifts.map(s => s.participant_id).filter(Boolean))];
                const locationIds = [...new Set(basicShifts.map(s => s.location_id).filter(Boolean))];
                const dutyTypeIds = [...new Set(basicShifts.map(s => s.duty_type_id).filter(Boolean))];
                const payRateIds = [...new Set(basicShifts.map(s => s.pay_override_id).filter(Boolean))];

                console.log('Loading related data for IDs:', {
                    staffIds: staffIds.length,
                    participantIds: participantIds.length,
                    locationIds: locationIds.length,
                    dutyTypeIds: dutyTypeIds.length,
                    payRateIds: payRateIds.length
                });

                // Load related data in parallel
                const [
                    { data: staffData },
                    { data: participantData },
                    { data: locationData },
                    { data: dutyTypeData },
                    { data: payRateData }
                ] = await Promise.all([
                    staffIds.length ? supabaseClient.from('staff').select('*').in('id', staffIds) : { data: [] },
                    participantIds.length ? supabaseClient.from('participants').select('*').in('id', participantIds) : { data: [] },
                    locationIds.length ? supabaseClient.from('locations').select('*').in('id', locationIds) : { data: [] },
                    dutyTypeIds.length ? supabaseClient.from('duty_types').select('*').in('id', dutyTypeIds) : { data: [] },
                    payRateIds.length ? supabaseClient.from('pay_rates').select('*').in('id', payRateIds) : { data: [] }
                ]);

                console.log('Related data loaded:', {
                    staff: staffData?.length || 0,
                    participants: participantData?.length || 0,
                    locations: locationData?.length || 0,
                    dutyTypes: dutyTypeData?.length || 0,
                    payRates: payRateData?.length || 0
                });

                // Create lookup maps
                const staffMap = new Map((staffData || []).map(s => [s.id, s]));
                const participantMap = new Map((participantData || []).map(p => [p.id, p]));
                const locationMap = new Map((locationData || []).map(l => [l.id, l]));
                const dutyTypeMap = new Map((dutyTypeData || []).map(d => [d.id, d]));
                const payRateMap = new Map((payRateData || []).map(r => [r.id, r]));

                // Enrich shifts and calculate hours/pay
                const enrichedShifts = basicShifts.map(shift => {
                    const enrichedShift = {
                        ...shift,
                        staff: staffMap.get(shift.staff_id) || null,
                        participant: participantMap.get(shift.participant_id) || null,
                        location: locationMap.get(shift.location_id) || null,
                        duty_type: dutyTypeMap.get(shift.duty_type_id) || null,
                        pay_override: payRateMap.get(shift.pay_override_id) || null
                    };

                    // Calculate hours and pay - FIXED LOGIC
                    enrichedShift.calculated_hours = calculateShiftHours(enrichedShift);
                    enrichedShift.calculated_pay = calculateShiftPay(enrichedShift, enrichedShift.calculated_hours);

                    console.log(`Shift ${shift.id} calculations:`, {
                        date: shift.date,
                        start: shift.start_time,
                        end: shift.end_time,
                        hours: enrichedShift.calculated_hours,
                        pay: enrichedShift.calculated_pay
                    });

                    return enrichedShift;
                });

                return enrichedShifts;
                
            } catch (error) {
                console.error('Error enriching shifts:', error);
                return basicShifts;
            }
        }

        // Format hours with 1 decimal place
function formatHours(hours) {
    if (hours === undefined || hours === null) return '0.0';
    return parseFloat(hours).toFixed(1);
}

// Format date to "Mon 5 Aug 2025"
function formatDateFriendly(dateString) {
    if (!dateString) return '';
    const date = new Date(dateString + 'T12:00:00'); // Use noon to avoid timezone issues
    const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    
    return `${days[date.getDay()]} ${date.getDate()} ${months[date.getMonth()]} ${date.getFullYear()}`;
}

// Format time to 12-hour format
function formatTime12Hour(timeString) {
    if (!timeString) return '';
    const [hours, minutes] = timeString.split(':');
    const hour = parseInt(hours);
    const period = hour >= 12 ? 'PM' : 'AM';
    const displayHour = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
    return `${displayHour}:${minutes} ${period}`;
}


// Undo/Redo Manager
const UndoRedoManager = {
    // Save state before any modification
    saveState: function(action, data) {
        undoStack.push({
            action: action,
            data: JSON.parse(JSON.stringify(data)), // Deep clone
            timestamp: new Date().toISOString()
        });
        
        // Limit stack size
        if (undoStack.length > MAX_UNDO_STACK) {
            undoStack.shift();
        }
        
        // Clear redo stack when new action is performed
        redoStack = [];
        
        // Update UI buttons
        this.updateButtons();
    },
    
    undo: async function() {
        if (undoStack.length === 0) {
            showNotification('Nothing to undo', 'info');
            return;
        }
        
        const state = undoStack.pop();
        
        try {
            switch(state.action) {
                case 'create_shift':
                    // Undo creation by soft deleting
                    await supabaseClient
                        .from('shifts')
                        .update({ deleted_at: new Date().toISOString() })
                        .eq('id', state.data.id);
                    
                    redoStack.push(state);
                    showNotification('Shift creation undone', 'success');
                    break;
                    
                case 'update_shift':
                    // Restore previous values
                    await supabaseClient
                        .from('shifts')
                        .update(state.data.previous)
                        .eq('id', state.data.id);
                    
                    redoStack.push({
                        action: 'update_shift',
                        data: {
                            id: state.data.id,
                            previous: state.data.current,
                            current: state.data.previous
                        }
                    });
                    showNotification('Shift update undone', 'success');
                    break;
                    
                case 'delete_shift':
                    // Undo deletion by removing deleted_at
                    await supabaseClient
                        .from('shifts')
                        .update({ deleted_at: null })
                        .eq('id', state.data.id);
                    
                    redoStack.push(state);
                    showNotification('Shift deletion undone', 'success');
                    break;
            }
            
            await loadShifts();
            this.updateButtons();
            
        } catch (error) {
            console.error('Undo failed:', error);
            showNotification('Undo failed: ' + error.message, 'error');
            undoStack.push(state); // Restore to stack if failed
        }
    },
    
    redo: async function() {
        if (redoStack.length === 0) {
            showNotification('Nothing to redo', 'info');
            return;
        }
        
        const state = redoStack.pop();
        
        try {
            switch(state.action) {
                case 'create_shift':
                    // Redo creation by removing deleted_at
                    await supabaseClient
                        .from('shifts')
                        .update({ deleted_at: null })
                        .eq('id', state.data.id);
                    break;
                    
                case 'update_shift':
                    // Apply the update again
                    await supabaseClient
                        .from('shifts')
                        .update(state.data.current)
                        .eq('id', state.data.id);
                    break;
                    
                case 'delete_shift':
                    // Redo deletion
                    await supabaseClient
                        .from('shifts')
                        .update({ deleted_at: new Date().toISOString() })
                        .eq('id', state.data.id);
                    break;
            }
            
            undoStack.push(state);
            await loadShifts();
            this.updateButtons();
            showNotification('Action redone', 'success');
            
        } catch (error) {
            console.error('Redo failed:', error);
            showNotification('Redo failed: ' + error.message, 'error');
            redoStack.push(state); // Restore to stack if failed
        }
    },
    
    updateButtons: function() {
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        
        if (undoBtn) {
            undoBtn.disabled = undoStack.length === 0;
            undoBtn.title = undoStack.length > 0 ? 
                `Undo: ${undoStack[undoStack.length - 1].action.replace('_', ' ')}` : 
                'Nothing to undo (Ctrl+Z)';
        }
        
        if (redoBtn) {
            redoBtn.disabled = redoStack.length === 0;
            redoBtn.title = redoStack.length > 0 ? 
                `Redo: ${redoStack[redoStack.length - 1].action.replace('_', ' ')}` : 
                'Nothing to redo (Ctrl+Y)';
        }
    }
};

// Add keyboard shortcuts for undo/redo
document.addEventListener('keydown', function(e) {
    // Check if user is typing in an input field
    const activeElement = document.activeElement;
    const isInputField = activeElement && (
        activeElement.tagName === 'INPUT' || 
        activeElement.tagName === 'TEXTAREA' || 
        activeElement.tagName === 'SELECT'
    );
    
    // Don't trigger undo/redo if user is typing
    if (isInputField) return;
    
    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        UndoRedoManager.undo();
    } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        e.preventDefault();
        UndoRedoManager.redo();
    }
});

document.addEventListener('keydown', function(e) {
    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        UndoRedoManager.undo();
    } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
        e.preventDefault();
        UndoRedoManager.redo();
    }
});

        // ========================================
        // HOUR CALCULATION ENGINE - FIXED
        // ========================================

        // Update the calculateShiftHours function to handle combined shifts
function calculateShiftHours(shift) {
    const result = {
        total: 0,
        weekdayDay: 0,
        weekdayEvening: 0,
        weekdayNight: 0,
        saturday: 0,
        sunday: 0,
        publicHoliday: 0,
        sleepover: 0
    };

    const dutyType = shift.duty_type;
    const isSleepover = dutyType && dutyType.name && 
        dutyType.name.toLowerCase().includes('sleepover');

    // If it has times AND is a sleepover, calculate both
    if (isSleepover && shift.start_time && shift.end_time) {
        // This is BOTH active hours AND a sleepover
        
        // First calculate active hours
        const startTime = new Date(`${shift.date}T${shift.start_time}`);
        let endTime = new Date(`${shift.date}T${shift.end_time}`);
        
        if (endTime <= startTime) {
            endTime.setDate(endTime.getDate() + 1);
        }
        
        const activeHours = (endTime - startTime) / (1000 * 60 * 60);
        
        // Apply penalty logic for active hours
        const shiftDate = new Date(shift.date);
        const dayOfWeek = shiftDate.getDay();
        const isPublicHoliday = publicHolidays.has(shift.date);
        
        if (isPublicHoliday) {
            result.publicHoliday = activeHours;
        } else if (dayOfWeek === 6) {
            result.saturday = activeHours;
        } else if (dayOfWeek === 0) {
            result.sunday = activeHours;
        } else {
            const weekdayBreakdown = splitWeekdayHours(startTime, endTime);
            Object.assign(result, weekdayBreakdown);
        }
        
        // ADD the sleepover hours on top
        result.sleepover = 2; // Always 2 hours for sleepover
        result.total = activeHours + 2; // Total is active + sleepover
        
        console.log(`Combined shift: ${activeHours}h active + 2h sleepover = ${result.total}h total`);
        
    } else if (isSleepover) {
        // Just a sleepover, no active hours
        result.sleepover = 2;
        result.total = 2;
        
    } else if (shift.start_time && shift.end_time) {
        // Just active hours, no sleepover
        const startTime = new Date(`${shift.date}T${shift.start_time}`);
        let endTime = new Date(`${shift.date}T${shift.end_time}`);
        
        if (endTime <= startTime) {
            endTime.setDate(endTime.getDate() + 1);
        }
        
        const totalHours = (endTime - startTime) / (1000 * 60 * 60);
        result.total = totalHours;
        
        // Apply penalty logic
        const shiftDate = new Date(shift.date);
        const dayOfWeek = shiftDate.getDay();
        const isPublicHoliday = publicHolidays.has(shift.date);
        
        if (isPublicHoliday) {
            result.publicHoliday = totalHours;
        } else if (dayOfWeek === 6) {
            result.saturday = totalHours;
        } else if (dayOfWeek === 0) {
            result.sunday = totalHours;
        } else {
            const weekdayBreakdown = splitWeekdayHours(startTime, endTime);
            Object.assign(result, weekdayBreakdown);
        }
    }
    
    return result;
}

        function splitWeekdayHours(startTime, endTime) {
            const result = {
                total: 0,
                weekdayDay: 0,      // 6am-8pm
                weekdayEvening: 0,  // 8pm-12am  
                weekdayNight: 0     // 12am-6am
            };

            const current = new Date(startTime);
            
            while (current < endTime) {
                // Calculate end of current period
                const nextPeriod = new Date(current);
                nextPeriod.setMinutes(current.getMinutes() + 30); // Calculate in 30-min increments for accuracy
                
                const periodEnd = nextPeriod > endTime ? endTime : nextPeriod;
                const periodHours = (periodEnd - current) / (1000 * 60 * 60);
                
                const hour = current.getHours();
                
                // Time period classification
                if (hour >= 6 && hour < 20) {
                    result.weekdayDay += periodHours;
                } else if (hour >= 20 && hour < 24) {
                    result.weekdayEvening += periodHours;
                } else {
                    result.weekdayNight += periodHours;
                }
                
                current.setTime(periodEnd.getTime());
            }

            result.total = result.weekdayDay + result.weekdayEvening + result.weekdayNight;
            return result;
        }

        // Update the calculateShiftPay function (around line 1050)
function calculateShiftPay(shift, hoursBreakdown) {
    // Get effective pay rate - FIXED LOGIC
    let payRate = null;
    
    // Check if there's a pay override
    if (shift.pay_override_id && shift.pay_override_id !== '00000000-0000-0000-0000-000000000002') {
        // Use the override rate
        payRate = shift.pay_override || payRates.find(pr => pr.id === shift.pay_override_id);
    } 
    
    // If no override OR if it's the standard rate placeholder, use staff's assigned rate
    if (!payRate || shift.pay_override_id === '00000000-0000-0000-0000-000000000002') {
        if (shift.staff && shift.staff.pay_rate_id) {
            payRate = payRates.find(pr => pr.id === shift.staff.pay_rate_id);
            console.log(`Using staff ${shift.staff.first_name}'s assigned rate:`, payRate);
        }
    }
    
    // Final fallback
    if (!payRate) {
        console.warn(`No pay rate found for shift ${shift.id}, using zero rates`);
        payRate = {
            hourly_pay_rate: 0,
            afternoon: 0,
            night: 0,
            saturday: 0,
            sunday: 0,
            public_holiday: 0,
            sleepover: 0
        };
    }
    
    const baseRate = parseFloat(payRate.hourly_pay_rate) || 0;
    
    const totalPay = 
        (hoursBreakdown.weekdayDay * baseRate) +
        (hoursBreakdown.weekdayEvening * (parseFloat(payRate.afternoon) || baseRate)) +
        (hoursBreakdown.weekdayNight * (parseFloat(payRate.night) || baseRate)) +
        (hoursBreakdown.saturday * (parseFloat(payRate.saturday) || baseRate)) +
        (hoursBreakdown.sunday * (parseFloat(payRate.sunday) || baseRate)) +
        (hoursBreakdown.publicHoliday * (parseFloat(payRate.public_holiday) || baseRate)) +
        (hoursBreakdown.sleepover * (parseFloat(payRate.sleepover) || baseRate));

    console.log(`Pay calculation for shift ${shift.id}:`, {
        staffName: shift.staff?.first_name,
        payRateId: payRate.id,
        baseRate: baseRate,
        breakdown: hoursBreakdown,
        totalPay: totalPay
    });

    return totalPay;
}

        // ========================================
        // WEEK NAVIGATION
        // ========================================
        
        function setCurrentWeek() {
    const today = new Date();
    currentWeekStart = getWeekStart(today);
    updateWeekDisplay();
}

function previousWeek() {
    const prevWeek = new Date(currentWeekStart);
    prevWeek.setDate(prevWeek.getDate() - 7);
    currentWeekStart = prevWeek;
    updateWeekDisplay();
    loadShifts();
}

function nextWeek() {
    const next = new Date(currentWeekStart);
    next.setDate(next.getDate() + 7);
    currentWeekStart = next;
    updateWeekDisplay();
    loadShifts();
}

        function goToCurrentWeek() {
            setCurrentWeek();
            applyFilters();
        }

        function updateWeekDisplay() {
            const weekEnd = new Date(currentWeekStart);
            weekEnd.setDate(weekEnd.getDate() + 6);
            
            const startStr = currentWeekStart.toLocaleDateString('en-AU', { 
                month: 'short', day: 'numeric' 
            });
            const endStr = weekEnd.toLocaleDateString('en-AU', { 
                month: 'short', day: 'numeric', year: 'numeric' 
            });
            
            document.getElementById('weekDisplay').textContent = `Week of ${startStr} - ${endStr}`;
        }

        function setWeekDateRange() {
            const weekEnd = new Date(currentWeekStart);
            weekEnd.setDate(weekEnd.getDate() + 6);
            
            document.getElementById('startDate').value = currentWeekStart.toISOString().split('T')[0];
            document.getElementById('endDate').value = weekEnd.toISOString().split('T')[0];
        }

        function getWeekStart(date) {
    const start = new Date(date);
    const day = start.getDay();
    // Adjust to Monday as start of week
    // If Sunday (0), go back 6 days; otherwise go back (day-1) days
    const diff = day === 0 ? -6 : 1 - day;
    start.setDate(start.getDate() + diff);
    start.setHours(0, 0, 0, 0);
    return start;
}
        // ========================================
        // FILTERING AND VIEW SWITCHING
        // ========================================

        function applyFilters() {
            console.log('=== APPLYING FILTERS ===');
            
            const startDate = document.getElementById('startDate')?.value;
            const endDate = document.getElementById('endDate')?.value;
            const statusFilter = document.getElementById('statusFilter')?.value;

            console.log('Filter values:', { startDate, endDate, staffFilterValue, participantFilterValue, statusFilter });

            filteredShifts = shifts.filter(shift => {
                if (startDate && shift.date < startDate) return false;
                if (endDate && shift.date > endDate) return false;
                if (staffFilterValue && shift.staff_id !== staffFilterValue) return false;
                if (participantFilterValue && shift.participant_id !== participantFilterValue) return false;
                if (statusFilter && shift.status !== statusFilter) return false;
                return true;
            });

            console.log('Filtered result:', filteredShifts.length, 'shifts');
            renderCurrentView();
        }

        // Add this to your switch view function
        function switchView(view) {
    currentView = view;
    
    // Update buttons
    document.querySelectorAll('.view-toggle button').forEach(btn => btn.classList.remove('active'));
    const activeBtn = document.getElementById(`${view}ViewBtn`);
    if (activeBtn) activeBtn.classList.add('active');

    // Update content
    document.querySelectorAll('.view-content').forEach(content => content.classList.remove('active'));
    const activeView = document.getElementById(`${view}View`);
    if (activeView) activeView.classList.add('active');

    // Render the appropriate view
    switch(view) {
        case 'table':
            renderTable();
            break;
        case 'requests':
            renderRequests();
            break;
        case 'summary':
            renderSummary();
            break;
        case 'timesheet':
            renderTimesheet();
            break;
        case 'conflicts':
            renderConflicts(); // Always refresh conflicts when switching to it
            break;
        case 'notes':
            renderNotes();
            break;
        case 'availability':
            renderAvailability();
            break;
    }
}

async function updateShift() {
    try {
        const shiftId = parseInt(document.getElementById('editShiftId').value);
        const date = document.getElementById('editShiftDate').value;
        const startTime = document.getElementById('editShiftStartTime').value;
        const endTime = document.getElementById('editShiftEndTime').value;
        const staffId = document.getElementById('editShiftStaff').value;
        const participantId = document.getElementById('editShiftParticipant').value || null;
        const locationId = document.getElementById('editShiftLocation').value || null;
        const dutyTypeId = document.getElementById('editShiftDutyType').value;
        const payRateId = document.getElementById('editShiftPayRate').value;
        const status = document.getElementById('editShiftStatus').value;
        const notes = document.getElementById('editShiftNotes').value;

        if (!date || !staffId || !dutyTypeId) {
            showNotification('Please fill required fields', 'error');
            return;
        }

        // Get current shift data before updating for undo
        const currentShift = shifts.find(s => s.id === shiftId);
        if (!currentShift) {
            showNotification('Shift not found', 'error');
            return;
        }

        const updateData = {
            date,
            start_time: startTime || null,
            end_time: endTime || null,
            staff_id: staffId,
            participant_id: participantId,
            location_id: locationId,
            duty_type_id: dutyTypeId,
            status: status,
            notes: notes || null,
            updated_at: new Date().toISOString()
        };

        if (payRateId) {
            updateData.pay_override_id = payRateId;
        }

        // Calculate new duration
        const selectedDutyType = dutyTypes.find(d => d.id === dutyTypeId);
        if (selectedDutyType?.name.toLowerCase().includes('sleepover')) {
            updateData.duration_hours = 2;
        } else if (startTime && endTime) {
            const start = new Date(`2000-01-01T${startTime}`);
            let end = new Date(`2000-01-01T${endTime}`);
            if (end <= start) end.setDate(end.getDate() + 1);
            updateData.duration_hours = (end - start) / (1000 * 60 * 60);
        }

        // Save to undo stack BEFORE making the change
        UndoRedoManager.saveState('update_shift', {
            id: shiftId,
            previous: {
                date: currentShift.date,
                start_time: currentShift.start_time,
                end_time: currentShift.end_time,
                staff_id: currentShift.staff_id,
                participant_id: currentShift.participant_id,
                location_id: currentShift.location_id,
                duty_type_id: currentShift.duty_type_id,
                pay_override_id: currentShift.pay_override_id,
                status: currentShift.status,
                notes: currentShift.notes,
                duration_hours: currentShift.duration_hours
            },
            current: updateData
        });

        console.log('Updating shift with data:', updateData);

        const { error } = await supabaseClient
            .from('shifts')
            .update(updateData)
            .eq('id', shiftId);

        if (error) throw error;

        showNotification('Shift updated successfully', 'success');
        closeModal('editShiftModal');
        await loadShifts();
        
        // ADD THIS: Refresh conflicts view if it's active
        if (currentView === 'conflicts') {
            await renderConflicts();
        } else {
            renderCurrentView();
        }

    } catch (error) {
        console.error('Error updating shift:', error);
        showNotification('Failed to update shift: ' + error.message, 'error');
    }
}


async function approveTransfer(requestId) {
    try {
        const { data: request } = await supabaseClient
            .from('transfer_requests')
            .select('*')
            .eq('id', requestId)
            .single();
        
        if (!request) throw new Error('Request not found');
        
        // Update the shift with new staff
        if (request.to_staff_id) {
            await supabaseClient
                .from('shifts')
                .update({ 
                    staff_id: request.to_staff_id,
                    transfer_status: 'completed',
                    transfer_approved_by: currentStaffData?.id,
                    updated_at: new Date().toISOString()
                })
                .eq('id', request.shift_id);
        }
        
        // Update request status
        await supabaseClient
            .from('transfer_requests')
            .update({ 
                status: 'approved',
                responded_at: new Date().toISOString(),
                responded_by: currentStaffData?.id
            })
            .eq('id', requestId);
        
        showNotification('Transfer approved successfully', 'success');
        
        // Refresh the appropriate view
        await refreshAfterChange();
        
    } catch (error) {
        console.error('Error approving transfer:', error);
        showNotification('Failed to approve transfer: ' + error.message, 'error');
    }
}


async function denyTransfer(requestId) {
    try {
        await supabaseClient
            .from('transfer_requests')
            .update({ 
                status: 'denied',
                responded_at: new Date().toISOString(),
                responded_by: currentStaffData?.id
            })
            .eq('id', requestId);
        
        showNotification('Transfer denied', 'info');
        renderRequests();
        
    } catch (error) {
        console.error('Error denying transfer:', error);
        showNotification('Failed to deny transfer: ' + error.message, 'error');
    }
}

async function approveAdjustment(requestId) {
    try {
        const { data: request } = await supabaseClient
            .from('shift_adjustment_requests')
            .select('*')
            .eq('id', requestId)
            .single();
        
        if (!request) throw new Error('Request not found');
        
        // Update the shift with new times
        await supabaseClient
            .from('shifts')
            .update({ 
                start_time: request.new_start_time,
                end_time: request.new_end_time,
                adjustment_status: 'approved',
                adjustment_approved_by: currentStaffData?.id,
                updated_at: new Date().toISOString()
            })
            .eq('id', request.shift_id);
        
        // Update request status
        await supabaseClient
            .from('shift_adjustment_requests')
            .update({ 
                status: 'approved',
                approved_at: new Date().toISOString(),
                approved_by: currentStaffData?.id
            })
            .eq('id', requestId);
        
        showNotification('Adjustment approved successfully', 'success');
        
        // Refresh the appropriate view
        await refreshAfterChange();
        
    } catch (error) {
        console.error('Error approving adjustment:', error);
        showNotification('Failed to approve adjustment: ' + error.message, 'error');
    }
}
async function denyAdjustment(requestId) {
    try {
        await supabaseClient
            .from('shift_adjustment_requests')
            .update({ 
                status: 'denied',
                approved_at: new Date().toISOString(),
                approved_by: currentStaffData?.id
            })
            .eq('id', requestId);
        
        showNotification('Adjustment denied', 'info');
        
        // Refresh the appropriate view
        await refreshAfterChange();
        
    } catch (error) {
        console.error('Error denying adjustment:', error);
        showNotification('Failed to deny adjustment: ' + error.message, 'error');
    }
}

        function renderCurrentView() {
            console.log(`Rendering ${currentView} view with ${filteredShifts.length} shifts`);
            
            switch (currentView) {
                case 'table':
                    renderTable();
                    break;
                case 'summary':
                    renderSummary();
                    break;
                case 'timesheet':
                    renderTimesheet();
                    break;
                case 'notes':
                    renderNotes();
                    break;
            }
        }


        async function renderAvailability() {
    const availabilityContent = document.getElementById('availabilityContent');
    if (!availabilityContent) {
        const availabilityView = document.getElementById('availabilityView');
        if (availabilityView) {
            availabilityView.innerHTML = `
                <div class="table-container">
                    <header class="table-header">
                        <h2 class="table-title">Staff Availability Management</h2>
                        <div class="table-actions">
                            <button class="btn btn-primary btn-sm" onclick="showAvailabilityModal()">Set Availability</button>
                            <button class="btn btn-outline btn-sm" onclick="renderAvailability()">Refresh</button>
                        </div>
                    </header>
                    <div class="card-content" id="availabilityContent">
                        <div class="loading">
                            <div class="spinner"></div>
                            <span>Loading availability...</span>
                        </div>
                    </div>
                </div>
            `;
        }
        return;
    }
    
    try {
        // Load staff availability for the current week
        const weekStart = getWeekStart(new Date());
        const weekEnd = new Date(weekStart);
        weekEnd.setDate(weekEnd.getDate() + 6);
        
        const { data: availability } = await supabaseClient
            .from('staff_availability')
            .select(`
                *,
                staff:staff_id(first_name, last_name)
            `)
            .gte('date', weekStart.toISOString().split('T')[0])
            .lte('date', weekEnd.toISOString().split('T')[0])
            .order('date');
        
        let html = `
            <style>
                .availability-grid {
                    display: grid;
                    grid-template-columns: 150px repeat(7, 1fr);
                    gap: 1px;
                    background: #e9ecef;
                    border-radius: 8px;
                    overflow: hidden;
                    margin-bottom: 24px;
                }
                
                .availability-cell {
                    background: white;
                    padding: 12px;
                    min-height: 50px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 14px;
                }
                
                .availability-header {
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    font-weight: 600;
                    font-size: 12px;
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                }
                
                .availability-name {
                    background: #f8f9fa;
                    font-weight: 500;
                    justify-content: flex-start;
                    padding-left: 16px;
                }
                
                .available {
                    background: #d4edda;
                    color: #155724;
                }
                
                .unavailable {
                    background: #f8d7da;
                    color: #721c24;
                }
                
                .partial {
                    background: #fff3cd;
                    color: #856404;
                }
            </style>
            
            <div class="availability-grid">
                <div class="availability-cell availability-header">Staff</div>
        `;
        
        // Add day headers
        const days = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
        days.forEach((day, index) => {
            const date = new Date(weekStart);
            date.setDate(date.getDate() + index);
            html += `
                <div class="availability-cell availability-header">
                    ${day}<br>${date.getDate()}
                </div>
            `;
        });
        
        // Group availability by staff
        const staffAvailability = {};
        availability?.forEach(av => {
            const staffId = av.staff_id;
            if (!staffAvailability[staffId]) {
                staffAvailability[staffId] = {
                    staff: av.staff,
                    days: {}
                };
            }
            const dayIndex = new Date(av.date).getDay();
            staffAvailability[staffId].days[dayIndex] = av.available;
        });
        
        // Render each staff member's availability
        Object.values(staffAvailability).forEach(sa => {
            html += `<div class="availability-cell availability-name">${sa.staff.first_name} ${sa.staff.last_name}</div>`;
            
            for (let i = 0; i < 7; i++) {
                const dayIndex = i === 6 ? 0 : i + 1; // Adjust for Monday start
                const isAvailable = sa.days[dayIndex];
                const className = isAvailable === true ? 'available' : 
                                 isAvailable === false ? 'unavailable' : '';
                const text = isAvailable === true ? '‚úì' : 
                           isAvailable === false ? '‚úó' : '-';
                
                html += `<div class="availability-cell ${className}">${text}</div>`;
            }
        });
        
        html += '</div>';
        
        availabilityContent.innerHTML = html;
        
    } catch (error) {
        console.error('Error loading availability:', error);
        availabilityContent.innerHTML = '<div class="error">Failed to load availability</div>';
    }
}
function renderTable() {
    const tbody = document.getElementById('shiftsTableBody');
    
    if (!tbody) {
        console.error('shiftsTableBody element not found');
        return;
    }
    
    if (filteredShifts.length === 0) {
        tbody.innerHTML = `
            <tr>
                <td colspan="8" class="empty-state">
                    <h3>No shifts found</h3>
                    <p>Try adjusting your date range or filters</p>
                    <button class="btn btn-outline btn-sm" onclick="clearAllFilters()">Clear Filters</button>
                    <button class="btn btn-primary btn-sm" onclick="showAddShiftModal()" style="margin-left: 12px;">Add Shift</button>
                </td>
            </tr>
        `;
        return;
    }

    // Group shifts by date
    const groupedShifts = groupShiftsByDate(filteredShifts);
    
    let html = '';
    
    Object.keys(groupedShifts).sort().forEach(date => {
        const dayShifts = groupedShifts[date];
        const dayStats = calculateDayStats(dayShifts);
        
        // Day header
        html += `
            <tr class="day-header">
                <td colspan="8">
                    ${formatDateLong(date)} 
                    <span class="day-stats">
                        ${dayStats.shifts} shifts | ${formatHours(dayStats.totalHours)}h | $${dayStats.totalPay.toFixed(2)}
                    </span>
                </td>
            </tr>
        `;
        
        for (const shift of dayShifts) {
    html += renderShiftRow(shift, date);  // No await needed if renderShiftRow is NOT async
}
    });

    tbody.innerHTML = html;
}

async function renderShiftRow(shift, date) {
    const staff = shift.staff || {};
    const participant = shift.participant || {};
    const location = shift.location || {};
    const dutyType = shift.duty_type || {};
    
    // FIX #3: Check staff availability for leave indicator
    let leaveIndicator = '';
    try {
        const { data: availabilityCheck } = await supabaseClient
            .from('staff_availability')
            .select('*')
            .eq('staff_id', shift.staff_id)
            .eq('date', shift.date)
            .eq('available', false)
            .single();
        
        if (availabilityCheck) {
            const leaveType = availabilityCheck.reason || 'Leave';
            const badgeColor = leaveType.toLowerCase().includes('sick') ? 'danger' : 
                              leaveType.toLowerCase().includes('annual') ? 'info' : 'warning';
            leaveIndicator = `<span class="badge badge-${badgeColor}" style="font-size: 10px; margin-left: 4px;" title="${leaveType}">ON LEAVE</span>`;
        }
    } catch (error) {
        // No leave record found, continue without indicator
    }
    
    // Get participant color
    const participantColor = getParticipantColor(shift.participant_id);
    
    // Check if this is a care home resident
    const isCareHomeResident = participant.address && 
        Array.from(careHomes.keys()).some(address => 
            participant.address.toLowerCase().includes(address)
        );
    
    // Client display with colored badge
    const clientDisplay = participant.first_name ? 
        `<span class="participant-badge" style="background: ${participantColor};">
            ${participant.first_name} ${participant.last_name}
            ${isCareHomeResident ? ' üè†' : ''}
        </span>` : 
        (location.name ? `<span class="location-badge">${location.name}</span>` : 'TBA');
    
    // Time display
    const timeDisplay = shift.start_time && shift.end_time ? 
        `${formatTime12Hour(shift.start_time)} - ${formatTime12Hour(shift.end_time)}` : 
        (shift.duty_type?.name?.toLowerCase().includes('sleepover') ? 'Sleepover' : '-');
    
    // Hours and pay with proper styling
    const hours = shift.calculated_hours?.total || 0;
    const pay = shift.calculated_pay || 0;
    
    // Determine if shift can be edited (based on role and status)
    const canEdit = currentUserRole !== 'staff' && shift.status !== 'completed';
    
    // Status badge
    let statusClass = 'badge-secondary';
    if (shift.status === 'confirmed') statusClass = 'badge-success';
    else if (shift.status === 'pending') statusClass = 'badge-warning';
    else if (shift.status === 'completed') statusClass = 'badge-info';
    else if (shift.status === 'cancelled') statusClass = 'badge-danger';
    
    const shiftActions = renderShiftActions(shift);
    
    return `
        <tr class="shift-row" data-shift-id="${shift.id}">
            <td>${formatDate(shift.date)}</td>
            <td class="time-cell">${timeDisplay}</td>
            <td>
                ${staff.first_name || ''} ${staff.last_name || ''}
                ${leaveIndicator}
            </td>
            <td>${clientDisplay}</td>
            <td>${location.name || participant.address || '-'}</td>
            <td>${dutyType.name || '-'}</td>
            <td><span class="badge ${statusClass}">${shift.status || 'pending'}</span></td>
            <td class="actions-cell">${shiftActions}</td>
        </tr>
    `;
}

async function loadParticipantTemplates(participantId) {
    if (!participantId) {
        const templateSelect = document.getElementById('shiftTemplate');
        if (templateSelect) {
            templateSelect.innerHTML = '<option value="">-- Select Template --</option>';
            templateSelect.style.display = 'none';
        }
        return;
    }
    
    try {
        // Check if templates table exists and load templates
        const { data: templates, error } = await supabaseClient
            .from('participant_shift_templates')
            .select('*')
            .eq('participant_id', participantId)
            .eq('is_active', true)
            .order('template_name');
        
        const templateSelect = document.getElementById('shiftTemplate');
        if (!templateSelect) return;
        
        templateSelect.innerHTML = '<option value="">-- No Template --</option>';
        
        if (!error && templates && templates.length > 0) {
            templates.forEach(t => {
                const timeDisplay = t.start_time && t.end_time ? 
                    `${formatTime12Hour(t.start_time)} - ${formatTime12Hour(t.end_time)}` : 
                    'Times not set';
                
                // Get duty type name if available
                const dutyType = dutyTypes.find(d => d.id === t.duty_type_id);
                const dutyDisplay = dutyType ? ` | ${dutyType.name}` : '';
                
                templateSelect.innerHTML += `
                    <option value='${JSON.stringify(t)}'>
                        ${t.template_name} (${timeDisplay}${dutyDisplay})
                    </option>`;
            });
            
            // Show template selector and add visual indicator
            templateSelect.style.display = 'block';
            templateSelect.parentElement.style.display = 'block';
            
            // Add info message
            const infoDiv = document.createElement('div');
            infoDiv.className = 'text-info small mt-1';
            infoDiv.textContent = `${templates.length} template(s) available for this participant`;
            if (!templateSelect.parentElement.querySelector('.text-info')) {
                templateSelect.parentElement.appendChild(infoDiv);
            }
        } else {
            templateSelect.style.display = 'none';
            templateSelect.parentElement.style.display = 'none';
        }
    } catch (error) {
        console.log('Templates table not available or error loading:', error);
        const templateSelect = document.getElementById('shiftTemplate');
        if (templateSelect) {
            templateSelect.style.display = 'none';
            templateSelect.parentElement.style.display = 'none';
        }
    }
}

function applyShiftTemplate(templateJson) {
    if (!templateJson) {
        // Clear template-related fields if no template selected
        return;
    }
    
    try {
        const template = JSON.parse(templateJson);
        
        // Apply template values to form with validation
        if (template.start_time) {
            const startTimeInput = document.getElementById('shiftStartTime');
            if (startTimeInput) startTimeInput.value = template.start_time;
        }
        
        if (template.end_time) {
            const endTimeInput = document.getElementById('shiftEndTime');
            if (endTimeInput) endTimeInput.value = template.end_time;
        }
        
        if (template.duty_type_id) {
            const dutyTypeSelect = document.getElementById('shiftDutyType');
            if (dutyTypeSelect) {
                dutyTypeSelect.value = template.duty_type_id;
                // Trigger any onchange handlers
                if (dutyTypeSelect.onchange) dutyTypeSelect.onchange();
            }
        }
        
        if (template.location_id) {
            const locationSelect = document.getElementById('shiftLocation');
            if (locationSelect) locationSelect.value = template.location_id;
        }
        
        if (template.pay_rate_id) {
            const payRateSelect = document.getElementById('shiftPayRate');
            if (payRateSelect) payRateSelect.value = template.pay_rate_id;
        }
        
        // Add any template notes to the notes field
        if (template.notes) {
            const notesField = document.getElementById('shiftNotes');
            if (notesField) {
                notesField.value = template.notes + (notesField.value ? '\n' + notesField.value : '');
            }
        }
        
        showNotification(`Template "${template.template_name}" applied successfully`, 'success');
        
        // Highlight applied fields briefly
        const appliedFields = ['shiftStartTime', 'shiftEndTime', 'shiftDutyType', 'shiftLocation'];
        appliedFields.forEach(fieldId => {
            const field = document.getElementById(fieldId);
            if (field && field.value) {
                field.style.backgroundColor = '#e8f5e9';
                setTimeout(() => {
                    field.style.backgroundColor = '';
                }, 2000);
            }
        });
        
    } catch (error) {
        console.error('Error applying template:', error);
        showNotification('Failed to apply template', 'error');
    }
}

async function renderAvailability() {
    const availabilityContent = document.getElementById('availabilityContent');
    if (!availabilityContent) {
        const availabilityView = document.getElementById('availabilityView');
        if (availabilityView) {
            availabilityView.innerHTML = `
                <div class="table-container">
                    <header class="table-header">
                        <h2 class="table-title">Staff Availability & Leave</h2>
                        <div class="table-actions">
                            <button class="btn btn-primary btn-sm" onclick="showAvailabilityModal()">Set Availability</button>
                            <button class="btn btn-outline btn-sm" onclick="renderAvailability()">Refresh</button>
                        </div>
                    </header>
                    <div class="card-content" id="availabilityContent">
                        <div class="loading">
                            <div class="spinner"></div>
                            <span>Loading availability...</span>
                        </div>
                    </div>
                </div>
            `;
            availabilityContent = document.getElementById('availabilityContent');
        }
    }
    
    if (!availabilityContent) return;
    
    try {
        // Get current week dates
        const weekStart = new Date(currentWeekStart);
        const weekEnd = new Date(weekStart);
        weekEnd.setDate(weekEnd.getDate() + 6);
        
        // FIX #5: Load leave data for the week
        const { data: weekLeave } = await supabaseClient
            .from('staff_availability')
            .select('*, staff:staff_id(first_name, last_name)')
            .gte('date', weekStart.toISOString().split('T')[0])
            .lte('date', weekEnd.toISOString().split('T')[0])
            .eq('available', false)
            .order('date');
        
        // Load regular availability patterns
        const { data: availabilityPatterns } = await supabaseClient
            .from('staff_weekly_availability')
            .select('*, staff:staff_id(first_name, last_name)')
            .order('staff_id, day_of_week');
        
        // Build enhanced availability view
        let html = `
            <style>
                .availability-wrapper {
                    background: white;
                    border-radius: var(--radius-lg);
                    overflow: hidden;
                    margin-bottom: 20px;
                }
                .availability-tabs {
                    display: flex;
                    background: var(--bg-light);
                    border-bottom: 2px solid var(--border-color);
                }
                .availability-tab {
                    flex: 1;
                    padding: 15px;
                    text-align: center;
                    cursor: pointer;
                    background: transparent;
                    border: none;
                    font-weight: 500;
                    transition: all 0.3s;
                }
                .availability-tab.active {
                    background: white;
                    border-bottom: 3px solid var(--primary-color);
                    color: var(--primary-color);
                }
                .availability-content {
                    padding: 20px;
                }
                .week-grid {
                    display: grid;
                    grid-template-columns: repeat(7, 1fr);
                    gap: 10px;
                    margin-top: 20px;
                }
                .day-card {
                    background: white;
                    border: 1px solid var(--border-color);
                    border-radius: 8px;
                    min-height: 200px;
                    overflow: hidden;
                }
                .day-header {
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: white;
                    padding: 12px;
                    text-align: center;
                }
                .day-header.weekend {
                    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
                }
                .day-date {
                    font-size: 11px;
                    opacity: 0.9;
                }
                .day-name {
                    font-weight: 600;
                    font-size: 14px;
                }
                .day-content {
                    padding: 12px;
                    max-height: 150px;
                    overflow-y: auto;
                }
                .leave-indicator {
                    margin-bottom: 8px;
                    padding: 8px;
                    border-radius: 6px;
                    font-size: 12px;
                    background: var(--bg-light);
                    border-left: 3px solid;
                }
                .leave-indicator.annual {
                    border-color: #17a2b8;
                    background: #d1ecf1;
                }
                .leave-indicator.sick {
                    border-color: #dc3545;
                    background: #f8d7da;
                }
                .leave-indicator.personal {
                    border-color: #ffc107;
                    background: #fff3cd;
                }
                .leave-indicator.other {
                    border-color: #6c757d;
                    background: #e2e3e5;
                }
                .staff-name {
                    font-weight: 600;
                    color: var(--text-primary);
                }
                .leave-type {
                    font-size: 10px;
                    text-transform: uppercase;
                    opacity: 0.8;
                }
                .availability-summary {
                    background: var(--bg-light);
                    padding: 15px;
                    border-radius: 8px;
                    margin-bottom: 20px;
                }
                .summary-stats {
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                    gap: 15px;
                }
                .stat-item {
                    text-align: center;
                }
                .stat-value {
                    font-size: 24px;
                    font-weight: 700;
                    color: var(--primary-color);
                }
                .stat-label {
                    font-size: 12px;
                    color: var(--text-muted);
                    text-transform: uppercase;
                }
            </style>
            
            <div class="availability-wrapper">
                <div class="availability-tabs">
                    <button class="availability-tab active" onclick="switchAvailabilityView('week')">
                        Week View
                    </button>
                    <button class="availability-tab" onclick="switchAvailabilityView('staff')">
                        Staff Patterns
                    </button>
                    <button class="availability-tab" onclick="switchAvailabilityView('summary')">
                        Summary
                    </button>
                </div>
                
                <div class="availability-content">
                    <div id="weekView">
                        <h3>Week of ${formatDateShort(weekStart.toISOString())}</h3>
                        
                        <div class="availability-summary">
                            <div class="summary-stats">
                                <div class="stat-item">
                                    <div class="stat-value">${staff.length}</div>
                                    <div class="stat-label">Total Staff</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-value">${weekLeave ? weekLeave.length : 0}</div>
                                    <div class="stat-label">On Leave</div>
                                </div>
                                <div class="stat-item">
                                    <div class="stat-value">${staff.length - (weekLeave ? weekLeave.length : 0)}</div>
                                    <div class="stat-label">Available</div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="week-grid">
        `;
        
        // Create day cards
        const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        
        for (let day = 0; day < 7; day++) {
            const currentDate = new Date(weekStart);
            currentDate.setDate(currentDate.getDate() + day);
            const dateStr = currentDate.toISOString().split('T')[0];
            const dayName = dayNames[currentDate.getDay()];
            const isWeekend = currentDate.getDay() === 0 || currentDate.getDay() === 6;
            
            // Get leave for this day
            const dayLeave = weekLeave ? weekLeave.filter(l => l.date === dateStr) : [];
            
            html += `
                <div class="day-card" data-date="${dateStr}">
                    <div class="day-header ${isWeekend ? 'weekend' : ''}">
                        <div class="day-name">${dayName}</div>
                        <div class="day-date">${formatDateShort(dateStr)}</div>
                    </div>
                    <div class="day-content">
            `;
            
            if (dayLeave.length > 0) {
                dayLeave.forEach(leave => {
                    const leaveType = leave.reason || 'Leave';
                    let typeClass = 'other';
                    if (leaveType.toLowerCase().includes('annual')) typeClass = 'annual';
                    else if (leaveType.toLowerCase().includes('sick')) typeClass = 'sick';
                    else if (leaveType.toLowerCase().includes('personal')) typeClass = 'personal';
                    
                    html += `
                        <div class="leave-indicator ${typeClass}">
                            <div class="staff-name">
                                ${leave.staff.first_name} ${leave.staff.last_name}
                            </div>
                            <div class="leave-type">${leaveType}</div>
                        </div>
                    `;
                });
            } else {
                html += `
                    <div style="text-align: center; padding: 40px 10px; color: var(--text-muted);">
                        <div style="font-size: 24px; margin-bottom: 5px;">‚úÖ</div>
                        <div style="font-size: 12px;">All Available</div>
                    </div>
                `;
            }
            
            html += `
                    </div>
                </div>
            `;
        }
        
        html += `
                        </div>
                    </div>
                    
                    <div id="staffView" style="display: none;">
                        <h3>Staff Availability Patterns</h3>
                        <div style="margin-top: 20px;">
                            <!-- Staff patterns will be loaded here -->
                        </div>
                    </div>
                    
                    <div id="summaryView" style="display: none;">
                        <h3>Availability Summary</h3>
                        <div style="margin-top: 20px;">
                            <!-- Summary statistics will be loaded here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="availability-legend" style="margin-top: 20px; padding: 15px; background: var(--bg-light); border-radius: 8px;">
                <strong>Legend:</strong>
                <span class="badge badge-info" style="margin: 0 5px;">Annual Leave</span>
                <span class="badge badge-danger" style="margin: 0 5px;">Sick Leave</span>
                <span class="badge badge-warning" style="margin: 0 5px;">Personal Leave</span>
                <span class="badge badge-secondary" style="margin: 0 5px;">Other</span>
            </div>
        `;
        
        availabilityContent.innerHTML = html;
        
    } catch (error) {
        console.error('Error loading availability:', error);
        availabilityContent.innerHTML = '<div class="error">Failed to load availability data</div>';
    }
}

// This goes in the modal HTML structure - add after participant select
function getAddShiftModalTemplateHTML() {
    return `
        <div class="form-group" id="templateGroup" style="display: none;">
            <label>Use Template (Optional)</label>
            <select id="shiftTemplate" class="form-control" onchange="applyShiftTemplate(this.value)">
                <option value="">-- Select Template --</option>
            </select>
            <small class="form-text text-muted">
                Templates provide pre-filled shift settings for this participant
            </small>
        </div>
    `;
}
// Helper function to switch availability views
function switchAvailabilityView(view) {
    // Update tab active states
    document.querySelectorAll('.availability-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    event.target.classList.add('active');
    
    // Show/hide views
    document.getElementById('weekView').style.display = view === 'week' ? 'block' : 'none';
    document.getElementById('staffView').style.display = view === 'staff' ? 'block' : 'none';
    document.getElementById('summaryView').style.display = view === 'summary' ? 'block' : 'none';
}

// Add event listener for participant selection to load templates
function setupParticipantTemplateLoader() {
    const participantSelect = document.getElementById('shiftParticipant');
    if (participantSelect) {
        participantSelect.addEventListener('change', function() {
            loadParticipantTemplates(this.value);
        });
    }
    
    const participantInput = document.getElementById('shiftParticipantInput');
    if (participantInput) {
        participantInput.addEventListener('change', function() {
            const hiddenSelect = document.getElementById('shiftParticipant');
            if (hiddenSelect && hiddenSelect.value) {
                loadParticipantTemplates(hiddenSelect.value);
            }
        });
    }
}


function onParticipantSelect(participantSelectId, locationSelectId) {
    const participantSelect = document.getElementById(participantSelectId);
    const locationSelect = document.getElementById(locationSelectId);
    
    if (!participantSelect.value) {
        locationSelect.value = '';
        return;
    }
    
    const selectedParticipant = participants.find(p => p.id === participantSelect.value);
    if (!selectedParticipant) return;
    
    // Auto-select location based on participant
    let foundLocation = false;
    
    // Check if participant is in a care home
    if (selectedParticipant.address) {
        const participantAddress = selectedParticipant.address.toLowerCase();
        
        // Check for care homes
        careHomes.forEach((careHome, careHomeAddress) => {
            if (participantAddress.includes(careHomeAddress)) {
                const careHomeLocation = locations.find(l => 
                    l.name.toLowerCase().includes('saunders') || 
                    (l.address && l.address.toLowerCase().includes(careHomeAddress))
                );
                
                if (careHomeLocation) {
                    locationSelect.value = careHomeLocation.id;
                    foundLocation = true;
                }
            }
        });
    }
    
    // If not in care home, select generic home location
    if (!foundLocation) {
        const homeLocation = locations.find(l => 
            l.name.toLowerCase().includes('home') ||
            l.name.toLowerCase().includes('client')
        );
        
        if (homeLocation) {
            locationSelect.value = homeLocation.id;
        }
    }
} 
function showOverlapTooltip(event, shiftId) {
    // Implementation for hover tooltip showing overlap details
    const tooltip = document.createElement('div');
    tooltip.className = 'overlap-tooltip';
    tooltip.id = 'overlapTooltip';
    
    const shift = shifts.find(s => s.id === shiftId);
    if (shift?.overlap_info) {
        tooltip.innerHTML = `
            <strong>${shift.overlap_info.ratio} Care Ratio</strong><br>
            ${shift.overlap_info.staff.map(s => 
                `${s.staff.first_name} ${s.staff.last_name}: ${s.time}`
            ).join('<br>')}
        `;
        
        tooltip.style.position = 'absolute';
        tooltip.style.left = event.pageX + 10 + 'px';
        tooltip.style.top = event.pageY + 10 + 'px';
        
        document.body.appendChild(tooltip);
    }
}

function hideOverlapTooltip() {
    const tooltip = document.getElementById('overlapTooltip');
    if (tooltip) tooltip.remove();
}

        function renderShiftActions(shift) {
            let actions = [];
            
            // Admin/Manager can edit any shift
            if (currentUserRole === 'admin' || currentUserRole === 'manager') {
                actions.push(`<button class="btn btn-outline btn-sm" onclick="editShift(${shift.id})">Edit</button>`);
                actions.push(`<button class="btn btn-danger btn-sm" onclick="deleteShiftConfirm(${shift.id})">Delete</button>`);
            }
            
            // All users can add notes
            actions.push(`<button class="btn btn-outline btn-sm" onclick="addNoteToShift(${shift.id})">Note</button>`);
            
            return actions.join('');
        }

        function groupShiftsByDate(shifts) {
            const groups = {};
            shifts.forEach(shift => {
                if (!groups[shift.date]) {
                    groups[shift.date] = [];
                }
                groups[shift.date].push(shift);
            });
            return groups;
        }

        function calculateDayStats(dayShifts) {
            return dayShifts.reduce((stats, shift) => {
                const hours = shift.calculated_hours || { total: 0 };
                stats.shifts++;
                stats.totalHours += hours.total;
                stats.totalPay += shift.calculated_pay || 0;
                return stats;
            }, { shifts: 0, totalHours: 0, totalPay: 0 });
        }

        function generateHourBreakdownTooltip(hours) {
            const parts = [];
            if (hours.weekdayDay > 0) parts.push(`Day: ${formatHours(hours.weekdayDay)}h`);
            if (hours.weekdayEvening > 0) parts.push(`Evening: ${formatHours(hours.weekdayEvening)}h`);
            if (hours.weekdayNight > 0) parts.push(`Night: ${formatHours(hours.weekdayNight)}h`);
            if (hours.saturday > 0) parts.push(`Saturday: ${formatHours(hours.saturday)}h`);
            if (hours.sunday > 0) parts.push(`Sunday: ${formatHours(hours.sunday)}h`);
            if (hours.publicHoliday > 0) parts.push(`Holiday: ${formatHours(hours.publicHoliday)}h`);
            if (hours.sleepover > 0) parts.push(`Sleepover: ${formatHours(hours.sleepover)}h`);
            
            return parts.join(' | ') || 'No breakdown available';
        }

        function generatePayBreakdownDisplay(hours) {
            const parts = [];
            if (hours.weekdayDay > 0) parts.push(`D:${formatHours(hours.weekdayDay)}`);
            if (hours.weekdayEvening > 0) parts.push(`E:${formatHours(hours.weekdayEvening)}`);
            if (hours.weekdayNight > 0) parts.push(`N:${formatHours(hours.weekdayNight)}`);
            if (hours.saturday > 0) parts.push(`Sa:${formatHours(hours.saturday)}`);
            if (hours.sunday > 0) parts.push(`Su:${formatHours(hours.sunday)}`);
            if (hours.publicHoliday > 0) parts.push(`PH:${formatHours(hours.publicHoliday)}`);
            if (hours.sleepover > 0) parts.push(`SL:${formatHours(hours.sleepover)}`);
            
            return parts.join(' ‚Ä¢ ') || '‚Äî';
        }

        // ========================================
        // SEARCHABLE DROPDOWNS - FIXED
        // ========================================

        function populateFilterDropdowns() {
            console.log('Populating filter dropdowns...');

            // Staff filter dropdown
            const staffList = document.getElementById('staffFilterList');
            if (staffList && staff.length > 0) {
                staffList.innerHTML = '';
                staff.forEach(s => {
                    const option = document.createElement('option');
                    option.value = `${s.first_name} ${s.last_name}`;
                    option.setAttribute('data-id', s.id);
                    staffList.appendChild(option);
                });
            }

            // Participant filter dropdown
            const participantList = document.getElementById('participantFilterList');
            if (participantList && participants.length > 0) {
                participantList.innerHTML = '';
                participants.forEach(p => {
                    const option = document.createElement('option');
                    option.value = `${p.first_name} ${p.last_name}`;
                    option.setAttribute('data-id', p.id);
                    participantList.appendChild(option);
                });
            }
        }

        function updateStaffFilter() {
            const input = document.getElementById('staffFilterInput');
            const selectedStaff = staff.find(s => `${s.first_name} ${s.last_name}` === input.value);
            staffFilterValue = selectedStaff ? selectedStaff.id : '';
            console.log('Staff filter updated:', staffFilterValue);
            applyFilters();
        }

        function updateParticipantFilter() {
    const input = document.getElementById('participantFilterInput');
    const selectedParticipant = participants.find(p => 
        `${p.first_name} ${p.last_name}` === input.value
    );
    participantFilterValue = selectedParticipant ? selectedParticipant.id : '';
    
    // Remove any existing care home filter
    const existingFilter = document.getElementById('careHomeResidentFilter');
    if (existingFilter) existingFilter.remove();
    
    // Check if selected participant is a care home
    if (selectedParticipant) {
        let foundCareHome = null;
        
        // Check if this participant ID is a main care home entity
        careHomes.forEach((ch, address) => {
            if (ch.mainEntityId === selectedParticipant.id) {
                foundCareHome = ch;
                activeCareHomeFilter = address;
            }
        });
        
        // If found, show the resident filter
        if (foundCareHome) {
            showCareHomeResidentFilter(foundCareHome);
        } else {
            activeCareHomeFilter = null;
        }
    } else {
        activeCareHomeFilter = null;
    }
    
    console.log('Participant filter updated:', participantFilterValue);
    applyFilters();
}

function showCareHomeResidentFilter(careHome) {
    const filterRow = document.querySelector('.filter-row');
    
    // Remove existing filter if present
    const existingFilter = document.getElementById('careHomeResidentFilter');
    if (existingFilter) existingFilter.remove();
    
    // Debug log
    console.log('Showing care home filter for:', careHome);
    console.log('Residents:', careHome.residents);
    
    // Create filter UI
    const careHomeFilter = document.createElement('div');
    careHomeFilter.className = 'filter-group';
    careHomeFilter.id = 'careHomeResidentFilter';
    
    const residentCount = careHome.residents.length;
    
    // Build the HTML
    let filterHTML = `
        <label>${careHome.name} Filter</label>
        <div style="
            background: var(--bg-light); 
            border: 1px solid var(--border-color); 
            border-radius: var(--radius-md);
            padding: 12px;
            max-height: 250px;
            overflow-y: auto;
        ">
    `;
    
    // Add general shifts checkbox if there's a main entity
    if (careHome.mainEntityId) {
        filterHTML += `
            <div style="margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid var(--border-color);">
                <label style="display: flex; align-items: center; cursor: pointer; font-weight: 600;">
                    <input type="checkbox" id="includeGeneralShifts" 
                           checked
                           onchange="applyCareHomeFilter()">
                    <span style="margin-left: 8px;">Include General ${careHome.name} Shifts</span>
                </label>
            </div>
        `;
    }
    
    // Add residents section
    if (residentCount > 0) {
        filterHTML += `
            <div style="margin-bottom: 8px;">
                <label style="display: flex; align-items: center; cursor: pointer; font-weight: 600;">
                    <input type="checkbox" id="selectAllResidents" 
                           onchange="toggleAllResidents(this)" checked>
                    <span style="margin-left: 8px;">All Residents (${residentCount})</span>
                </label>
            </div>
        `;
        
        // Add each resident
        careHome.residents.forEach(resident => {
            filterHTML += `
                <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 4px; padding-left: 20px;">
                    <input type="checkbox" class="resident-checkbox" 
                           value="${resident.id}" 
                           data-name="${resident.first_name} ${resident.last_name}"
                           checked
                           onchange="applyCareHomeFilter()">
                    <span style="margin-left: 8px;">${resident.first_name} ${resident.last_name}</span>
                </label>
            `;
        });
    } else {
        // No residents but show shifts for the care home entity
        filterHTML += `
            <p style="color: var(--text-muted); text-align: center; margin: 20px 0;">
                No individual residents found.<br>
                ${careHome.mainEntityId ? 'Showing general care home shifts only.' : 'No shifts to display.'}
            </p>
        `;
    }
    
    filterHTML += `
        </div>
        <button class="btn btn-outline btn-sm" onclick="clearCareHomeFilter()" style="margin-top: 8px; width: 100%;">
            Clear ${careHome.name} Filter
        </button>
    `;
    
    careHomeFilter.innerHTML = filterHTML;
    
    // Insert after participant filter
    const participantFilterGroup = document.getElementById('participantFilterInput').closest('.filter-group');
    participantFilterGroup.after(careHomeFilter);
    
    showNotification(`Filtering by ${careHome.name} (${residentCount} residents)`, 'info');
    applyCareHomeFilter();
}

// Apply care home filter (generic for any care home)
window.applyCareHomeFilter = function() {
    if (!activeCareHomeFilter) {
        applyFilters();
        return;
    }
    
    const careHome = careHomes.get(activeCareHomeFilter);
    if (!careHome) {
        applyFilters();
        return;
    }
    
    const includeGeneral = document.getElementById('includeGeneralShifts')?.checked ?? false;
    const selectedResidents = Array.from(document.querySelectorAll('.resident-checkbox:checked'))
        .map(cb => cb.value);
    
    // Get other filter values
    const startDate = document.getElementById('startDate').value;
    const endDate = document.getElementById('endDate').value;
    const statusFilter = document.getElementById('statusFilter').value;
    
    // Filter shifts
    filteredShifts = shifts.filter(shift => {
        // Apply standard filters
        if (startDate && shift.date < startDate) return false;
        if (endDate && shift.date > endDate) return false;
        if (statusFilter && shift.status !== statusFilter) return false;
        if (staffFilterValue && shift.staff_id !== staffFilterValue) return false;
        
        // Care home filter
        const isGeneralShift = careHome.mainEntityId && shift.participant_id === careHome.mainEntityId;
        const isResidentShift = selectedResidents.includes(shift.participant_id);
        
        if (includeGeneral && isGeneralShift) return true;
        if (isResidentShift) return true;
        
        return false;
    });
    
    // Update "All Residents" checkbox
    const allCheckbox = document.getElementById('selectAllResidents');
    const residentCheckboxes = document.querySelectorAll('.resident-checkbox');
    if (allCheckbox && residentCheckboxes.length > 0) {
        allCheckbox.checked = selectedResidents.length === residentCheckboxes.length;
    }
    
    console.log(`Filtered to ${filteredShifts.length} shifts for ${careHome.name}`);
    renderCurrentView();
}

// Clear care home filter
window.clearCareHomeFilter = function() {
    document.getElementById('participantFilterInput').value = '';
    participantFilterValue = '';
    activeCareHomeFilter = null;
    
    const careHomeFilter = document.getElementById('careHomeResidentFilter');
    if (careHomeFilter) careHomeFilter.remove();
    
    applyFilters();
}

// Toggle all residents
window.toggleAllResidents = function(checkbox) {
    const residentCheckboxes = document.querySelectorAll('.resident-checkbox');
    residentCheckboxes.forEach(cb => cb.checked = checkbox.checked);
    applyCareHomeFilter();
}
function populateModalDropdowns() {
    // Staff dropdowns
    const staffSelects = [
        document.getElementById('shiftStaff'),
        document.getElementById('editShiftStaff')
    ];
    
    staffSelects.forEach(select => {
        if (select) {
            select.innerHTML = '<option value="">Select Staff</option>';
            staff.forEach(s => {
                select.innerHTML += `<option value="${s.id}">${s.first_name} ${s.last_name}</option>`;
            });
        }
    });

    // Participant dropdowns with onchange handlers
    const participantSelects = [
        document.getElementById('shiftParticipant'),
        document.getElementById('editShiftParticipant')
    ];
    
    participantSelects.forEach((select, index) => {
        if (select) {
            select.innerHTML = '<option value="">Select Participant</option>';
            participants.forEach(p => {
                select.innerHTML += `<option value="${p.id}">${p.first_name} ${p.last_name}</option>`;
            });
            
            // Add onchange event to auto-populate location
            select.onchange = function() {
                const locationSelectId = index === 0 ? 'shiftLocation' : 'editShiftLocation';
                const locationSelect = document.getElementById(locationSelectId);
                
                if (!this.value) {
                    locationSelect.value = '';
                    return;
                }
                
                const selectedParticipant = participants.find(p => p.id === this.value);
                if (!selectedParticipant) return;
                
                // Check if participant is in a care home
                let foundCareHome = false;
                
                // Check if address matches any care home
                if (selectedParticipant.address) {
                    const participantAddress = selectedParticipant.address.toLowerCase();
                    
                    // Check for Saunders or other care homes
                    careHomes.forEach((careHome, careHomeAddress) => {
                        if (participantAddress.includes(careHomeAddress)) {
                            // Find matching location
                            const careHomeLocation = locations.find(l => {
                                const locationName = l.name.toLowerCase();
                                const locationAddr = (l.address || '').toLowerCase();
                                
                                return locationName.includes('saunders') || 
                                       locationAddr.includes('saunders') ||
                                       locationAddr.includes(careHomeAddress) ||
                                       (careHome.name && locationName.includes(careHome.name.toLowerCase()));
                            });
                            
                            if (careHomeLocation) {
                                locationSelect.value = careHomeLocation.id;
                                foundCareHome = true;
                                console.log(`Auto-selected care home location: ${careHomeLocation.name}`);
                            }
                        }
                    });
                }
                
                // If not in care home, look for client home location
                if (!foundCareHome) {
                    // Try to find a "Client Home" or similar location
                    const homeLocation = locations.find(l => {
                        const name = l.name.toLowerCase();
                        return name.includes('client home') || 
                               name.includes('participant home') ||
                               name.includes('home visit') ||
                               name === 'home' ||
                               (selectedParticipant.address && 
                                l.name === selectedParticipant.address);
                    });
                    
                    if (homeLocation) {
                        locationSelect.value = homeLocation.id;
                        console.log(`Auto-selected home location: ${homeLocation.name}`);
                    } else {
                        // Default to first "home" type location if exists
                        const genericHome = locations.find(l => 
                            l.name.toLowerCase().includes('home')
                        );
                        
                        if (genericHome) {
                            locationSelect.value = genericHome.id;
                        } else {
                            // Leave empty if no suitable location found
                            locationSelect.value = '';
                        }
                    }
                }
            };
        }
    });

    // Location dropdowns
    const locationSelects = [
        document.getElementById('shiftLocation'),
        document.getElementById('editShiftLocation')
    ];
    
    locationSelects.forEach(select => {
        if (select) {
            select.innerHTML = '<option value="">Select Location</option>';
            locations.forEach(l => {
                select.innerHTML += `<option value="${l.id}">${l.name}</option>`;
            });
        }
    });

    // Duty Type dropdowns
    const dutyTypeSelects = [
        document.getElementById('shiftDutyType'),
        document.getElementById('editShiftDutyType')
    ];
    
    dutyTypeSelects.forEach(select => {
        if (select) {
            select.innerHTML = '<option value="">Select Duty Type</option>';
            dutyTypes.forEach(dt => {
                select.innerHTML += `<option value="${dt.id}">${dt.name}</option>`;
            });
        }
    });

    // Pay Rate dropdowns (for overrides)
    const payRateSelects = [
        document.getElementById('shiftPayRate'),
        document.getElementById('editShiftPayRate')
    ];
    
    payRateSelects.forEach(select => {
        if (select) {
            select.innerHTML = '<option value="">Use Staff Default</option>';
            
            // Group pay rates by category for better organization
            const groupedRates = {};
            payRates.forEach(pr => {
                const category = pr.category || 'Other';
                if (!groupedRates[category]) {
                    groupedRates[category] = [];
                }
                groupedRates[category].push(pr);
            });
            
            // Add grouped options
            Object.keys(groupedRates).sort().forEach(category => {
                if (groupedRates[category].length > 0) {
                    select.innerHTML += `<optgroup label="${category}">`;
                    groupedRates[category].forEach(pr => {
                        const label = payRateLabels.get(pr.id) || 
                                    `${category} - Level ${pr.level || '?'} - Point ${pr.pay_point || '?'}`;
                        select.innerHTML += `<option value="${pr.id}">${label} ($${pr.hourly_pay_rate}/hr)</option>`;
                    });
                    select.innerHTML += `</optgroup>`;
                }
            });
        }
    });

    // Status dropdown (only for edit modal)
    const statusSelect = document.getElementById('editShiftStatus');
    if (statusSelect) {
        statusSelect.innerHTML = `
            <option value="pending">Pending</option>
            <option value="confirmed">Confirmed</option>
            <option value="completed">Completed</option>
            <option value="cancelled">Cancelled</option>
        `;
    }

    console.log('Modal dropdowns populated:', {
        staff: staff.length,
        participants: participants.length,
        locations: locations.length,
        dutyTypes: dutyTypes.length,
        payRates: payRates.length
    });
}

        function populateStaffDatalist(datalistId) {
            const datalist = document.getElementById(datalistId);
            if (datalist && staff.length > 0) {
                datalist.innerHTML = '';
                staff.forEach(s => {
                    const option = document.createElement('option');
                    option.value = `${s.first_name} ${s.last_name}`;
                    option.setAttribute('data-id', s.id);
                    datalist.appendChild(option);
                });
            }
        }

        function populateParticipantDatalist(datalistId) {
            const datalist = document.getElementById(datalistId);
            if (datalist && participants.length > 0) {
                datalist.innerHTML = '';
                participants.forEach(p => {
                    const option = document.createElement('option');
                    option.value = `${p.first_name} ${p.last_name}`;
                    option.setAttribute('data-id', p.id);
                    datalist.appendChild(option);
                });
            }
        }

        function updateStaffSelection() {
            const input = document.getElementById('shiftStaffInput');
            const hiddenInput = document.getElementById('shiftStaff');
            const selectedStaff = staff.find(s => `${s.first_name} ${s.last_name}` === input.value);
            
            if (selectedStaff) {
                hiddenInput.value = selectedStaff.id;
                updateHourWarning();
            } else {
                hiddenInput.value = '';
            }
        }

        function updateParticipantSelection() {
            const input = document.getElementById('shiftParticipantInput');
            const hiddenInput = document.getElementById('shiftParticipant');
            const selectedParticipant = participants.find(p => `${p.first_name} ${p.last_name}` === input.value);
            
            hiddenInput.value = selectedParticipant ? selectedParticipant.id : '';
        }

        function updateEditStaffSelection() {
            const input = document.getElementById('editShiftStaffInput');
            const hiddenInput = document.getElementById('editShiftStaff');
            const selectedStaff = staff.find(s => `${s.first_name} ${s.last_name}` === input.value);
            
            hiddenInput.value = selectedStaff ? selectedStaff.id : '';
        }

        function updateEditParticipantSelection() {
            const input = document.getElementById('editShiftParticipantInput');
            const hiddenInput = document.getElementById('editShiftParticipant');
            const selectedParticipant = participants.find(p => `${p.first_name} ${p.last_name}` === input.value);
            
            hiddenInput.value = selectedParticipant ? selectedParticipant.id : '';
        }

        // ========================================
        // SHIFT CRUD OPERATIONS
        // ========================================

        function showAddShiftModal() {
    const modal = document.getElementById('addShiftModal');
    if (modal) {
        // Clear form first
        document.getElementById('shiftDate').value = new Date().toISOString().split('T')[0];
        document.getElementById('shiftStartTime').value = '';
        document.getElementById('shiftEndTime').value = '';
        document.getElementById('shiftStaff').value = '';
        document.getElementById('shiftParticipant').value = '';
        document.getElementById('shiftLocation').value = '';
        document.getElementById('shiftPayRate').value = '';
        
        // Set Active Shift as default duty type
        const activeShiftDutyType = dutyTypes.find(dt => 
            dt.name.toLowerCase().includes('active') || 
            dt.name.toLowerCase() === 'active shift' ||
            dt.name.toLowerCase() === 'active'
        );
        
        if (activeShiftDutyType) {
            document.getElementById('shiftDutyType').value = activeShiftDutyType.id;
        } else if (dutyTypes.length > 0) {
            // Default to first duty type if no "Active Shift" found
            document.getElementById('shiftDutyType').value = dutyTypes[0].id;
        } else {
            document.getElementById('shiftDutyType').value = '';
        }
        
        modal.style.display = 'flex';
    }
}

async function createShift() {
    try {
        const date = document.getElementById('shiftDate').value;
        const startTime = document.getElementById('shiftStartTime').value;
        const endTime = document.getElementById('shiftEndTime').value;
        const staffId = document.getElementById('shiftStaff').value;
        const participantId = document.getElementById('shiftParticipant').value || null;
        const locationId = document.getElementById('shiftLocation').value || null;
        const dutyTypeId = document.getElementById('shiftDutyType').value;
        const payRateId = document.getElementById('shiftPayRate').value;

        // Basic validation
        if (!date || !staffId || !dutyTypeId) {
            showNotification('Please fill required fields (Date, Staff, Duty Type)', 'error');
            return;
        }

        if (!participantId && !locationId) {
            showNotification('Please select either participant or location', 'error');
            return;
        }

        // FIX #2: Check staff availability BEFORE conflict checking
        const { data: availabilityCheck } = await supabaseClient
            .from('staff_availability')
            .select('*')
            .eq('staff_id', staffId)
            .eq('date', date)
            .single();

        if (availabilityCheck && !availabilityCheck.available) {
            const selectedStaff = staff.find(s => s.id === staffId);
            const staffName = selectedStaff ? `${selectedStaff.first_name} ${selectedStaff.last_name}` : 'Staff member';
            const leaveReason = availabilityCheck.reason || 'unavailable';
            
            const message = `‚ö†Ô∏è AVAILABILITY WARNING\n\n` +
                `${staffName} is on ${leaveReason} on ${formatDateFriendly(date)}.\n\n` +
                `Do you want to create this shift anyway?`;
            
            if (!confirm(message)) {
                return;
            }
        }
        const selectedDutyType = dutyTypes.find(d => d.id === dutyTypeId);
        
        // FIX #1: Enhanced conflict checking with database query for real-time accuracy
        const { data: dbShifts } = await supabaseClient
            .from('shifts')
            .select('*')
            .eq('staff_id', staffId)
            .eq('date', date)
            .is('deleted_at', null);

        const existingShifts = dbShifts || [];

        // Check for sleepover conflicts first
        const isNewSleepover = selectedDutyType?.name?.toLowerCase().includes('sleepover');
        const existingSleepover = existingShifts.find(s => {
            const dt = dutyTypes.find(d => d.id === s.duty_type_id);
            return dt?.name?.toLowerCase().includes('sleepover');
        });

        if (isNewSleepover && existingSleepover) {
            showNotification(`Staff already has a sleepover shift on ${date}`, 'error');
            return; // Hard block - no duplicate sleepovers
        }

        if (isNewSleepover && existingShifts.length > 0) {
            // Check if any existing shifts conflict with sleepover hours (10pm-6am)
            for (const shift of existingShifts) {
                if (shift.start_time) {
                    const startHour = parseInt(shift.start_time.split(':')[0]);
                    const endHour = shift.end_time ? parseInt(shift.end_time.split(':')[0]) : 0;
                    
                    // Check if shift extends into sleepover hours
                    if (startHour >= 22 || startHour < 6 || 
                        (endHour > 0 && endHour <= 6) || 
                        (shift.end_time && shift.end_time < shift.start_time)) { // Overnight shift
                        showNotification('Cannot add sleepover: Staff has a shift during sleepover hours (10pm-6am)', 'error');
                        return;
                    }
                }
            }
        }

        // Check for regular shift overlaps
        if (startTime && endTime && !isNewSleepover) {
            // Check if there's an existing sleepover
            if (existingSleepover) {
                const newStartHour = parseInt(startTime.split(':')[0]);
                const newEndHour = parseInt(endTime.split(':')[0]);
                
                if (newStartHour >= 22 || newStartHour < 6 || 
                    newEndHour <= 6 || 
                    (endTime < startTime)) { // Overnight shift
                    showNotification('Cannot add shift during sleepover hours when staff has a sleepover', 'error');
                    return;
                }
            }

            // Check for time overlaps with other shifts
            const newStart = new Date(`2000-01-01T${startTime}`);
            let newEnd = new Date(`2000-01-01T${endTime}`);
            if (newEnd <= newStart) newEnd.setDate(newEnd.getDate() + 1);
            
            for (const existing of existingShifts) {
                if (existing.start_time && existing.end_time) {
                    const existingStart = new Date(`2000-01-01T${existing.start_time}`);
                    let existingEnd = new Date(`2000-01-01T${existing.end_time}`);
                    if (existingEnd <= existingStart) existingEnd.setDate(existingEnd.getDate() + 1);
                    
                    // Check for overlap
                    if (!(newEnd <= existingStart || newStart >= existingEnd)) {
                        // Calculate overlap period
                        const overlapStart = new Date(Math.max(newStart, existingStart));
                        const overlapEnd = new Date(Math.min(newEnd, existingEnd));
                        const overlapHours = (overlapEnd - overlapStart) / (1000 * 60 * 60);
                        
                        // Get participant name for better error message
                        const existingParticipant = participants.find(p => p.id === existing.participant_id);
                        const participantName = existingParticipant ? 
                            `${existingParticipant.first_name} ${existingParticipant.last_name}` : 
                            'Unknown';
                        
                        const staffName = staff.find(s => s.id === staffId)?.first_name || 'Staff';
                        
                        const message = `‚ö†Ô∏è SHIFT OVERLAP DETECTED\n\n` +
                            `${staffName} already has a shift:\n` +
                            `‚Ä¢ Time: ${formatTime12Hour(existing.start_time)} to ${formatTime12Hour(existing.end_time)}\n` +
                            `‚Ä¢ Client: ${participantName}\n` +
                            `‚Ä¢ Overlap: ${overlapHours.toFixed(1)} hours\n\n` +
                            `Do you want to create this overlapping shift anyway?`;
                        
                        if (!confirm(message)) {
                            return; // Block creation if user cancels
                        }
                    }
                }
            }
        }

        // Check weekly hours limit
        const weekStart = new Date(date);
        weekStart.setDate(weekStart.getDate() - weekStart.getDay());
        const weekEnd = new Date(weekStart);
        weekEnd.setDate(weekEnd.getDate() + 6);

        const { data: weekShifts } = await supabaseClient
            .from('shifts')
            .select('*')
            .eq('staff_id', staffId)
            .gte('date', weekStart.toISOString().split('T')[0])
            .lte('date', weekEnd.toISOString().split('T')[0])
            .is('deleted_at', null);

        let totalWeekHours = 0;
        (weekShifts || []).forEach(s => {
            totalWeekHours += s.duration_hours || 0;
        });

        // Add new shift hours
        let newShiftHours = 0;
        if (selectedDutyType?.name.toLowerCase().includes('sleepover')) {
            newShiftHours = 2;
        } else if (startTime && endTime) {
            const start = new Date(`2000-01-01T${startTime}`);
            let end = new Date(`2000-01-01T${endTime}`);
            if (end <= start) end.setDate(end.getDate() + 1);
            newShiftHours = (end - start) / (1000 * 60 * 60);
        }

        const selectedStaff = staff.find(s => s.id === staffId);
        const weeklyLimit = selectedStaff?.weekly_hour_limit || 38;

        if (totalWeekHours + newShiftHours > weeklyLimit) {
            const message = `‚ö†Ô∏è WEEKLY HOURS WARNING\n\n` +
                `${selectedStaff?.first_name} will have ${(totalWeekHours + newShiftHours).toFixed(1)} hours this week.\n` +
                `This exceeds their ${weeklyLimit} hour weekly limit.\n\n` +
                `Do you want to proceed anyway?`;
            
            if (!confirm(message)) {
                return;
            }
        }

        // Prepare shift data
        const effectivePayRateId = payRateId || selectedStaff?.pay_rate_id || '00000000-0000-0000-0000-000000000002';

        const shiftData = {
            date, 
            start_time: startTime || null,
            end_time: endTime || null,
            duty_type_id: dutyTypeId,
            pay_override_id: effectivePayRateId,
            staff_id: staffId,
            participant_id: participantId,
            location_id: locationId,
            created_by: currentStaffData?.id || currentUser.id,
            status: 'confirmed',
            transfer_status: 'none',
            adjustment_status: 'none',
            duration_hours: newShiftHours || null
        };

        console.log('Creating shift with data:', shiftData);

        const { data: newShift, error } = await supabaseClient
            .from('shifts')
            .insert([shiftData])
            .select()
            .single();

        if (error) throw error;

        // Save to undo stack
        if (typeof UndoRedoManager !== 'undefined') {
            UndoRedoManager.saveState('create_shift', { id: newShift.id });
        }

        showNotification('Shift created successfully', 'success');
        closeModal('addShiftModal');
        await loadShifts();
        
        // FIX: Refresh conflicts view if active
        if (currentView === 'conflicts') {
            await renderConflicts();
        }

    } catch (error) {
        console.error('Error creating shift:', error);
        showNotification('Failed to create shift: ' + error.message, 'error');
    }
}


function getParticipantColor(participantId) {
    if (!participantId) return 'transparent';
    
    const colors = [
        '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
        '#1abc9c', '#e67e22', '#16a085', '#f1c40f', '#e84393',
        '#00b894', '#6c5ce7', '#fdcb6e', '#fd79a8', '#a29bfe'
    ];
    
    // Use participant ID to consistently pick same color
    const hash = participantId.split('').reduce((acc, char) => 
        acc + char.charCodeAt(0), 0);
    
    return colors[hash % colors.length];
}


        function editShift(shiftId) {
            const shift = shifts.find(s => s.id === shiftId);
            if (!shift) {
                showNotification('Shift not found', 'error');
                return;
            }

            console.log('Editing shift:', shift);

            // Populate edit form
            document.getElementById('editShiftId').value = shift.id;
            document.getElementById('editShiftDate').value = shift.date;
            document.getElementById('editShiftStartTime').value = shift.start_time || '';
            document.getElementById('editShiftEndTime').value = shift.end_time || '';
            
            // Set staff selection
            if (shift.staff) {
                const staffName = `${shift.staff.first_name} ${shift.staff.last_name}`;
                document.getElementById('editShiftStaffInput').value = staffName;
                document.getElementById('editShiftStaff').value = shift.staff_id;
            }
            
            // Set participant selection
            if (shift.participant) {
                const participantName = `${shift.participant.first_name} ${shift.participant.last_name}`;
                document.getElementById('editShiftParticipantInput').value = participantName;
                document.getElementById('editShiftParticipant').value = shift.participant_id;
            }
            
            document.getElementById('editShiftLocation').value = shift.location_id || '';
            document.getElementById('editShiftDutyType').value = shift.duty_type_id || '';
            document.getElementById('editShiftPayRate').value = shift.pay_override_id || '';
            document.getElementById('editShiftStatus').value = shift.status || 'scheduled';
            document.getElementById('editShiftNotes').value = shift.notes || '';

            document.getElementById('editShiftModal').style.display = 'flex';
        }

        
        function deleteShiftConfirm() {
            const shiftId = parseInt(document.getElementById('editShiftId').value);
            
            if (!confirm('Are you sure you want to delete this shift? This action cannot be undone.')) {
                return;
            }

            deleteShift(shiftId);
        }

        async function deleteShift(shiftId) {
    if (!confirm('Are you sure you want to delete this shift?')) return;
    
    try {
        // Get the shift data before deletion for undo
        const shiftToDelete = shifts.find(s => s.id === shiftId);
        if (shiftToDelete) {
            // Save to undo stack
            UndoRedoManager.saveState('delete_shift', {
                id: shiftId,
                shiftData: { ...shiftToDelete }
            });
        }
        
        // Soft delete - only use deleted_at (not deleted_by since it doesn't exist)
        const { error } = await supabaseClient
            .from('shifts')
            .update({ 
                deleted_at: new Date().toISOString()
            })
            .eq('id', shiftId);
        
        if (error) throw error;
        
        showNotification('Shift deleted successfully', 'success');
        
        // Close modal if open
        const modal = document.getElementById('editShiftModal');
        if (modal && modal.style.display !== 'none') {
            closeModal('editShiftModal');
        }
        
        await loadShifts();
        
        // Refresh conflicts view if it's active
        if (currentView === 'conflicts') {
            await renderConflicts();
        } else {
            renderCurrentView();
        }
        
    } catch (error) {
        console.error('Error deleting shift:', error);
        showNotification('Failed to delete shift', 'error');
    }
}
async function deleteShiftConfirm() {
    const shiftId = document.getElementById('editShiftId').value;
    if (shiftId) {
        await deleteShift(shiftId);
    }
}

        function updateTimeFields() {
            const dutyTypeSelect = document.getElementById('shiftDutyType');
            const startTimeInput = document.getElementById('shiftStartTime');
            const endTimeInput = document.getElementById('shiftEndTime');
            
            if (!dutyTypeSelect || !startTimeInput || !endTimeInput) return;
            
            const selectedDutyType = dutyTypes.find(d => d.id === dutyTypeSelect.value);
            
            if (selectedDutyType && selectedDutyType.name.toLowerCase().includes('sleepover')) {
                startTimeInput.required = false;
                endTimeInput.required = false;
                startTimeInput.placeholder = "Optional for sleepovers";
                endTimeInput.placeholder = "Optional for sleepovers";
            } else {
                startTimeInput.required = true;
                endTimeInput.required = true;
                startTimeInput.placeholder = "";
                endTimeInput.placeholder = "";
            }
        }

        function updateEditTimeFields() {
            const dutyTypeSelect = document.getElementById('editShiftDutyType');
            const startTimeInput = document.getElementById('editShiftStartTime');
            const endTimeInput = document.getElementById('editShiftEndTime');
            
            if (!dutyTypeSelect || !startTimeInput || !endTimeInput) return;
            
            const selectedDutyType = dutyTypes.find(d => d.id === dutyTypeSelect.value);
            
            if (selectedDutyType && selectedDutyType.name.toLowerCase().includes('sleepover')) {
                startTimeInput.required = false;
                endTimeInput.required = false;
                startTimeInput.placeholder = "Optional for sleepovers";
                endTimeInput.placeholder = "Optional for sleepovers";
            } else {
                startTimeInput.required = true;
                endTimeInput.required = true;
                startTimeInput.placeholder = "";
                endTimeInput.placeholder = "";
            }
        }

        function updateHourWarning() {
            const staffId = document.getElementById('shiftStaff').value;
            const warningDiv = document.getElementById('hourWarningText');
            
            if (!staffId || !warningDiv) {
                if (warningDiv) warningDiv.style.display = 'none';
                return;
            }
            
            const selectedStaff = staff.find(s => s.id === staffId);
            if (!selectedStaff || selectedStaff.limits === undefined || selectedStaff.limits === null) {
                warningDiv.style.display = 'none';
                return;
            }

            // Calculate current week hours
            const weekStart = getWeekStart(new Date());
            const weekEnd = new Date(weekStart);
            weekEnd.setDate(weekEnd.getDate() + 6);
            
            const weekShifts = shifts.filter(shift => 
                shift.staff_id === selectedStaff.id &&
                shift.date >= weekStart.toISOString().split('T')[0] &&
                shift.date <= weekEnd.toISOString().split('T')[0]
            );
            
            const currentWeekHours = weekShifts.reduce((total, shift) => 
                total + (shift.calculated_hours?.total || 0), 0
            );
            
            const hourLimit = parseFloat(selectedStaff.limits);
            const remaining = hourLimit - currentWeekHours;
            
            if (remaining <= 10) {
                warningDiv.style.display = 'block';
                warningDiv.innerHTML = `WARNING: ${selectedStaff.first_name} has ${remaining.toFixed(1)}h remaining this week (${currentWeekHours.toFixed(1)}h/${hourLimit}h)`;
            } else {
                warningDiv.style.display = 'none';
            }
        }

        function validateSleepoverRules(shifts, newShift) {
    const violations = [];
    
    // If new shift is a sleepover
    if (newShift.duty_type?.toLowerCase().includes('sleepover')) {
        shifts.forEach(existing => {
            if (existing.start_time) {
                const startHour = parseInt(existing.start_time.split(':')[0]);
                const endHour = parseInt(existing.end_time?.split(':')[0]) || 0;
                
                // Check for late night shifts (10pm onwards)
                if (startHour >= 22 || startHour < 6) {
                    violations.push({
                        type: 'sleepover_conflict',
                        message: `Cannot have sleepover with late night shift (${existing.start_time} - ${existing.end_time})`,
                        shift: existing
                    });
                }
                
                // Check for early morning shifts (12am-6am)
                if (endHour > 0 && endHour <= 6) {
                    violations.push({
                        type: 'sleepover_conflict', 
                        message: `Cannot have sleepover with early morning shift ending at ${existing.end_time}`,
                        shift: existing
                    });
                }
            }
        });
    }
    
    // If new shift is active and there's a sleepover
    const hasSleepover = shifts.some(s => s.duty_type?.toLowerCase().includes('sleepover'));
    if (hasSleepover && newShift.start_time) {
        const startHour = parseInt(newShift.start_time.split(':')[0]);
        const endHour = parseInt(newShift.end_time?.split(':')[0]) || 0;
        
        if (startHour >= 22 || startHour < 6 || (endHour > 0 && endHour <= 6)) {
            violations.push({
                type: 'sleepover_conflict',
                message: 'Cannot roster 10pm-6am shifts when staff has sleepover',
                shift: null
            });
        }
    }
    
    return violations;
}

// Comprehensive overlap check
async function checkShiftConflicts(staffId, participantId, date, startTime, endTime, dutyType, excludeShiftId = null) {
    const conflicts = {
        overlaps: [],
        violations: [],
        warnings: [],
        participantOverlaps: []
    };
    
    try {
        // 1. Check staff availability/leave
        const { data: leaveData } = await supabaseClient
            .from('staff_availability')
            .select('*')
            .eq('staff_id', staffId)
            .eq('date', date)
            .eq('available', false)
            .single();
        
        if (leaveData) {
            conflicts.violations.push({
                type: 'on_leave',
                message: `Staff is on leave on ${formatDateFriendly(date)}`,
                blocking: true
            });
        }
        
        // 2. Get all shifts for this staff on this date
        let staffQuery = supabaseClient
            .from('shifts')
            .select('*, duty_type:duty_type_id(name)')
            .eq('staff_id', staffId)
            .eq('date', date)
            .is('deleted_at', null);
        
        if (excludeShiftId) {
            staffQuery = staffQuery.neq('id', excludeShiftId);
        }
        
        const { data: staffShifts } = await staffQuery;
        
        // 3. Check time overlaps for active shifts
        if (startTime && endTime && staffShifts) {
            const newStart = new Date(`2000-01-01T${startTime}`);
            const newEnd = new Date(`2000-01-01T${endTime}`);
            if (newEnd <= newStart) newEnd.setDate(newEnd.getDate() + 1);
            
            staffShifts.forEach(shift => {
                if (shift.start_time && shift.end_time) {
                    const existingStart = new Date(`2000-01-01T${shift.start_time}`);
                    const existingEnd = new Date(`2000-01-01T${shift.end_time}`);
                    if (existingEnd <= existingStart) existingEnd.setDate(existingEnd.getDate() + 1);
                    
                    // Check for overlap
                    if (!(newEnd <= existingStart || newStart >= existingEnd)) {
                        // Calculate overlap period
                        const overlapStart = new Date(Math.max(newStart, existingStart));
                        const overlapEnd = new Date(Math.min(newEnd, existingEnd));
                        
                        conflicts.overlaps.push({
                            type: 'time_overlap',
                            message: `Overlaps with shift ${formatTime12Hour(shift.start_time)}-${formatTime12Hour(shift.end_time)}`,
                            overlapPeriod: `${overlapStart.toTimeString().slice(0,5)}-${overlapEnd.toTimeString().slice(0,5)}`,
                            shift: shift,
                            blocking: true
                        });
                    }
                }
            });
        }
        
        // 4. Check sleepover business rules
        const sleepoverViolations = validateSleepoverRules(staffShifts || [], {
            start_time: startTime,
            end_time: endTime,
            duty_type: dutyType
        });
        
        conflicts.violations.push(...sleepoverViolations);
        
        // 5. Check participant overlaps (for information only)
        if (participantId && startTime && endTime) {
            const { data: participantShifts } = await supabaseClient
                .from('shifts')
                .select('*, staff:staff_id(first_name, last_name)')
                .eq('participant_id', participantId)
                .eq('date', date)
                .is('deleted_at', null)
                .neq('id', excludeShiftId || '00000000-0000-0000-0000-000000000000');
            
            if (participantShifts) {
                const overlappingStaff = [];
                
                participantShifts.forEach(shift => {
                    if (shift.start_time && shift.end_time) {
                        const existingStart = new Date(`2000-01-01T${shift.start_time}`);
                        const existingEnd = new Date(`2000-01-01T${shift.end_time}`);
                        const newStart = new Date(`2000-01-01T${startTime}`);
                        const newEnd = new Date(`2000-01-01T${endTime}`);
                        
                        if (existingEnd <= existingStart) existingEnd.setDate(existingEnd.getDate() + 1);
                        if (newEnd <= newStart) newEnd.setDate(newEnd.getDate() + 1);
                        
                        if (!(newEnd <= existingStart || newStart >= existingEnd)) {
                            overlappingStaff.push({
                                staff: shift.staff,
                                time: `${formatTime12Hour(shift.start_time)}-${formatTime12Hour(shift.end_time)}`
                            });
                        }
                    }
                });
                
                if (overlappingStaff.length > 0) {
                    conflicts.participantOverlaps = {
                        count: overlappingStaff.length + 1, // +1 for the new shift
                        ratio: `${overlappingStaff.length + 1}:1`,
                        staff: overlappingStaff,
                        message: `Participant will have ${overlappingStaff.length + 1} staff during this time`
                    };
                }
            }
        }
        
    } catch (error) {
        console.error('Error checking conflicts:', error);
    }
    
    return conflicts;
}
        // ========================================
        // SUMMARY AND TIMESHEET RENDERING - FIXED
        // ========================================

        function renderSummary() {
    const summaryGrid = document.getElementById('summaryGrid');
    if (!summaryGrid) return;
    
    console.log('Rendering summary with', filteredShifts.length, 'shifts');
    
    // Staff summary with proper calculations
    const staffSummary = staff.map(s => {
        const staffShifts = filteredShifts.filter(shift => shift.staff_id === s.id);
        
        if (staffShifts.length === 0) return null;
        
        const totals = staffShifts.reduce((acc, shift) => {
            const hours = shift.calculated_hours || {};
            const pay = shift.calculated_pay || 0;
            
            acc.total += hours.total || 0;
            acc.weekdayDay += hours.weekdayDay || 0;
            acc.weekdayEvening += hours.weekdayEvening || 0;
            acc.weekdayNight += hours.weekdayNight || 0;
            acc.saturday += hours.saturday || 0;
            acc.sunday += hours.sunday || 0;
            acc.publicHoliday += hours.publicHoliday || 0;
            acc.sleepover += hours.sleepover || 0;
            acc.pay += pay;
            
            // Count sleepovers
            if (hours.sleepover > 0) {
                acc.sleepoverCount++;
            }
            
            return acc;
        }, {
            total: 0, weekdayDay: 0, weekdayEvening: 0, weekdayNight: 0,
            saturday: 0, sunday: 0, publicHoliday: 0, sleepover: 0, pay: 0, sleepoverCount: 0
        });

        const hourLimit = parseFloat(s.limits) || 76;
        const overLimit = totals.total > hourLimit;

        return {
            name: `${s.first_name} ${s.last_name}`,
            shifts: staffShifts.length,
            hourLimit: hourLimit,
            overLimit: overLimit,
            deductedHours: Math.max(0, totals.total - hourLimit),
            ...totals
        };
    }).filter(Boolean);

    // Participant summary
    const participantSummary = participants.map(p => {
        const participantShifts = filteredShifts.filter(shift => shift.participant_id === p.id);
        if (participantShifts.length === 0) return null;
        
        const totals = participantShifts.reduce((acc, shift) => {
            acc.hours += shift.calculated_hours?.total || 0;
            acc.pay += shift.calculated_pay || 0;
            if (shift.calculated_hours?.sleepover > 0) acc.sleepovers++;
            return acc;
        }, { hours: 0, pay: 0, sleepovers: 0 });
        
        const uniqueStaff = new Set(participantShifts.map(shift => shift.staff_id)).size;

        return {
            name: `${p.first_name} ${p.last_name}`,
            shifts: participantShifts.length,
            hours: totals.hours,
            pay: totals.pay,
            sleepovers: totals.sleepovers,
            staffCount: uniqueStaff
        };
    }).filter(Boolean);

    summaryGrid.innerHTML = `
        <div class="summary-card">
            <h3>Staff Summary (${staffSummary.length} with shifts)</h3>
            ${staffSummary.map(s => `
                <div class="summary-item" style="flex-direction: column; align-items: flex-start;">
                    <div style="display: flex; justify-content: space-between; width: 100%; font-weight: 600;">
                        <span>${s.name}</span>
                        <span>${s.shifts} shifts ‚Ä¢ ${formatHours(s.total)}h ‚Ä¢ $${s.pay.toFixed(2)}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; width: 100%; margin-top: 4px;">
                        <span style="font-size: var(--font-size-xs); color: var(--text-muted);">
                            Limit: ${s.hourLimit}h ${s.overLimit ? '(EXCEEDED)' : ''}
                        </span>
                        ${s.overLimit ? `<span style="font-size: var(--font-size-xs); color: var(--danger-color);">Deducted: ${formatHours(s.deductedHours)}h</span>` : ''}
                    </div>
                    <div class="summary-item-details">
                        ${s.weekdayDay > 0 ? `Day: ${formatHours(s.weekdayDay)}h` : ''}
                        ${s.weekdayEvening > 0 ? ` ‚Ä¢ Eve: ${formatHours(s.weekdayEvening)}h` : ''}
                        ${s.weekdayNight > 0 ? ` ‚Ä¢ Night: ${formatHours(s.weekdayNight)}h` : ''}
                        ${s.saturday > 0 ? ` ‚Ä¢ Sat: ${formatHours(s.saturday)}h` : ''}
                        ${s.sunday > 0 ? ` ‚Ä¢ Sun: ${formatHours(s.sunday)}h` : ''}
                        ${s.publicHoliday > 0 ? ` ‚Ä¢ Holiday: ${formatHours(s.publicHoliday)}h` : ''}
                        ${s.sleepoverCount > 0 ? ` ‚Ä¢ Sleepovers: ${s.sleepoverCount}` : ''}
                    </div>
                </div>
            `).join('')}
        </div>
        <div class="summary-card">
            <h3>Participant Summary (${participantSummary.length} with shifts)</h3>
            ${participantSummary.map(p => `
                <div class="summary-item" style="flex-direction: column; align-items: flex-start;">
                    <div style="display: flex; justify-content: space-between; width: 100%; font-weight: 500;">
                        <span>${p.name}</span>
                        <span>${p.shifts} shifts ‚Ä¢ ${formatHours(p.hours)}h ‚Ä¢ $${p.pay.toFixed(2)}</span>
                    </div>
                    <div class="summary-item-details">
                        ${p.sleepovers > 0 ? `${p.sleepovers} sleepovers ‚Ä¢ ` : ''}
                        ${p.staffCount} staff assigned
                    </div>
                </div>
            `).join('')}
        </div>
    `;
}
        

function renderTimesheet() {
    const timesheetContent = document.getElementById('timesheetContent');
    if (!timesheetContent) return;
    
    console.log('Rendering timesheet...');
    
    // Group by staff
    const staffGroups = {};
    filteredShifts.forEach(shift => {
        const staffId = shift.staff_id;
        if (!staffGroups[staffId]) {
            staffGroups[staffId] = {
                staff: shift.staff,
                shifts: [],
                totalHours: { 
                    total: 0, weekdayDay: 0, weekdayEvening: 0, weekdayNight: 0, 
                    saturday: 0, sunday: 0, publicHoliday: 0, sleepover: 0,
                    overtime: 0 // Added overtime tracking
                },
                totalPay: 0,
                sleepoverCount: 0,
                weeklyHours: 0 // Track weekly hours for overtime calculation
            };
        }
        staffGroups[staffId].shifts.push(shift);
    });

    // Calculate totals for each staff member
    Object.values(staffGroups).forEach(group => {
        // First pass: calculate base hours
        group.shifts.forEach(shift => {
            const hours = shift.calculated_hours || {};
            const pay = shift.calculated_pay || 0;
            
            // Sum all hour categories
            Object.keys(hours).forEach(category => {
                if (group.totalHours[category] !== undefined) {
                    group.totalHours[category] += hours[category] || 0;
                }
            });
            
            // Count sleepovers (not hours)
            if (hours.sleepover > 0) {
                group.sleepoverCount++;
            }
            
            // Track public holiday hours - check the shift's is_public_holiday field
            if (shift.is_public_holiday === true) {
                group.totalHours.publicHoliday += hours.total || 0;
            }
            
            group.totalPay += pay;
        });
        
        // Calculate overtime (hours over 38 per week for full-time/part-time)
        const staff = group.staff;
        const payCategory = staff?.pay_category || 'casual';
        
        if (payCategory.toLowerCase().includes('full') || payCategory.toLowerCase().includes('part')) {
            // Only calculate overtime for full-time and part-time staff
            const standardWeeklyHours = 38;
            if (group.totalHours.total > standardWeeklyHours) {
                group.totalHours.overtime = group.totalHours.total - standardWeeklyHours;
            }
        }
        
        // Apply hour limits
        if (staff && staff.limits !== undefined && staff.limits !== null) {
            const hourLimit = parseFloat(staff.limits);
            group.overLimit = group.totalHours.total > hourLimit;
            group.hourLimit = hourLimit;
            group.finalHours = Math.min(group.totalHours.total, hourLimit);
            group.deductedHours = Math.max(0, group.totalHours.total - hourLimit);
        } else {
            group.overLimit = false;
            group.hourLimit = 76; // Default
            group.finalHours = group.totalHours.total;
            group.deductedHours = 0;
        }
        
        // Get pay rate label
        if (staff && staff.pay_rate_id) {
            group.payRateLabel = payRateLabels.get(staff.pay_rate_id) || 'Standard Rate';
        } else {
            group.payRateLabel = 'Standard Rate';
        }
    });

    // Calculate grand totals for footer
    let grandTotalHours = 0;
    let grandTotalPay = 0;
    let grandTotalOvertime = 0;
    let grandTotalPublicHoliday = 0;
    
    Object.values(staffGroups).forEach(group => {
        grandTotalHours += group.totalHours.total;
        grandTotalPay += group.totalPay;
        grandTotalOvertime += group.totalHours.overtime || 0;
        grandTotalPublicHoliday += group.totalHours.publicHoliday || 0;
    });

    // Build the accordion table HTML with enhanced styling
    let html = `
        <style>
            .timesheet-wrapper {
                background: white;
                border-radius: var(--radius-lg);
                overflow: hidden;
                box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            }
            
            .timesheet-table { 
                width: 100%; 
                border-collapse: separate;
                border-spacing: 0;
                background: white;
            }
            
            .timesheet-table thead {
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            }
            
            .timesheet-table th { 
                padding: 16px 12px; 
                text-align: left; 
                font-weight: 600; 
                font-size: 11px; 
                text-transform: uppercase;
                letter-spacing: 1px;
                color: white;
                border: none;
            }
            
            .timesheet-table tfoot {
                background: #f8f9fa;
                border-top: 2px solid #dee2e6;
            }
            
            .timesheet-table tfoot td {
                padding: 16px 12px;
                font-weight: 700;
                color: var(--text-primary);
                font-size: 14px;
            }
            
            .timesheet-row { 
                cursor: pointer; 
                transition: all 0.2s ease;
                background: white;
                position: relative;
            }
            
            .timesheet-row:hover { 
                background: #f8f9fa;
                transform: translateX(2px);
            }
            
            .timesheet-row td { 
                padding: 16px 12px; 
                border-bottom: 1px solid #e9ecef; 
                font-size: 14px;
                vertical-align: middle;
            }
            
            .timesheet-row:hover td:first-child {
                border-left: 3px solid var(--primary-color);
                padding-left: 9px;
            }
            
            .accordion-content { 
                display: none; 
                background: #f8f9fa;
            }
            
            .accordion-content.active { 
                display: table-row;
                animation: slideDown 0.3s ease;
            }
            
            @keyframes slideDown {
                from {
                    opacity: 0;
                    transform: translateY(-10px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
            
            .accordion-arrow { 
                display: inline-block; 
                margin-right: 10px; 
                transition: transform 0.3s ease; 
                font-size: 12px;
                color: var(--primary-color);
                font-weight: bold;
            }
            
            .accordion-arrow.open { 
                transform: rotate(90deg); 
            }
            
            .staff-name {
                font-weight: 600;
                color: var(--text-primary);
                font-size: 15px;
            }
            
            .pay-rate-badge {
                display: inline-block;
                background: linear-gradient(135deg, #667eea, #764ba2);
                color: white;
                padding: 5px 12px;
                border-radius: 20px;
                font-size: 11px;
                font-weight: 500;
                letter-spacing: 0.5px;
            }
            
            .hours-display {
                font-weight: 500;
                font-size: 14px;
            }
            
            .hours-limit {
                color: var(--text-muted);
                font-weight: normal;
            }
            
            .hour-exceeded { 
                color: #e74c3c !important; 
                font-weight: 600; 
            }
            
            .exceeded-badge {
                display: inline-block;
                background: #e74c3c;
                color: white;
                padding: 2px 6px;
                border-radius: 4px;
                font-size: 10px;
                margin-left: 8px;
                font-weight: 600;
                animation: pulse 2s infinite;
            }
            
            @keyframes pulse {
                0%, 100% { opacity: 1; }
                50% { opacity: 0.7; }
            }
            
            .sleepover-badge {
                display: inline-block;
                background: #f39c12;
                color: white;
                padding: 6px 12px;
                border-radius: 20px;
                font-weight: 600;
                font-size: 13px;
            }
            
            .overtime-badge {
                display: inline-block;
                background: #e67e22;
                color: white;
                padding: 6px 12px;
                border-radius: 20px;
                font-weight: 600;
                font-size: 13px;
                margin-left: 6px;
            }
            
            .hour-breakdown-cell {
                font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
                font-size: 12px;
                line-height: 1.8;
                color: var(--text-secondary);
                background: #f8f9fa;
                padding: 8px 12px !important;
                border-radius: 6px;
            }
            
            .hour-breakdown-item {
                display: inline-block;
                padding: 3px 8px;
                background: white;
                border-radius: 4px;
                margin-right: 8px;
                margin-bottom: 4px;
                border: 1px solid #e9ecef;
            }
            
            .hour-breakdown-item.overtime {
                background: #fff4e4;
                border-color: #ffd6a5;
                color: #e67e22;
                font-weight: 600;
            }
            
            .hour-breakdown-item.public-holiday {
                background: #e3f2fd;
                border-color: #90caf9;
                color: #1976d2;
                font-weight: 600;
            }
            
            .final-hours {
                font-weight: 600;
                font-size: 15px;
                color: var(--text-primary);
            }
            
            .deducted { 
                color: #e67e22; 
                font-size: 11px;
                font-weight: 500;
                display: block;
                margin-top: 4px;
            }
            
            .total-pay {
                font-weight: 700;
                font-size: 16px;
                color: #27ae60;
            }
            
            .shifts-detail-container {
                padding: 24px;
                background: white;
                margin: 16px;
                border-radius: 8px;
                box-shadow: 0 1px 4px rgba(0,0,0,0.08);
            }
            
            .shifts-detail-header {
                margin-bottom: 16px;
                color: var(--text-secondary);
                font-size: 13px;
                font-weight: 600;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .shifts-detail-table { 
                width: 100%;
                font-size: 13px;
                border-collapse: separate;
                border-spacing: 0;
                overflow: hidden;
                border-radius: 6px;
                border: 1px solid #e9ecef;
            }
            
            .shifts-detail-table th { 
                background: #f8f9fa;
                padding: 10px 12px; 
                text-align: left;
                font-weight: 600;
                font-size: 11px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
                color: var(--text-secondary);
                border-bottom: 1px solid #e9ecef;
            }
            
            .shifts-detail-table td { 
                padding: 12px; 
                border-bottom: 1px solid #f1f3f4;
                background: white;
            }
            
            .shifts-detail-table tbody tr:hover {
                background: #f8f9fa;
            }
            
            .shifts-detail-table tbody tr:last-child td {
                border-bottom: none;
            }
            
            .status-badge {
                padding: 4px 10px;
                border-radius: 12px;
                font-size: 11px;
                font-weight: 600;
                text-transform: uppercase;
                letter-spacing: 0.5px;
            }
            
            .status-confirmed {
                background: #d4edda;
                color: #155724;
            }
            
            .status-pending {
                background: #fff3cd;
                color: #856404;
            }
            
            .status-completed {
                background: #cce5ff;
                color: #004085;
            }
            
            .public-holiday-indicator {
                display: inline-block;
                background: #1976d2;
                color: white;
                padding: 2px 6px;
                border-radius: 4px;
                font-size: 10px;
                margin-left: 6px;
                font-weight: 600;
                text-transform: uppercase;
            }
        </style>
        
        <div class="timesheet-wrapper">
            <table class="timesheet-table">
                <thead>
                    <tr>
                        <th style="width: 20%;">Staff Member</th>
                        <th style="width: 15%;">Pay Rate</th>
                        <th style="width: 12%;">Hours / Limit</th>
                        <th style="width: 8%; text-align: center;">Sleepovers</th>
                        <th style="width: 30%;">Hour Breakdown</th>
                        <th style="width: 10%;">Final Hours</th>
                        <th style="width: 10%; text-align: right;">Total Pay</th>
                    </tr>
                </thead>
                <tbody>
    `;

    // Add each staff member's row and accordion content
    let accordionIndex = 0;
    Object.values(staffGroups).forEach(group => {
        const staff = group.staff || { first_name: 'Unknown', last_name: 'Staff' };
        const staffName = `${staff.first_name} ${staff.last_name}`;
        
        // Build hour breakdown with styled items
        const hourBreakdown = [];
        if (group.totalHours.weekdayDay > 0) 
            hourBreakdown.push(`<span class="hour-breakdown-item">Day: ${formatHours(group.totalHours.weekdayDay)}h</span>`);
        if (group.totalHours.weekdayEvening > 0) 
            hourBreakdown.push(`<span class="hour-breakdown-item">Eve: ${formatHours(group.totalHours.weekdayEvening)}h</span>`);
        if (group.totalHours.weekdayNight > 0) 
            hourBreakdown.push(`<span class="hour-breakdown-item">Night: ${formatHours(group.totalHours.weekdayNight)}h</span>`);
        if (group.totalHours.saturday > 0) 
            hourBreakdown.push(`<span class="hour-breakdown-item">Sat: ${formatHours(group.totalHours.saturday)}h</span>`);
        if (group.totalHours.sunday > 0) 
            hourBreakdown.push(`<span class="hour-breakdown-item">Sun: ${formatHours(group.totalHours.sunday)}h</span>`);
        if (group.totalHours.publicHoliday > 0) 
            hourBreakdown.push(`<span class="hour-breakdown-item public-holiday">PH: ${formatHours(group.totalHours.publicHoliday)}h</span>`);
        if (group.totalHours.overtime > 0) 
            hourBreakdown.push(`<span class="hour-breakdown-item overtime">OT: ${formatHours(group.totalHours.overtime)}h</span>`);
        
        const hourBreakdownStr = hourBreakdown.join('') || '<span style="color: #aaa;">‚Äî</span>';
        
        // Main row
        html += `
            <tr class="timesheet-row" onclick="toggleAccordion(${accordionIndex})">
                <td>
                    <span class="accordion-arrow" id="arrow-${accordionIndex}">‚ñ∂</span>
                    <span class="staff-name">${staffName}</span>
                </td>
                <td>
                    <span class="pay-rate-badge">${group.payRateLabel}</span>
                </td>
                <td>
                    <span class="hours-display ${group.overLimit ? 'hour-exceeded' : ''}">
                        ${formatHours(group.totalHours.total)}h 
                        <span class="hours-limit">/ ${group.hourLimit}h</span>
                        ${group.overLimit ? '<span class="exceeded-badge">EXCEEDED</span>' : ''}
                    </span>
                </td>
                <td style="text-align: center;">
                    ${group.sleepoverCount > 0 ? 
                        `<span class="sleepover-badge">${group.sleepoverCount}</span>` : 
                        '<span style="color: #ccc;">‚Äî</span>'}
                </td>
                <td class="hour-breakdown-cell">${hourBreakdownStr}</td>
                <td>
                    <span class="final-hours">${formatHours(group.finalHours)}h</span>
                    ${group.deductedHours > 0 ? 
                        `<span class="deducted">‚àí${formatHours(group.deductedHours)}h deducted</span>` : ''}
                    ${group.totalHours.overtime > 0 ? 
                        `<span class="overtime-badge" title="Overtime hours">+${formatHours(group.totalHours.overtime)}h OT</span>` : ''}
                </td>
                <td style="text-align: right;">
                    <span class="total-pay">$${group.totalPay.toFixed(2)}</span>
                </td>
            </tr>
            <tr class="accordion-content" id="accordion-${accordionIndex}">
                <td colspan="7" style="padding: 0; background: #f8f9fa;">
                    <div class="shifts-detail-container">
                        <h4 class="shifts-detail-header">Individual Shifts (${group.shifts.length})</h4>
                        <table class="shifts-detail-table">
                            <thead>
                                <tr>
                                    <th>Date</th>
                                    <th>Time</th>
                                    <th>Participant</th>
                                    <th>Hours</th>
                                    <th>Type</th>
                                    <th>Pay</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody>
        `;
        
        // Sort shifts by date
        group.shifts.sort((a, b) => new Date(a.date) - new Date(b.date));
        
        // Add individual shifts
        group.shifts.forEach(shift => {
            const participant = shift.participant || {};
            const participantName = participant.first_name ? 
                `${participant.first_name} ${participant.last_name}` : 
                (shift.location?.name || 'Unassigned');
            
            const timeDisplay = shift.start_time && shift.end_time ? 
                `${formatTime12Hour(shift.start_time)} - ${formatTime12Hour(shift.end_time)}` : 
                'Sleepover';
            
            const shiftHours = shift.calculated_hours?.total || 0;
            const shiftPay = shift.calculated_pay || 0;
            const dutyType = dutyTypes.find(d => d.id === shift.duty_type_id);
            
            html += `
                <tr>
                    <td>
                        <strong>${formatDateFriendly(shift.date)}</strong>
                        ${shift.is_public_holiday === true ? '<span class="public-holiday-indicator">PH</span>' : ''}
                    </td>
                    <td>${timeDisplay}</td>
                    <td>${participantName}</td>
                    <td>${formatHours(shiftHours)}h</td>
                    <td>${dutyType?.name || 'Standard'}</td>
                    <td style="font-weight: 600; color: #27ae60;">$${shiftPay.toFixed(2)}</td>
                    <td><span class="status-badge status-${shift.status || 'pending'}">${shift.status || 'pending'}</span></td>
                </tr>
            `;
        });
        
        html += `
                            </tbody>
                        </table>
                    </div>
                </td>
            </tr>
        `;
        
        accordionIndex++;
    });

    // Add footer with totals
    html += `
                </tbody>
                <tfoot>
                    <tr>
                        <td colspan="2"><strong>TOTALS</strong></td>
                        <td><strong>${formatHours(grandTotalHours)}h</strong></td>
                        <td style="text-align: center;">‚Äî</td>
                        <td>
                            ${grandTotalOvertime > 0 ? `<span class="hour-breakdown-item overtime">OT: ${formatHours(grandTotalOvertime)}h</span>` : ''}
                            ${grandTotalPublicHoliday > 0 ? `<span class="hour-breakdown-item public-holiday">PH: ${formatHours(grandTotalPublicHoliday)}h</span>` : ''}
                        </td>
                        <td>‚Äî</td>
                        <td style="text-align: right;"><strong style="color: #27ae60;">$${grandTotalPay.toFixed(2)}</strong></td>
                    </tr>
                </tfoot>
            </table>
        </div>
    `;

    timesheetContent.innerHTML = html || '<div class="loading">No timesheet data available</div>';
}
// Add accordion toggle function to window scope
window.toggleAccordion = function(index) {
    // Close all other accordions
    document.querySelectorAll('.accordion-content').forEach((content, i) => {
        if (i !== index) {
            content.classList.remove('active');
            const arrow = document.getElementById(`arrow-${i}`);
            if (arrow) arrow.classList.remove('open');
        }
    });
    
    // Toggle current accordion
    const content = document.getElementById(`accordion-${index}`);
    const arrow = document.getElementById(`arrow-${index}`);
    
    if (content && arrow) {
        content.classList.toggle('active');
        arrow.classList.toggle('open');
    }
};

        // ========================================
        // NOTES MANAGEMENT - FIXED
        // ========================================

        async function renderNotes() {
    try {
        const notesContent = document.getElementById('notesContent');
        if (!notesContent) return;
        
        // Fixed query - just get the notes without joins
        const { data: notesData, error } = await supabaseClient
            .from('shift_notes')
            .select('*')
            .order('created_at', { ascending: false })
            .limit(50);
        
        if (error) throw error;
        
        // Manually enrich with related data
        const enrichedNotes = [];
        if (notesData) {
            for (const note of notesData) {
                const shift = shifts.find(s => s.id === note.shift_id) || {};
                const noteStaff = staff.find(s => s.id === note.staff_id) || {};
                const participant = shift.participant_id ? 
                    participants.find(p => p.id === shift.participant_id) : null;
                
                enrichedNotes.push({
                    ...note,
                    shift: shift,
                    staff: noteStaff,
                    participant: participant
                });
            }
        }
        
        let html = `
            <style>
                .notes-wrapper {
                    background: white;
                    border-radius: var(--radius-lg);
                    overflow: hidden;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
                }
                
                .note-item {
                    padding: 20px;
                    border-bottom: 1px solid #e9ecef;
                    transition: all 0.2s;
                }
                
                .note-item:hover {
                    background: #f8f9fa;
                }
                
                .note-header {
                    display: flex;
                    justify-content: space-between;
                    align-items: start;
                    margin-bottom: 12px;
                }
                
                .note-type-badge {
                    display: inline-block;
                    padding: 4px 10px;
                    border-radius: 12px;
                    font-size: 11px;
                    font-weight: 600;
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                    margin-right: 8px;
                }
                
                .note-type-shift {
                    background: #cce5ff;
                    color: #004085;
                }
                
                .note-type-handover {
                    background: #fff3cd;
                    color: #856404;
                }
                
                .note-type-incident {
                    background: #f8d7da;
                    color: #721c24;
                }
                
                .note-content {
                    background: #f8f9fa;
                    padding: 16px;
                    border-radius: 8px;
                    margin: 12px 0;
                    line-height: 1.6;
                    color: var(--text-secondary);
                }
                
                .note-meta {
                    font-size: 12px;
                    color: var(--text-muted);
                    display: flex;
                    gap: 16px;
                }
            </style>
            
            <div class="notes-wrapper">
        `;
        
        if (enrichedNotes && enrichedNotes.length > 0) {
            enrichedNotes.forEach(note => {
                html += `
                    <div class="note-item">
                        <div class="note-header">
                            <div>
                                <span class="note-type-badge note-type-${note.note_type || 'shift'}">${note.note_type || 'shift'}</span>
                                <strong>${note.staff?.first_name || 'Unknown'} ${note.staff?.last_name || ''}</strong>
                            </div>
                            <span style="font-size: 12px; color: var(--text-muted);">
                                ${formatDateTime(note.created_at)}
                            </span>
                        </div>
                        <div class="note-content">${note.note}</div>
                        <div class="note-meta">
                            <span>üìÖ ${note.shift?.date ? formatDateFriendly(note.shift.date) : 'No date'}</span>
                            ${note.shift?.start_time ? `
                                <span>‚è∞ ${formatTime12Hour(note.shift.start_time)} - ${formatTime12Hour(note.shift.end_time)}</span>
                            ` : ''}
                            ${note.participant ? `
                                <span>üë§ ${note.participant.first_name} ${note.participant.last_name}</span>
                            ` : ''}
                        </div>
                    </div>
                `;
            });
        } else {
            html += `
                <div style="text-align: center; padding: 60px 20px; color: var(--text-muted);">
                    <div style="font-size: 48px; margin-bottom: 16px;">üìù</div>
                    <h3>No notes found</h3>
                    <p>Shift notes and communications will appear here</p>
                    <button class="btn btn-primary" onclick="showAddNoteModal()" style="margin-top: 16px;">
                        Add First Note
                    </button>
                </div>
            `;
        }
        
        html += '</div>';
        notesContent.innerHTML = html;
        
    } catch (error) {
        console.error('Error loading notes:', error);
        document.getElementById('notesContent').innerHTML = 
            '<div class="error">Failed to load notes: ' + error.message + '</div>';
    }
}
// Enhanced Add Note Modal
function showAddNoteModal() {
    const modal = document.getElementById('addNoteModal');
    if (!modal) {
        // Create modal if it doesn't exist
        const modalHtml = `
            <div id="addNoteModal" class="modal-overlay" style="display: none;">
                <div class="modal">
                    <header class="modal-header">
                        <h3 class="modal-title">Add Shift Note</h3>
                        <button class="modal-close" onclick="closeModal('addNoteModal')">&times;</button>
                    </header>
                    <div class="modal-content">
                        <form id="addNoteForm">
                            <div class="form-group">
                                <label class="form-label">Shift *</label>
                                <select class="form-control" id="noteShift" required>
                                    <option value="">Select Shift</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Note Type *</label>
                                <select class="form-control" id="noteType" required>
                                    <option value="shift">Shift Note (Visible to All)</option>
                                    <option value="handover">Handover Note (Private)</option>
                                    <option value="incident">Incident Report</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Note *</label>
                                <textarea class="form-control" id="noteContent" required 
                                          placeholder="Enter your note..." rows="4"></textarea>
                            </div>
                        </form>
                    </div>
                    <footer class="modal-footer">
                        <div class="modal-actions">
                            <button class="btn btn-outline" onclick="closeModal('addNoteModal')">Cancel</button>
                            <button class="btn btn-primary" onclick="createNote()">Add Note</button>
                        </div>
                    </footer>
                </div>
            </div>
        `;
        document.body.insertAdjacentHTML('beforeend', modalHtml);
    }
    
    // Populate shifts dropdown
    const noteShiftSelect = document.getElementById('noteShift');
    noteShiftSelect.innerHTML = '<option value="">Select Shift</option>';
    
    // Get recent and upcoming shifts for notes
    const relevantShifts = shifts.filter(shift => {
        const shiftDate = new Date(shift.date);
        const today = new Date();
        const daysDiff = Math.abs((shiftDate - today) / (1000 * 60 * 60 * 24));
        return daysDiff <= 30; // Show shifts within 30 days
    });
    
    relevantShifts.forEach(shift => {
        const staff = shift.staff || {};
        const participant = shift.participant || {};
        const shiftLabel = `${formatDateFriendly(shift.date)} - ${staff.first_name} ${staff.last_name} / ${participant.first_name || 'Unassigned'} ${participant.last_name || ''}`;
        noteShiftSelect.innerHTML += `<option value="${shift.id}">${shiftLabel}</option>`;
    });
    
    document.getElementById('addNoteModal').style.display = 'flex';
}

        async function createNote() {
            try {
                const shiftId = parseInt(document.getElementById('noteShift').value); // SERIAL - use parseInt
                const noteType = document.getElementById('noteType').value;
                const noteContent = document.getElementById('noteContent').value;

                if (!shiftId || !noteType || !noteContent?.trim()) {
                    showNotification('Please fill in all fields', 'error');
                    return;
                }

                const { error } = await supabaseClient
                    .from('shift_notes')
                    .insert([{
                        shift_id: shiftId,
                        staff_id: currentStaffData?.id || currentUser.id,
                        note_type: noteType,
                        note: noteContent.trim()
                    }]);

                if (error) throw error;

                showNotification('Note added successfully', 'success');
                closeModal('addNoteModal');
                if (currentView === 'notes') renderNotes();

            } catch (error) {
                console.error('Error creating note:', error);
                showNotification('Failed to add note: ' + error.message, 'error');
            }
        }

        function addNoteToShift(shiftId) {
            showAddNoteModal();
            setTimeout(() => {
                document.getElementById('noteShift').value = shiftId;
            }, 100);
        }

        // ========================================
        // PUBLIC HOLIDAYS MANAGEMENT
        // ========================================

        async function loadPublicHolidays() {
            try {
                const storedHolidays = localStorage.getItem('mcm_public_holidays');
                if (storedHolidays) {
                    const holidays = JSON.parse(storedHolidays);
                    Object.keys(holidays).forEach(date => publicHolidays.add(date));
                } else {
                    loadDefaultAustralianHolidays();
                }
                
                console.log('Loaded public holidays:', publicHolidays.size);
                
            } catch (error) {
                console.log('Loading default holidays due to error');
                loadDefaultAustralianHolidays();
            }
        }

        function loadDefaultAustralianHolidays() {
            const currentYear = new Date().getFullYear();
            const defaultHolidays = {
                [`${currentYear}-01-01`]: "New Year's Day",
                [`${currentYear}-01-26`]: "Australia Day", 
                [`${currentYear}-03-29`]: "Good Friday",
                [`${currentYear}-04-01`]: "Easter Monday",
                [`${currentYear}-04-25`]: "ANZAC Day",
                [`${currentYear}-12-25`]: "Christmas Day",
                [`${currentYear}-12-26`]: "Boxing Day"
            };
            
            Object.keys(defaultHolidays).forEach(date => publicHolidays.add(date));
            localStorage.setItem('mcm_public_holidays', JSON.stringify(defaultHolidays));
        }

        function showPublicHolidayModal() {
            document.getElementById('publicHolidayModal').style.display = 'flex';
            populateHolidayList();
        }

        function showAddHolidayForm() {
            document.getElementById('addHolidayForm').style.display = 'block';
        }

        function cancelAddHoliday() {
            document.getElementById('addHolidayForm').style.display = 'none';
            document.getElementById('holidayDate').value = '';
            document.getElementById('holidayName').value = '';
        }

        function addHoliday() {
            const date = document.getElementById('holidayDate').value;
            const name = document.getElementById('holidayName').value;
            
            if (!date || !name) {
                showNotification('Please enter both date and name', 'error');
                return;
            }
            
            publicHolidays.add(date);
            const holidays = JSON.parse(localStorage.getItem('mcm_public_holidays') || '{}');
            holidays[date] = name;
            localStorage.setItem('mcm_public_holidays', JSON.stringify(holidays));
            
            populateHolidayList();
            cancelAddHoliday();
            showNotification('Holiday added successfully', 'success');
            
            // Recalculate all shifts
            if (shifts.length > 0) {
                shifts.forEach(shift => {
                    shift.calculated_hours = calculateShiftHours(shift);
                    shift.calculated_pay = calculateShiftPay(shift, shift.calculated_hours);
                });
                renderCurrentView();
            }
        }

        function populateHolidayList() {
            const holidayList = document.getElementById('holidayList');
            const sortedHolidays = Array.from(publicHolidays).sort();
            const holidayNames = JSON.parse(localStorage.getItem('mcm_public_holidays') || '{}');
            
            if (sortedHolidays.length === 0) {
                holidayList.innerHTML = '<div class="empty-state"><p>No holidays configured</p></div>';
                return;
            }
            
            holidayList.innerHTML = sortedHolidays.map(date => `
                <div class="holiday-item">
                    <span>${formatDate(date)} - ${holidayNames[date] || 'Public Holiday'}</span>
                    <button class="btn btn-danger btn-sm" onclick="removeHoliday('${date}')">Remove</button>
                </div>
            `).join('');
        }

        function removeHoliday(date) {
            publicHolidays.delete(date);
            const holidays = JSON.parse(localStorage.getItem('mcm_public_holidays') || '{}');
            delete holidays[date];
            localStorage.setItem('mcm_public_holidays', JSON.stringify(holidays));
            populateHolidayList();
        }

        function loadAustralianHolidays() {
            loadDefaultAustralianHolidays();
            populateHolidayList();
            showNotification('Australian holidays loaded successfully', 'success');
        }

        // ========================================
        // EXPORT FUNCTIONS - FIXED
        // ========================================

        function exportShifts() {
    if (!filteredShifts || filteredShifts.length === 0) {
        showNotification('No shifts to export', 'error');
        return;
    }
    
    // FIX #6: Include complete data in export
    const exportData = filteredShifts.map(shift => {
        const staffMember = staff.find(s => s.id === shift.staff_id);
        const participant = participants.find(p => p.id === shift.participant_id);
        const location = locations.find(l => l.id === shift.location_id);
        const dutyType = dutyTypes.find(d => d.id === shift.duty_type_id);
        const hours = calculateShiftHours(shift);
        
        // Format date properly for Excel
        const shiftDate = new Date(shift.date + 'T12:00:00');
        const formattedDate = shiftDate.toLocaleDateString('en-AU');
        
        return {
            ID: shift.id,
            Date: formattedDate,
            DayOfWeek: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][shiftDate.getDay()],
            StaffCode: staffMember?.staff_code || '',
            StaffFirstName: staffMember?.first_name || '',
            StaffLastName: staffMember?.last_name || '',
            ParticipantFirstName: participant?.first_name || '',
            ParticipantLastName: participant?.last_name || '',
            ParticipantNDIS: participant?.ndis_number || '',
            Location: location?.name || participant ? 'Client Home' : 'Unassigned',
            LocationAddress: location?.address || '',
            StartTime: shift.start_time || '',
            EndTime: shift.end_time || '',
            DutyType: dutyType?.name || '',
            Status: shift.status || 'scheduled',
            
            // Hours breakdown
            TotalHours: hours.total.toFixed(2),
            WeekdayDayHours: (hours.weekdayDay || 0).toFixed(2),
            WeekdayEveningHours: (hours.weekdayEvening || 0).toFixed(2),
            WeekdayNightHours: (hours.weekdayNight || 0).toFixed(2),
            SaturdayHours: (hours.saturday || 0).toFixed(2),
            SundayHours: (hours.sunday || 0).toFixed(2),
            PublicHolidayHours: (hours.publicHoliday || 0).toFixed(2),
            SleepoverCount: hours.sleepover ? (hours.sleepover / 2) : 0,
            
            // Pay information
            BaseRate: staffMember?.base_pay_rate || 0,
            CalculatedPay: (shift.calculated_pay || 0).toFixed(2),
            PayOverride: shift.pay_override_id ? 'Yes' : 'No',
            
            // Additional info
            Notes: shift.notes || '',
            CreatedAt: formatDateTime(shift.created_at),
            UpdatedAt: shift.updated_at ? formatDateTime(shift.updated_at) : '',
            TransferStatus: shift.transfer_status || '',
            AdjustmentStatus: shift.adjustment_status || ''
        };
    });
    
    downloadCSV(exportData, `shifts-export-${formatDate(new Date().toISOString())}.csv`);
    showNotification('Shifts exported successfully', 'success');
}

async function checkBulkShiftConflicts(shiftsToImport) {
    const conflicts = [];
    const warnings = [];
    
    for (const shift of shiftsToImport) {
        // Check for existing shifts
        const { data: existingShifts } = await supabaseClient
            .from('shifts')
            .select('*')
            .eq('staff_id', shift.staff_id)
            .eq('date', shift.date)
            .is('deleted_at', null);
        
        if (existingShifts && existingShifts.length > 0) {
            for (const existing of existingShifts) {
                // Check for overlaps
                if (shift.start_time && shift.end_time && existing.start_time && existing.end_time) {
                    const newStart = new Date(`2000-01-01T${shift.start_time}`);
                    const newEnd = new Date(`2000-01-01T${shift.end_time}`);
                    const existStart = new Date(`2000-01-01T${existing.start_time}`);
                    const existEnd = new Date(`2000-01-01T${existing.end_time}`);
                    
                    if (newEnd <= newStart) newEnd.setDate(newEnd.getDate() + 1);
                    if (existEnd <= existStart) existEnd.setDate(existEnd.getDate() + 1);
                    
                    if (!(newEnd <= existStart || newStart >= existEnd)) {
                        conflicts.push({
                            importShift: shift,
                            existingShift: existing,
                            type: 'overlap',
                            message: `Staff ${shift.staff_name} has overlapping shifts on ${shift.date}`
                        });
                    }
                }
            }
        }
        
        // Check weekly hour limits
        const weekStart = getWeekStart(new Date(shift.date));
        const weekEnd = new Date(weekStart.getTime() + 7 * 24 * 60 * 60 * 1000);
        
        const { data: weekShifts } = await supabaseClient
            .from('shifts')
            .select('*')
            .eq('staff_id', shift.staff_id)
            .gte('date', weekStart.toISOString().split('T')[0])
            .lt('date', weekEnd.toISOString().split('T')[0])
            .is('deleted_at', null);
        
        let weekHours = 0;
        if (weekShifts) {
            weekShifts.forEach(s => {
                const hours = calculateShiftHours(s);
                weekHours += hours.total;
            });
        }
        
        const shiftHours = calculateShiftHours(shift);
        const staffMember = staff.find(s => s.id === shift.staff_id);
        const limit = staffMember?.weekly_hour_limit || 38;
        
        if (weekHours + shiftHours.total > limit) {
            warnings.push({
                shift: shift,
                type: 'hours',
                message: `Staff ${shift.staff_name} will exceed ${limit}h weekly limit (${weekHours + shiftHours.total}h total)`
            });
        }
    }
    
    return { conflicts, warnings };
}

async function createCareHomeBatchShifts() {
    const careHomeId = document.getElementById('batchCareHomeSelect')?.value;
    const date = document.getElementById('batchShiftDate')?.value;
    const startTime = document.getElementById('batchStartTime')?.value;
    const endTime = document.getElementById('batchEndTime')?.value;
    const selectedStaffId = document.getElementById('batchStaffSelect')?.value;
    const dutyTypeId = document.getElementById('batchDutyType')?.value;
    
    if (!careHomeId || !date || !selectedStaffId || !dutyTypeId) {
        showNotification('Please fill all required fields', 'error');
        return;
    }
    
    const careHome = careHomes.get(careHomeId);
    if (!careHome || !careHome.residents) {
        showNotification('No residents found for this care home', 'error');
        return;
    }
    
    try {
        // Check staff availability first
        const { data: existingShifts } = await supabaseClient
            .from('shifts')
            .select('*')
            .eq('staff_id', selectedStaffId)
            .eq('date', date)
            .is('deleted_at', null);
        
        if (existingShifts && existingShifts.length > 0) {
            const message = `‚ö†Ô∏è WARNING\n\n` +
                `Staff member already has ${existingShifts.length} shift(s) on ${date}.\n` +
                `Creating ${careHome.residents.length} additional shifts.\n\n` +
                `Continue?`;
            
            if (!confirm(message)) {
                return;
            }
        }
        
        // Calculate duration for each shift
        const selectedDutyType = dutyTypes.find(d => d.id === dutyTypeId);
        let duration = 0;
        
        if (selectedDutyType?.name.toLowerCase().includes('sleepover')) {
            duration = 2;
        } else if (startTime && endTime) {
            const start = new Date(`2000-01-01T${startTime}`);
            let end = new Date(`2000-01-01T${endTime}`);
            if (end <= start) end.setDate(end.getDate() + 1);
            duration = (end - start) / (1000 * 60 * 60);
        }
        
        // Create shifts for each resident
        const shiftsToCreate = careHome.residents.map(resident => ({
            date,
            start_time: startTime || null,
            end_time: endTime || null,
            staff_id: selectedStaffId,
            participant_id: resident.id,
            location_id: careHomeId,
            duty_type_id: dutyTypeId,
            status: 'confirmed',
            duration_hours: duration || null,
            notes: `Batch created for ${careHome.name}`,
            created_at: new Date().toISOString(),
            created_by: currentUser?.id || currentStaffData?.id
        }));
        
        // Batch insert
        const { data: createdShifts, error } = await supabaseClient
            .from('shifts')
            .insert(shiftsToCreate)
            .select();
        
        if (error) throw error;
        
        showNotification(`Created ${createdShifts.length} shifts for ${careHome.name}`, 'success');
        
        // Close modal if exists
        const modal = document.getElementById('batchCreateModal');
        if (modal) closeModal('batchCreateModal');
        
        await loadShifts();
        
        if (currentView === 'conflicts') {
            await renderConflicts();
        } else {
            renderCurrentView();
        }
        
    } catch (error) {
        console.error('Error creating batch shifts:', error);
        showNotification('Failed to create batch shifts: ' + error.message, 'error');
    }
}

async function createCareHomeShifts() {
    const careHomeId = document.getElementById('batchCareHomeSelect')?.value;
    const date = document.getElementById('batchShiftDate')?.value;
    const startTime = document.getElementById('batchStartTime')?.value;
    const endTime = document.getElementById('batchEndTime')?.value;
    const selectedStaffId = document.getElementById('batchStaffSelect')?.value;
    const dutyTypeId = document.getElementById('batchDutyType')?.value;
    
    if (!careHomeId || !date || !selectedStaffId || !dutyTypeId) {
        showNotification('Please fill all required fields', 'error');
        return;
    }
    
    const careHome = careHomes.get(careHomeId);
    if (!careHome) {
        showNotification('Care home not found', 'error');
        return;
    }
    
    try {
        // Check for conflicts first
        const { data: existingShifts } = await supabaseClient
            .from('shifts')
            .select('*')
            .eq('staff_id', selectedStaffId)
            .eq('date', date)
            .is('deleted_at', null);
        
        if (existingShifts && existingShifts.length > 0) {
            if (!confirm(`Staff member already has ${existingShifts.length} shift(s) on this date. Continue?`)) {
                return;
            }
        }
        
        // Create shifts for each resident
        const shiftsToCreate = careHome.residents.map(resident => ({
            date,
            start_time: startTime || null,
            end_time: endTime || null,
            staff_id: selectedStaffId,
            participant_id: resident.id,
            location_id: careHomeId,
            duty_type_id: dutyTypeId,
            status: 'scheduled',
            notes: `Batch created for ${careHome.name}`,
            created_at: new Date().toISOString(),
            created_by: currentUser?.id
        }));
        
        // Calculate duration for each shift
        shiftsToCreate.forEach(shift => {
            const dutyType = dutyTypes.find(d => d.id === dutyTypeId);
            if (dutyType?.name.toLowerCase().includes('sleepover')) {
                shift.duration_hours = 2;
            } else if (startTime && endTime) {
                const start = new Date(`2000-01-01T${startTime}`);
                let end = new Date(`2000-01-01T${endTime}`);
                if (end <= start) end.setDate(end.getDate() + 1);
                shift.duration_hours = (end - start) / (1000 * 60 * 60);
            }
        });
        
        // Batch insert
        const { error } = await supabaseClient
            .from('shifts')
            .insert(shiftsToCreate);
        
        if (error) throw error;
        
        showNotification(`Created ${shiftsToCreate.length} shifts for ${careHome.name}`, 'success');
        closeModal('batchCreateModal');
        await loadShifts();
        
        if (currentView === 'conflicts') {
            await renderConflicts();
        } else {
            renderCurrentView();
        }
        
    } catch (error) {
        console.error('Error creating batch shifts:', error);
        showNotification('Failed to create batch shifts: ' + error.message, 'error');
    }
}

        function generatePayrollSummary() {
    const startDate = document.getElementById('startDate').value;
    const endDate = document.getElementById('endDate').value;
    
    if (!startDate || !endDate) {
        showNotification('Please set date range for payroll', 'error');
        return;
    }
    
    const staffPayroll = {};
    
    filteredShifts.forEach(shift => {
        const staffId = shift.staff_id;
        if (!staffPayroll[staffId]) {
            staffPayroll[staffId] = {
                staff: shift.staff,
                totalHours: { 
                    total: 0, weekdayDay: 0, weekdayEvening: 0, weekdayNight: 0, 
                    saturday: 0, sunday: 0, publicHoliday: 0, sleepover: 0 
                },
                totalPay: 0,
                shifts: [],
                sleepoverCount: 0
            };
        }
        
        const entry = staffPayroll[staffId];
        const hours = shift.calculated_hours || {};
        
        entry.shifts.push(shift);
        entry.totalPay += shift.calculated_pay || 0;
        
        // Count sleepovers
        if (hours.sleepover > 0) {
            entry.sleepoverCount++;
        }
        
        Object.keys(entry.totalHours).forEach(category => {
            entry.totalHours[category] += hours[category] || 0;
        });
    });
    
    // Generate export data with pay rates
    const payrollData = Object.values(staffPayroll).map(entry => {
        const staff = entry.staff || { first_name: 'Unknown', last_name: 'Staff', staff_code: '', limits: 76 };
        const hourLimit = parseFloat(staff.limits) || 76;
        const overLimit = entry.totalHours.total > hourLimit;
        const finalHours = Math.min(entry.totalHours.total, hourLimit);
        const deductedHours = Math.max(0, entry.totalHours.total - hourLimit);
        
        // Get the staff's pay rate
        let payRate = null;
        if (staff.pay_rate_id) {
            payRate = payRates.find(pr => pr.id === staff.pay_rate_id);
        }
        if (!payRate) {
            payRate = payRates.find(pr => pr.id === '00000000-0000-0000-0000-000000000002') || {};
        }
        
        // Get pay rate label
        const payRateLabel = staff.pay_rate_id ? 
            (payRateLabels.get(staff.pay_rate_id) || 'Standard Rate') : 
            'Standard Rate';
        
        return {
            StaffName: `${staff.first_name} ${staff.last_name}`,
            StaffCode: staff.staff_code || '',
            PayRateLabel: payRateLabel,
            DayRate: `$${(payRate.hourly_pay_rate || 0).toFixed(2)}`,
            EveningRate: `$${(payRate.afternoon || 0).toFixed(2)}`,
            NightRate: `$${(payRate.night || 0).toFixed(2)}`,
            SaturdayRate: `$${(payRate.saturday || 0).toFixed(2)}`,
            SundayRate: `$${(payRate.sunday || 0).toFixed(2)}`,
            PublicHolidayRate: `$${(payRate.public_holiday || 0).toFixed(2)}`,
            SleepoverRate: `$${(payRate.sleepover || 0).toFixed(2)}`,
            RawHours: formatHours(entry.totalHours.total),
            HourLimit: hourLimit.toFixed(0),
            OverLimit: overLimit ? 'YES' : 'NO',
            DeductedHours: formatHours(deductedHours),
            FinalHours: formatHours(finalHours),
            WeekdayDayHours: formatHours(entry.totalHours.weekdayDay),
            WeekdayEveningHours: formatHours(entry.totalHours.weekdayEvening),
            WeekdayNightHours: formatHours(entry.totalHours.weekdayNight),
            SaturdayHours: formatHours(entry.totalHours.saturday),
            SundayHours: formatHours(entry.totalHours.sunday),
            PublicHolidayHours: formatHours(entry.totalHours.publicHoliday),
            SleepoverCount: entry.sleepoverCount,
            SleepoverHours: formatHours(entry.totalHours.sleepover),
            TotalPay: `$${entry.totalPay.toFixed(2)}`,
            ShiftCount: entry.shifts.length,
            DateRange: `${startDate} to ${endDate}`
        };
    });
    
    downloadCSV(payrollData, `payroll-summary-${startDate}-to-${endDate}.csv`);
}
        function exportData() {
            // Fixed export with proper staff name handling
            const exportData = filteredShifts.map(shift => {
                const staff = shift.staff || { first_name: 'Unknown', last_name: 'Staff' };
                const participant = shift.participant || {};
                const location = shift.location || {};
                const dutyType = shift.duty_type || {};
                const hours = shift.calculated_hours || { total: 0 };
                
                return {
                    Date: formatDate(shift.date),
                    Staff: `${staff.first_name} ${staff.last_name}`,
                    Client: participant.first_name ? `${participant.first_name} ${participant.last_name}` : location.name || 'Unassigned',
                    StartTime: shift.start_time || '',
                    EndTime: shift.end_time || '',
                    DutyType: dutyType.name || '',
                    TotalHours: hours.total.toFixed(2),
                    TotalPay: (shift.calculated_pay || 0).toFixed(2),
                    Status: shift.status || 'pending'
                };
            });

            downloadCSV(exportData, 'shifts-export.csv');
        }

        function exportTimesheet() {
            generatePayrollSummary(); // Use detailed payroll export
        }

        // ========================================
        // UTILITY FUNCTIONS
        // ========================================

        function formatDate(dateString) {
            if (!dateString) return '';
            const date = new Date(dateString);
            return date.toLocaleDateString('en-AU', {
                day: '2-digit',
                month: '2-digit', 
                year: 'numeric'
            });
        }

        function formatDateLong(dateString) {
            if (!dateString) return '';
            const date = new Date(dateString);
            return date.toLocaleDateString('en-AU', {
                weekday: 'long',
                day: 'numeric',
                month: 'long',
                year: 'numeric'
            });
        }

        function formatDateTime(dateTimeString) {
            if (!dateTimeString) return '';
            const date = new Date(dateTimeString);
            return date.toLocaleString('en-AU', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function downloadCSV(data, filename) {
            if (!data || data.length === 0) {
                showNotification('No data to export', 'error');
                return;
            }

            const headers = Object.keys(data[0]);
            const csvContent = [
                headers.join(','),
                ...data.map(row => headers.map(header => 
                    `"${(row[header] || '').toString().replace(/"/g, '""')}"`
                ).join(','))
            ].join('\n');

            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            
            showNotification(`${filename} downloaded successfully`, 'success');
        }

        function showNotification(message, type = 'info', duration = 4000) {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, duration);
        }

        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.style.display = 'none';
                
                // Reset all forms in the modal
                const forms = modal.querySelectorAll('form');
                forms.forEach(form => form.reset());
                
                // Clear hidden inputs and searchable inputs
                const hiddenInputs = modal.querySelectorAll('input[type="hidden"]');
                hiddenInputs.forEach(input => input.value = '');
                
                const searchableInputs = modal.querySelectorAll('.searchable-input');
                searchableInputs.forEach(input => input.value = '');
                
                // Hide any warning elements
                const warnings = modal.querySelectorAll('.hour-warning');
                warnings.forEach(warning => warning.style.display = 'none');
            }
        }

        function clearAllFilters() {
            document.getElementById('staffFilterInput').value = '';
            document.getElementById('participantFilterInput').value = '';
            document.getElementById('statusFilter').value = '';
            
            staffFilterValue = '';
            participantFilterValue = '';
            
            // Reset to current week
            setCurrentWeek();
            
            showNotification('All filters cleared, showing current week', 'info');
            applyFilters();
        }

        async function loadInitialData() {
    try {
        console.log('=== LOADING REFERENCE DATA ===');
        
        // Load all reference data in parallel
        const [
            { data: staffData, error: staffError },
            { data: participantsData, error: participantsError },
            { data: locationsData, error: locationsError },
            { data: dutyTypesData, error: dutyTypesError },
            { data: payRatesData, error: payRatesError },
            { data: payRateLabelsData, error: payRateLabelsError }
        ] = await Promise.all([
            supabaseClient.from('staff').select('*').eq('is_active', true).is('deleted_at', null).order('first_name'),
            supabaseClient.from('participants').select('*').eq('is_active', true).is('deleted_at', null).order('first_name'),
            supabaseClient.from('locations').select('*').order('name'),
            supabaseClient.from('duty_types').select('*').order('name'),
            supabaseClient.from('pay_rates').select('*').order('category, level, pay_point'),
            supabaseClient.from('pay_rate_labels').select('*')
        ]);

        // Check for errors
        if (staffError) throw staffError;
        if (participantsError) throw participantsError;
        if (locationsError) throw locationsError;
        if (dutyTypesError) throw dutyTypesError;
        if (payRatesError) throw payRatesError;
        if (payRateLabelsError) console.warn('Pay rate labels error:', payRateLabelsError);
        
        // Assign to global variables
        staff = staffData || [];
        participants = participantsData || [];
        locations = locationsData || [];
        dutyTypes = dutyTypesData || [];
        payRates = payRatesData || [];
        
        // Create pay rate labels map
        payRateLabels = new Map();
        if (payRateLabelsData) {
            payRateLabelsData.forEach(label => {
                payRateLabels.set(label.id, label.label);
            });
        }
        
        // Detect all care homes based on shared addresses
        detectCareHomes();
        
        console.log('Reference data loaded:', {
            staff: staff.length,
            participants: participants.length,
            locations: locations.length,
            dutyTypes: dutyTypes.length,
            payRates: payRates.length,
            payRateLabels: payRateLabels.size,
            careHomes: careHomes.size
        });
        
        // Initialize undo/redo buttons if they exist
        if (typeof UndoRedoManager !== 'undefined') {
            UndoRedoManager.updateButtons();
        }
        
        populateFilterDropdowns();
        populateModalDropdowns();

    } catch (error) {
        console.error('Error loading initial data:', error);
        showNotification('Failed to load reference data: ' + error.message, 'error');
    }
}

        function refreshData() {
            showNotification('Refreshing data...', 'info');
            Promise.all([loadInitialData(), loadShifts()])
                .then(() => {
                    showNotification('Data refreshed successfully', 'success');
                })
                .catch(error => {
                    console.error('Refresh error:', error);
                    showNotification('Failed to refresh data: ' + error.message, 'error');
                });
        }

        async function logout() {
            try {
                const { error } = await supabaseClient.auth.signOut();
                if (error) throw error;
                window.location.href = 'index.html';
            } catch (error) {
                console.error('Logout error:', error);
                showNotification('Logout failed', 'error');
            }
        }

        // ========================================
        // DEBUG FUNCTIONS
        // ========================================

        async function debugDataLoading() {
            console.log('=== COMPREHENSIVE DEBUG ANALYSIS ===');
            
            try {
                // Database connectivity tests
                const { count: shiftCount } = await supabaseClient
                    .from('shifts')
                    .select('*', { count: 'exact', head: true });
                    
                const { count: staffCount } = await supabaseClient
                    .from('staff')
                    .select('*', { count: 'exact', head: true });

                // Sample data with detailed info
                const { data: sampleShifts } = await supabaseClient
                    .from('shifts')
                    .select('id, date, start_time, end_time, staff_id, status, duration_hours, deleted_at')
                    .is('deleted_at', null)
                    .limit(5);
                    
                const { data: sampleStaff } = await supabaseClient
                    .from('staff')
                    .select('id, first_name, last_name, limits, is_active')
                    .eq('is_active', true)
                    .limit(3);
                
                console.log('Debug results:', {
                    database: { shiftCount, staffCount },
                    loaded: { 
                        shifts: shifts.length, 
                        filtered: filteredShifts.length,
                        staff: staff.length,
                        participants: participants.length 
                    },
                    samples: { sampleShifts, sampleStaff }
                });
                
                // Calculate sample hours for debugging
                let calculationTest = '';
                if (sampleShifts && sampleShifts.length > 0) {
                    const testShift = sampleShifts[0];
                    calculationTest = `
HOUR CALCULATION TEST:
Shift ID: ${testShift.id}
Date: ${testShift.date}
Start: ${testShift.start_time}
End: ${testShift.end_time}
Duration DB: ${testShift.duration_hours}`;
                }
                
                const filters = {
                    startDate: document.getElementById('startDate').value,
                    endDate: document.getElementById('endDate').value,
                    staffFilter: staffFilterValue,
                    participantFilter: participantFilterValue
                };
                
                alert(`DEBUG RESULTS:

DATABASE:
‚Ä¢ ${shiftCount || 0} total shifts
‚Ä¢ ${staffCount || 0} total staff

LOADED DATA:
‚Ä¢ ${shifts.length} shifts in memory
‚Ä¢ ${filteredShifts.length} after filters
‚Ä¢ ${staff.length} staff loaded
‚Ä¢ ${participants.length} participants loaded
‚Ä¢ ${publicHolidays.size} public holidays

CURRENT FILTERS:
‚Ä¢ Date: ${filters.startDate} to ${filters.endDate}
‚Ä¢ Staff: ${filters.staffFilter || 'all'}
‚Ä¢ Participant: ${filters.participantFilter || 'all'}

SAMPLE SHIFTS IN DB:
${sampleShifts?.map(s => `‚Ä¢ ${s.date} ${s.start_time}-${s.end_time} (${s.duration_hours}h)`).join('\n') || 'No shifts found'}

SAMPLE STAFF:
${sampleStaff?.map(s => `‚Ä¢ ${s.first_name} ${s.last_name} (limit: ${s.limits}h)`).join('\n') || 'No staff found'}

${calculationTest}

NEXT STEPS:
1. If no data: Create test shifts
2. If data exists but filtered out: Clear filters
3. Check browser console for detailed logs`);
                
            } catch (error) {
                console.error('Debug error:', error);
                alert('Debug failed: ' + error.message);
            }
        }

        // ========================================
        // INITIALIZATION
        // ========================================

        document.addEventListener('DOMContentLoaded', async () => {
            try {
                console.log('=== MC MANAGER STARTING ===');
                await initializeApp();
                console.log('=== MC MANAGER READY ===');
            } catch (error) {
                console.error('Initialization failed:', error);
                showNotification('Initialization failed. Please refresh the page.', 'error');
            }
        });

        // Auth state monitoring
        supabaseClient.auth.onAuthStateChange((event, session) => {
            console.log('Auth state change:', event);
            if (event === 'SIGNED_OUT') {
                window.location.href = 'index.html';
            }
        });

        // Debug helper
        window.mcDebug = {
            shifts: () => shifts,
            filtered: () => filteredShifts,
            staff: () => staff,
            calculateHours: (shiftId) => {
                const shift = shifts.find(s => s.id === shiftId);
                return shift ? calculateShiftHours(shift) : null;
            },
            testCalculation: () => {
                if (shifts.length > 0) {
                    const testShift = shifts[0];
                    console.log('Test calculation for first shift:', {
                        shift: testShift,
                        calculatedHours: calculateShiftHours(testShift),
                        calculatedPay: calculateShiftPay(testShift, calculateShiftHours(testShift))
                    });
                }
            }
        };

        // ============================================
// ENHANCED FEATURES - ADD THIS ENTIRE BLOCK
// ============================================

// 1. Initialize Enhanced Features
function initializeEnhancements() {
    initializeDarkMode();
    resetSessionTimer();
    setupEnhancedKeyboardShortcuts();
    addEnhancedUIElements();
}

// 2. Dark Mode Implementation
function initializeDarkMode() {
    const savedMode = localStorage.getItem('darkMode') || 'light';
    document.body.setAttribute('data-theme', savedMode);
    
    // Add dark mode styles
    if (!document.getElementById('darkModeStyles')) {
        const styleSheet = document.createElement('style');
        styleSheet.id = 'darkModeStyles';
        styleSheet.innerHTML = `
            [data-theme="dark"] {
                --bg-primary: #1a1a1a;
                --bg-secondary: #2d2d2d;
                --bg-light: #3a3a3a;
                --text-primary: #e0e0e0;
                --text-secondary: #b0b0b0;
                --text-muted: #808080;
                --border-color: #404040;
                --border-light: #333333;
            }
            
            [data-theme="dark"] .modal {
                background: var(--bg-secondary);
                color: var(--text-primary);
            }
            
            [data-theme="dark"] .roster-table {
                background: var(--bg-secondary);
            }
            
            [data-theme="dark"] input, 
            [data-theme="dark"] select, 
            [data-theme="dark"] textarea {
                background: var(--bg-light);
                color: var(--text-primary);
                border-color: var(--border-color);
            }
            
            [data-theme="dark"] .card {
                background: var(--bg-secondary);
                border-color: var(--border-color);
            }
        `;
        document.head.appendChild(styleSheet);
    }
}

function toggleDarkMode() {
    const currentMode = document.body.getAttribute('data-theme') || 'light';
    const newMode = currentMode === 'light' ? 'dark' : 'light';
    document.body.setAttribute('data-theme', newMode);
    localStorage.setItem('darkMode', newMode);
    
    // Update button icon
    const btn = document.getElementById('darkModeBtn');
    if (btn) btn.innerHTML = newMode === 'dark' ? '‚òÄÔ∏è' : 'üåô';
}

// 3. Enhanced Keyboard Shortcuts
function setupEnhancedKeyboardShortcuts() {
    document.addEventListener('keydown', function(e) {
        // Skip if typing in input
        if (document.activeElement.tagName === 'INPUT' || 
            document.activeElement.tagName === 'TEXTAREA' || 
            document.activeElement.tagName === 'SELECT') return;
        
        // N - New shift
        if (e.key === 'n' && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            showAddShiftModal();
        }
        
        // F - Focus search
        if (e.key === 'f' && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            document.getElementById('staffFilterInput')?.focus();
        }
        
        // T - Today
        if (e.key === 't' && !e.ctrlKey && !e.metaKey) {
            e.preventDefault();
            setCurrentWeek();
            loadShifts();
        }
        
        // Arrow keys - Navigate weeks
        if (e.key === 'ArrowLeft' && !e.shiftKey && !e.ctrlKey) {
            e.preventDefault();
            previousWeek();
        }
        if (e.key === 'ArrowRight' && !e.shiftKey && !e.ctrlKey) {
            e.preventDefault();
            nextWeek();
        }
        
        // 1-5 - Quick view switches
        if (e.key >= '1' && e.key <= '5' && !e.ctrlKey) {
            const views = ['table', 'summary', 'timesheet', 'requests', 'notes'];
            const viewIndex = parseInt(e.key) - 1;
            if (views[viewIndex]) {
                e.preventDefault();
                switchView(views[viewIndex]);
            }
        }
        
        // Ctrl+K - Global search
        if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
            e.preventDefault();
            showGlobalSearch();
        }
        
        // Ctrl+P - Print
        if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
            e.preventDefault();
            printRoster();
        }
    });
}

// 4. Copy/Duplicate Functions
async function copyShift(shiftId) {
    const shift = shifts.find(s => s.id === shiftId);
    if (!shift) return;
    
    const newDate = prompt('Enter date for copied shift (YYYY-MM-DD):', shift.date);
    if (!newDate) return;
    
    try {
        const shiftData = {
            date: newDate,
            start_time: shift.start_time,
            end_time: shift.end_time,
            staff_id: shift.staff_id,
            participant_id: shift.participant_id,
            location_id: shift.location_id,
            duty_type_id: shift.duty_type_id,
            pay_override_id: shift.pay_override_id,
            status: 'pending',
            created_by: currentStaffData?.id || currentUser.id
        };
        
        const { error } = await supabaseClient
            .from('shifts')
            .insert([shiftData]);
        
        if (!error) {
            showNotification('Shift copied successfully', 'success');
            await loadShifts();
        } else {
            throw error;
        }
    } catch (error) {
        showNotification('Failed to copy shift: ' + error.message, 'error');
    }
}

async function duplicateWeek() {
    const confirmDupe = confirm('Duplicate all shifts from current week to next week?');
    if (!confirmDupe) return;
    
    try {
        const weekStart = getWeekStart(currentWeekStart);
        const weekEnd = new Date(weekStart);
        weekEnd.setDate(weekEnd.getDate() + 6);
        
        const weekShifts = shifts.filter(s => 
            s.date >= weekStart.toISOString().split('T')[0] &&
            s.date <= weekEnd.toISOString().split('T')[0]
        );
        
        if (weekShifts.length === 0) {
            showNotification('No shifts to duplicate in current week', 'warning');
            return;
        }
        
        const newShifts = weekShifts.map(shift => {
            const newDate = new Date(shift.date);
            newDate.setDate(newDate.getDate() + 7);
            
            return {
                date: newDate.toISOString().split('T')[0],
                start_time: shift.start_time,
                end_time: shift.end_time,
                staff_id: shift.staff_id,
                participant_id: shift.participant_id,
                location_id: shift.location_id,
                duty_type_id: shift.duty_type_id,
                pay_override_id: shift.pay_override_id,
                status: 'pending',
                created_by: currentStaffData?.id || currentUser.id
            };
        });
        
        const { error } = await supabaseClient
            .from('shifts')
            .insert(newShifts);
        
        if (!error) {
            showNotification(`${newShifts.length} shifts duplicated to next week`, 'success');
            nextWeek();
        } else {
            throw error;
        }
    } catch (error) {
        showNotification('Failed to duplicate week: ' + error.message, 'error');
    }
}

// 5. Auto-save Indicator
function showSaving() {
    let indicator = document.getElementById('saveIndicator');
    
    if (!indicator) {
        indicator = document.createElement('div');
        indicator.id = 'saveIndicator';
        indicator.style.cssText = `
            position: fixed;
            top: 70px;
            right: 20px;
            background: var(--success-color);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            z-index: 9999;
            display: none;
            align-items: center;
            gap: 8px;
        `;
        document.body.appendChild(indicator);
    }
    
    indicator.innerHTML = '‚è≥ Saving...';
    indicator.style.display = 'flex';
    
    setTimeout(() => {
        indicator.innerHTML = '‚úì Saved';
        setTimeout(() => {
            indicator.style.display = 'none';
        }, 2000);
    }, 500);
}

// 6. Global Search
function showGlobalSearch() {
    // Remove existing if any
    const existing = document.getElementById('searchModal');
    if (existing) existing.remove();
    
    const searchModal = document.createElement('div');
    searchModal.id = 'searchModal';
    searchModal.className = 'modal-overlay';
    searchModal.style.display = 'flex';
    searchModal.innerHTML = `
        <div class="modal" style="max-width: 600px;">
            <header class="modal-header">
                <h3 class="modal-title">Search Everything (Ctrl+K)</h3>
                <button class="modal-close" onclick="closeModal('searchModal')">&times;</button>
            </header>
            <div class="modal-content">
                <input type="text" 
                       id="globalSearchInput" 
                       class="form-control" 
                       placeholder="Search staff, participants, locations..."
                       onkeyup="performGlobalSearch()"
                       autofocus>
                <div id="searchResults" style="margin-top: 16px; max-height: 400px; overflow-y: auto;"></div>
            </div>
        </div>
    `;
    
    document.body.appendChild(searchModal);
    document.getElementById('globalSearchInput').focus();
}

function performGlobalSearch() {
    const query = document.getElementById('globalSearchInput').value.toLowerCase();
    const results = document.getElementById('searchResults');
    
    if (query.length < 2) {
        results.innerHTML = '<p style="color: var(--text-muted);">Type at least 2 characters...</p>';
        return;
    }
    
    let html = '';
    
    // Search staff
    const matchingStaff = staff.filter(s => 
        `${s.first_name} ${s.last_name}`.toLowerCase().includes(query)
    );
    
    if (matchingStaff.length > 0) {
        html += '<h4>Staff</h4>';
        matchingStaff.forEach(s => {
            html += `
                <div style="padding: 8px; cursor: pointer; border-radius: 4px;" 
                     onmouseover="this.style.background='var(--bg-light)'"
                     onmouseout="this.style.background='transparent'"
                     onclick="document.getElementById('staffFilterInput').value='${s.first_name} ${s.last_name}'; 
                              updateStaffFilter(); closeModal('searchModal');">
                    üë§ ${s.first_name} ${s.last_name}
                </div>`;
        });
    }
    
    // Search participants
    const matchingParticipants = participants.filter(p => 
        `${p.first_name} ${p.last_name}`.toLowerCase().includes(query)
    );
    
    if (matchingParticipants.length > 0) {
        html += '<h4 style="margin-top: 16px;">Participants</h4>';
        matchingParticipants.forEach(p => {
            html += `
                <div style="padding: 8px; cursor: pointer; border-radius: 4px;"
                     onmouseover="this.style.background='var(--bg-light)'"
                     onmouseout="this.style.background='transparent'"
                     onclick="document.getElementById('participantFilterInput').value='${p.first_name} ${p.last_name}'; 
                              updateParticipantFilter(); closeModal('searchModal');">
                    üë• ${p.first_name} ${p.last_name}
                </div>`;
        });
    }
    
    results.innerHTML = html || '<p style="text-align: center; color: var(--text-muted);">No results found</p>';
}

// 7. Print Function
function printRoster() {
    // Add print styles if not already added
    if (!document.getElementById('printStyles')) {
        const styleSheet = document.createElement('style');
        styleSheet.id = 'printStyles';
        styleSheet.innerHTML = `
            @media print {
                .header, .filters-section, .view-actions, .modal, .view-toggle, .btn { 
                    display: none !important; 
                }
                
                body { 
                    font-size: 10pt; 
                    color: black !important;
                    background: white !important;
                }
                
                .roster-table { 
                    width: 100%; 
                    border-collapse: collapse;
                    background: white !important;
                }
                
                .roster-table th, .roster-table td { 
                    border: 1px solid #000 !important; 
                    padding: 4px !important;
                    font-size: 9pt !important;
                    color: black !important;
                }
                
                @page { 
                    margin: 1cm;
                    size: landscape;
                }
            }
        `;
        document.head.appendChild(styleSheet);
    }
    
    window.print();
}

// 8. Quick Status Change
async function quickStatusChange(shiftId, newStatus) {
    if (!newStatus) return;
    
    try {
        const { error } = await supabaseClient
            .from('shifts')
            .update({ 
                status: newStatus,
                updated_at: new Date().toISOString()
            })
            .eq('id', shiftId);
        
        if (!error) {
            showSaving();
            showNotification(`Status updated to ${newStatus}`, 'success');
            await loadShifts();
        } else {
            throw error;
        }
    } catch (error) {
        showNotification('Failed to update status: ' + error.message, 'error');
    }
}

// 9. Session Management
let sessionTimer;
let warningTimer;
const SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes
const WARNING_TIME = 5 * 60 * 1000; // 5 minute warning

function resetSessionTimer() {
    clearTimeout(sessionTimer);
    clearTimeout(warningTimer);
    
    warningTimer = setTimeout(() => {
        if (confirm('Your session will expire in 5 minutes. Stay logged in?')) {
            resetSessionTimer();
        }
    }, SESSION_TIMEOUT - WARNING_TIME);
    
    sessionTimer = setTimeout(() => {
        alert('Session expired. Please log in again.');
        window.location.href = 'index.html';
    }, SESSION_TIMEOUT);
}

// Reset timer on activity
document.addEventListener('click', resetSessionTimer);
document.addEventListener('keypress', resetSessionTimer);

// 10. Export Functions
function exportJSON() {
    const dataStr = JSON.stringify(filteredShifts, null, 2);
    const dataBlob = new Blob([dataStr], {type: 'application/json'});
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `roster_${new Date().toISOString().split('T')[0]}.json`;
    link.click();
}

async function processCSVImport(csvData) {
    try {
        // Parse CSV data (assuming you have parsing logic)
        const shiftsToImport = parseCSVData(csvData);
        
        // FIX #2: Check conflicts before bulk import
        const conflictReport = {
            overlaps: [],
            sleepovers: [],
            weeklyLimits: [],
            skipped: 0,
            imported: 0
        };
        
        const validShifts = [];
        
        for (const importShift of shiftsToImport) {
            let hasConflict = false;
            
            // Check for existing shifts
            const { data: existingShifts } = await supabaseClient
                .from('shifts')
                .select('*')
                .eq('staff_id', importShift.staff_id)
                .eq('date', importShift.date)
                .is('deleted_at', null);
            
            // Check for sleepover conflicts
            const isImportSleepover = importShift.duty_type?.toLowerCase().includes('sleepover');
            const existingSleepover = (existingShifts || []).find(s => {
                const dt = dutyTypes.find(d => d.id === s.duty_type_id);
                return dt?.name?.toLowerCase().includes('sleepover');
            });
            
            if (isImportSleepover && existingSleepover) {
                conflictReport.sleepovers.push({
                    shift: importShift,
                    reason: 'Staff already has sleepover on this date'
                });
                hasConflict = true;
                continue;
            }
            
            // Check for time overlaps
            if (importShift.start_time && importShift.end_time && !isImportSleepover) {
                const newStart = new Date(`2000-01-01T${importShift.start_time}`);
                let newEnd = new Date(`2000-01-01T${importShift.end_time}`);
                if (newEnd <= newStart) newEnd.setDate(newEnd.getDate() + 1);
                
                for (const existing of (existingShifts || [])) {
                    if (existing.start_time && existing.end_time) {
                        const existingStart = new Date(`2000-01-01T${existing.start_time}`);
                        let existingEnd = new Date(`2000-01-01T${existing.end_time}`);
                        if (existingEnd <= existingStart) existingEnd.setDate(existingEnd.getDate() + 1);
                        
                        if (!(newEnd <= existingStart || newStart >= existingEnd)) {
                            conflictReport.overlaps.push({
                                importShift,
                                existingShift: existing,
                                overlapHours: ((Math.min(newEnd, existingEnd) - Math.max(newStart, existingStart)) / (1000 * 60 * 60)).toFixed(1)
                            });
                            hasConflict = true;
                            break;
                        }
                    }
                }
            }
            
            // Check weekly hours
            const weekStart = new Date(importShift.date);
            weekStart.setDate(weekStart.getDate() - weekStart.getDay());
            const weekEnd = new Date(weekStart);
            weekEnd.setDate(weekEnd.getDate() + 6);
            
            const { data: weekShifts } = await supabaseClient
                .from('shifts')
                .select('*')
                .eq('staff_id', importShift.staff_id)
                .gte('date', weekStart.toISOString().split('T')[0])
                .lte('date', weekEnd.toISOString().split('T')[0])
                .is('deleted_at', null);
            
            let totalWeekHours = 0;
            (weekShifts || []).forEach(s => {
                totalWeekHours += s.duration_hours || 0;
            });
            
            const staffMember = staff.find(s => s.id === importShift.staff_id);
            const weeklyLimit = staffMember?.weekly_hour_limit || 38;
            const importHours = importShift.duration_hours || 0;
            
            if (totalWeekHours + importHours > weeklyLimit) {
                conflictReport.weeklyLimits.push({
                    shift: importShift,
                    currentHours: totalWeekHours,
                    newTotal: totalWeekHours + importHours,
                    limit: weeklyLimit
                });
            }
            
            if (!hasConflict) {
                validShifts.push(importShift);
            } else {
                conflictReport.skipped++;
            }
        }
        
        // Show conflict report if there are issues
        if (conflictReport.overlaps.length > 0 || 
            conflictReport.sleepovers.length > 0 || 
            conflictReport.weeklyLimits.length > 0) {
            
            let message = 'IMPORT CONFLICTS DETECTED\n\n';
            
            if (conflictReport.overlaps.length > 0) {
                message += `‚ö†Ô∏è ${conflictReport.overlaps.length} overlapping shifts\n`;
            }
            if (conflictReport.sleepovers.length > 0) {
                message += `üõèÔ∏è ${conflictReport.sleepovers.length} sleepover conflicts\n`;
            }
            if (conflictReport.weeklyLimits.length > 0) {
                message += `‚è∞ ${conflictReport.weeklyLimits.length} weekly hour limit warnings\n`;
            }
            
            message += `\n‚úì ${validShifts.length} shifts ready to import\n`;
            message += `‚úó ${conflictReport.skipped} shifts will be skipped\n\n`;
            message += 'Do you want to proceed with importing valid shifts only?';
            
            if (!confirm(message)) {
                showNotification('Import cancelled', 'info');
                return;
            }
        }
        
        // Import valid shifts
        if (validShifts.length > 0) {
            const { error } = await supabaseClient
                .from('shifts')
                .insert(validShifts);
            
            if (error) throw error;
            
            showNotification(`Successfully imported ${validShifts.length} shifts`, 'success');
            conflictReport.imported = validShifts.length;
        } else {
            showNotification('No valid shifts to import', 'warning');
        }
        
        // Generate detailed report
        generateImportReport(conflictReport);
        
        await loadShifts();
        if (currentView === 'conflicts') {
            await renderConflicts();
        } else {
            renderCurrentView();
        }
        
    } catch (error) {
        console.error('Error processing CSV import:', error);
        showNotification('Failed to import shifts: ' + error.message, 'error');
    }
}

function generateImportReport(report) {
    // Create a detailed CSV report of conflicts
    let csvContent = 'Type,Date,Staff,Details,Status\n';
    
    report.overlaps.forEach(item => {
        const staffName = staff.find(s => s.id === item.importShift.staff_id)?.first_name || 'Unknown';
        csvContent += `Overlap,${item.importShift.date},${staffName},"${item.overlapHours}h overlap",Skipped\n`;
    });
    
    report.sleepovers.forEach(item => {
        const staffName = staff.find(s => s.id === item.shift.staff_id)?.first_name || 'Unknown';
        csvContent += `Sleepover,${item.shift.date},${staffName},"${item.reason}",Skipped\n`;
    });
    
    report.weeklyLimits.forEach(item => {
        const staffName = staff.find(s => s.id === item.shift.staff_id)?.first_name || 'Unknown';
        csvContent += `Hours,Week of ${item.shift.date},${staffName},"${item.newTotal}h exceeds ${item.limit}h limit",Warning\n`;
    });
    
    // Download the report
    downloadCSV(csvContent, `import-report-${new Date().toISOString().split('T')[0]}.csv`);
}

function exportDetailedCSV() {
    let csv = 'Date,Day,Start Time,End Time,Staff Name,Participant,Location,Duty Type,Hours,Status,Pay Rate,Total Pay\n';
    
    filteredShifts.forEach(shift => {
        const row = [
            shift.date,
            new Date(shift.date).toLocaleDateString('en-AU', {weekday: 'short'}),
            shift.start_time || 'N/A',
            shift.end_time || 'N/A',
            `${shift.staff?.first_name || ''} ${shift.staff?.last_name || ''}`,
            shift.participant ? `${shift.participant.first_name} ${shift.participant.last_name}` : '',
            shift.location?.name || '',
            shift.duty_type?.name || '',
            shift.calculated_hours?.total?.toFixed(2) || '0',
            shift.status || 'pending',
            payRateLabels.get(shift.staff?.pay_rate_id) || 'Standard',
            shift.calculated_pay?.toFixed(2) || '0'
        ];
        csv += row.map(cell => `"${cell}"`).join(',') + '\n';
    });
    
    downloadCSV(csv, `roster_detailed_${new Date().toISOString().split('T')[0]}.csv`);
}

// 11. Add UI Enhancement Buttons
function addEnhancedUIElements() {
    // Add buttons to view-actions if they don't exist
    const viewActions = document.querySelector('.view-actions');
    if (viewActions && !document.getElementById('enhancedButtons')) {
        const enhancedButtons = document.createElement('div');
        enhancedButtons.id = 'enhancedButtons';
        enhancedButtons.style.display = 'inline-flex';
        enhancedButtons.style.gap = '8px';
        enhancedButtons.style.marginLeft = '8px';
        enhancedButtons.innerHTML = `
            <span style="border-left: 1px solid var(--border-color); margin: 0 8px; height: 24px;"></span>
            <button class="btn btn-outline btn-sm" id="darkModeBtn" onclick="toggleDarkMode()" title="Toggle Dark Mode">
                ${document.body.getAttribute('data-theme') === 'dark' ? '‚òÄÔ∏è' : 'üåô'}
            </button>
            <button class="btn btn-outline btn-sm" onclick="showGlobalSearch()" title="Search (Ctrl+K)">üîç</button>
            <button class="btn btn-outline btn-sm" onclick="duplicateWeek()" title="Duplicate Week">üìã</button>
            <button class="btn btn-outline btn-sm" onclick="printRoster()" title="Print (Ctrl+P)">üñ®Ô∏è</button>
            <button class="btn btn-outline btn-sm" onclick="exportDetailedCSV()" title="Export Detailed CSV">üìä</button>
            <button class="btn btn-outline btn-sm" onclick="showKeyboardShortcuts()" title="Keyboard Shortcuts">‚å®Ô∏è</button>
        `;
        viewActions.appendChild(enhancedButtons);
    }
}

// 12. Keyboard Shortcuts Help
function showKeyboardShortcuts() {
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.style.display = 'flex';
    modal.innerHTML = `
        <div class="modal" style="max-width: 500px;">
            <header class="modal-header">
                <h3 class="modal-title">Keyboard Shortcuts</h3>
                <button class="modal-close" onclick="this.closest('.modal-overlay').remove()">&times;</button>
            </header>
            <div class="modal-content">
                <table style="width: 100%;">
                    <tr><td><kbd>N</kbd></td><td>New Shift</td></tr>
                    <tr><td><kbd>F</kbd></td><td>Focus Search</td></tr>
                    <tr><td><kbd>T</kbd></td><td>Go to Today</td></tr>
                    <tr><td><kbd>‚Üê</kbd> <kbd>‚Üí</kbd></td><td>Navigate Weeks</td></tr>
                    <tr><td><kbd>1-5</kbd></td><td>Switch Views</td></tr>
                    <tr><td><kbd>Ctrl+K</kbd></td><td>Global Search</td></tr>
                    <tr><td><kbd>Ctrl+Z</kbd></td><td>Undo</td></tr>
                    <tr><td><kbd>Ctrl+Y</kbd></td><td>Redo</td></tr>
                    <tr><td><kbd>Ctrl+P</kbd></td><td>Print</td></tr>
                </table>
            </div>
        </div>
    `;
    document.body.appendChild(modal);
}

async function renderConflicts() {
    const conflictsContent = document.getElementById('conflictsContent');
    if (!conflictsContent) {
        // Create the view if it doesn't exist
        const conflictsView = document.getElementById('conflictsView');
        if (conflictsView) {
            conflictsView.innerHTML = `
                <div class="table-container">
                    <header class="table-header">
                        <h2 class="table-title">‚ö†Ô∏è Scheduling Conflicts & Issues</h2>
                        <div class="table-actions">
                            <button class="btn btn-outline btn-sm" onclick="renderConflicts()">
                                <span style="margin-right: 4px;">üîÑ</span> Refresh
                            </button>
                            <button class="btn btn-warning btn-sm" onclick="autoResolveConflicts()" style="margin-left: 8px;">
                                <span style="margin-right: 4px;">üîß</span> Auto-Resolve
                            </button>
                            <button class="btn btn-success btn-sm" onclick="exportConflictsReport()" style="margin-left: 8px;">
                                <span style="margin-right: 4px;">üìä</span> Export Report
                            </button>
                        </div>
                    </header>
                    <div class="card-content" id="conflictsContent">
                        <div class="loading">
                            <div class="spinner"></div>
                            <span>Analyzing shifts for conflicts...</span>
                        </div>
                    </div>
                </div>
            `;
            conflictsContent = document.getElementById('conflictsContent');
        }
        return;
    }
    
    console.log('Analyzing conflicts in', shifts.length, 'shifts...');
    
    // Analyze all shifts for conflicts
    const conflicts = {
        staffDoubleBooking: [],
        sleepoverViolations: [],
        excessiveHours: [],
        missingTimes: [],
        unconfirmedShifts: [],
        noPayRate: [],
        participantOverlaps: []
    };
    
    // 1. Check for staff double-booking
    const staffShiftsByDate = {};
    shifts.forEach(shift => {
        const key = `${shift.staff_id}_${shift.date}`;
        if (!staffShiftsByDate[key]) {
            staffShiftsByDate[key] = [];
        }
        staffShiftsByDate[key].push(shift);
    });
    
    Object.entries(staffShiftsByDate).forEach(([key, dayShifts]) => {
        if (dayShifts.length > 1) {
            // Check for time overlaps
            for (let i = 0; i < dayShifts.length - 1; i++) {
                for (let j = i + 1; j < dayShifts.length; j++) {
                    const shift1 = dayShifts[i];
                    const shift2 = dayShifts[j];
                    
                    if (shift1.start_time && shift1.end_time && 
                        shift2.start_time && shift2.end_time) {
                        
                        const start1 = new Date(`2000-01-01T${shift1.start_time}`);
                        let end1 = new Date(`2000-01-01T${shift1.end_time}`);
                        const start2 = new Date(`2000-01-01T${shift2.start_time}`);
                        let end2 = new Date(`2000-01-01T${shift2.end_time}`);
                        
                        if (end1 <= start1) end1.setDate(end1.getDate() + 1);
                        if (end2 <= start2) end2.setDate(end2.getDate() + 1);
                        
                        // Check for overlap
                        if (!(end1 <= start2 || start1 >= end2)) {
                            const overlapStart = new Date(Math.max(start1, start2));
                            const overlapEnd = new Date(Math.min(end1, end2));
                            
                            conflicts.staffDoubleBooking.push({
                                staff: shift1.staff,
                                date: shift1.date,
                                shift1: shift1,
                                shift2: shift2,
                                overlapPeriod: {
                                    start: overlapStart.toTimeString().slice(0, 5),
                                    end: overlapEnd.toTimeString().slice(0, 5),
                                    hours: ((overlapEnd - overlapStart) / (1000 * 60 * 60)).toFixed(1)
                                }
                            });
                        }
                    }
                }
            }
            
            // Check for sleepover violations
            const sleepover = dayShifts.find(s => 
                s.duty_type?.name?.toLowerCase().includes('sleepover')
            );
            
            if (sleepover) {
                dayShifts.forEach(shift => {
                    if (shift.id !== sleepover.id && shift.start_time) {
                        const startHour = parseInt(shift.start_time.split(':')[0]);
                        const endHour = shift.end_time ? 
                            parseInt(shift.end_time.split(':')[0]) : 0;
                        
                        if (startHour >= 22 || startHour < 6 || 
                            (endHour > 0 && endHour <= 6)) {
                            conflicts.sleepoverViolations.push({
                                staff: shift.staff,
                                date: shift.date,
                                sleepoverShift: sleepover,
                                conflictingShift: shift,
                                reason: startHour >= 22 ? 
                                    'Late night shift (after 10pm) with sleepover' : 
                                    'Early morning shift (before 6am) with sleepover'
                            });
                        }
                    }
                });
            }
        }
    });
    
    // 2. Check for excessive hours (over limit in week)
    const weekGroups = {};
    shifts.forEach(shift => {
        const weekStart = getWeekStart(new Date(shift.date));
        const weekKey = `${shift.staff_id}_${weekStart.toISOString().split('T')[0]}`;
        
        if (!weekGroups[weekKey]) {
            weekGroups[weekKey] = {
                staff: shift.staff,
                weekStart: weekStart,
                shifts: [],
                totalHours: 0
            };
        }
        
        weekGroups[weekKey].shifts.push(shift);
        weekGroups[weekKey].totalHours += shift.calculated_hours?.total || 0;
    });
    
    Object.values(weekGroups).forEach(group => {
        const limit = group.staff?.limits || 76;
        if (group.totalHours > limit) {
            conflicts.excessiveHours.push({
                staff: group.staff,
                weekStart: group.weekStart,
                totalHours: group.totalHours,
                limit: limit,
                excess: group.totalHours - limit,
                shiftCount: group.shifts.length
            });
        }
    });
    
    // 3. Check for missing times
    shifts.forEach(shift => {
        const isSleepover = shift.duty_type?.name?.toLowerCase().includes('sleepover');
        
        if (!isSleepover && (!shift.start_time || !shift.end_time)) {
            conflicts.missingTimes.push({
                shift: shift,
                staff: shift.staff,
                participant: shift.participant,
                date: shift.date,
                missing: !shift.start_time && !shift.end_time ? 'both times' :
                        !shift.start_time ? 'start time' : 'end time'
            });
        }
    });
    
    // 4. Check for unconfirmed shifts
    shifts.forEach(shift => {
        if (shift.status === 'pending') {
            conflicts.unconfirmedShifts.push({
                shift: shift,
                staff: shift.staff,
                participant: shift.participant,
                date: shift.date,
                daysOld: Math.floor((new Date() - new Date(shift.created_at)) / (1000 * 60 * 60 * 24))
            });
        }
    });
    
    // 5. Check for missing pay rates
    shifts.forEach(shift => {
        if (!shift.pay_override_id && !shift.staff?.pay_rate_id) {
            conflicts.noPayRate.push({
                shift: shift,
                staff: shift.staff,
                date: shift.date,
                participant: shift.participant
            });
        }
    });
    
    // 6. Check participant overlaps (for info)
    const participantShiftsByDate = {};
    shifts.forEach(shift => {
        if (shift.participant_id) {
            const key = `${shift.participant_id}_${shift.date}`;
            if (!participantShiftsByDate[key]) {
                participantShiftsByDate[key] = [];
            }
            participantShiftsByDate[key].push(shift);
        }
    });
    
    Object.entries(participantShiftsByDate).forEach(([key, dayShifts]) => {
        if (dayShifts.length > 1) {
            // Check for overlapping times
            let maxConcurrent = 0;
            const overlaps = [];
            
            for (let i = 0; i < dayShifts.length; i++) {
                const shift = dayShifts[i];
                if (shift.start_time && shift.end_time) {
                    const concurrent = [];
                    
                    for (let j = 0; j < dayShifts.length; j++) {
                        if (i !== j && dayShifts[j].start_time && dayShifts[j].end_time) {
                            const start1 = new Date(`2000-01-01T${shift.start_time}`);
                            let end1 = new Date(`2000-01-01T${shift.end_time}`);
                            const start2 = new Date(`2000-01-01T${dayShifts[j].start_time}`);
                            let end2 = new Date(`2000-01-01T${dayShifts[j].end_time}`);
                            
                            if (end1 <= start1) end1.setDate(end1.getDate() + 1);
                            if (end2 <= start2) end2.setDate(end2.getDate() + 1);
                            
                            if (!(end1 <= start2 || start1 >= end2)) {
                                concurrent.push(dayShifts[j]);
                            }
                        }
                    }
                    
                    if (concurrent.length > 0 && concurrent.length + 1 > maxConcurrent) {
                        maxConcurrent = concurrent.length + 1;
                        overlaps.push({
                            participant: shift.participant,
                            date: shift.date,
                            ratio: `${concurrent.length + 1}:1`,
                            mainShift: shift,
                            overlappingShifts: concurrent
                        });
                    }
                }
            }
            
            if (maxConcurrent > 2) {
                // Only flag if more than 2:1 ratio
                conflicts.participantOverlaps.push(overlaps[0]);
            }
        }
    });
    
    // Build the HTML display
    let html = `
        <style>
            .conflicts-summary {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 16px;
                margin-bottom: 24px;
            }
            
            .conflict-stat {
                background: white;
                border: 1px solid var(--border-color);
                border-radius: 8px;
                padding: 16px;
                text-align: center;
            }
            
            .conflict-stat.error {
                border-color: var(--danger-color);
                background: var(--danger-color)10;
            }
            
            .conflict-stat.warning {
                border-color: var(--warning-color);
                background: var(--warning-color)10;
            }
            
            .conflict-stat.info {
                border-color: var(--info-color);
                background: var(--info-color)10;
            }
            
            .conflict-stat h3 {
                margin: 0 0 8px 0;
                font-size: 24px;
                font-weight: bold;
            }
            
            .conflict-stat p {
                margin: 0;
                font-size: 14px;
                color: var(--text-secondary);
            }
            
            .conflict-section {
                margin-bottom: 32px;
            }
            
            .conflict-section h3 {
                margin-bottom: 16px;
                display: flex;
                align-items: center;
                gap: 8px;
            }
            
            .conflict-item {
                background: white;
                border: 1px solid var(--border-color);
                border-radius: 8px;
                padding: 16px;
                margin-bottom: 12px;
                display: flex;
                justify-content: space-between;
                align-items: center;
            }
            
            .conflict-details {
                flex: 1;
            }
            
            .conflict-actions {
                display: flex;
                gap: 8px;
            }
            
            .overlap-visual {
                display: inline-block;
                background: var(--danger-color)20;
                color: var(--danger-color);
                padding: 4px 8px;
                border-radius: 4px;
                font-family: monospace;
                font-size: 12px;
                margin-left: 8px;
            }
        </style>
        
        <div class="conflicts-summary">
            <div class="conflict-stat ${conflicts.staffDoubleBooking.length > 0 ? 'error' : ''}">
                <h3>${conflicts.staffDoubleBooking.length}</h3>
                <p>Staff Double-Bookings</p>
            </div>
            <div class="conflict-stat ${conflicts.sleepoverViolations.length > 0 ? 'error' : ''}">
                <h3>${conflicts.sleepoverViolations.length}</h3>
                <p>Sleepover Violations</p>
            </div>
            <div class="conflict-stat ${conflicts.excessiveHours.length > 0 ? 'warning' : ''}">
                <h3>${conflicts.excessiveHours.length}</h3>
                <p>Excessive Hours</p>
            </div>
            <div class="conflict-stat ${conflicts.missingTimes.length > 0 ? 'warning' : ''}">
                <h3>${conflicts.missingTimes.length}</h3>
                <p>Missing Times</p>
            </div>
            <div class="conflict-stat ${conflicts.unconfirmedShifts.length > 0 ? 'info' : ''}">
                <h3>${conflicts.unconfirmedShifts.length}</h3>
                <p>Unconfirmed Shifts</p>
            </div>
            <div class="conflict-stat ${conflicts.noPayRate.length > 0 ? 'warning' : ''}">
                <h3>${conflicts.noPayRate.length}</h3>
                <p>No Pay Rate</p>
            </div>
        </div>
    `;
    
    // Staff Double-Booking Section
    if (conflicts.staffDoubleBooking.length > 0) {
        html += `
            <div class="conflict-section">
                <h3>
                    <span style="color: var(--danger-color);"></span> 
                    Staff Double-Bookings (${conflicts.staffDoubleBooking.length})
                </h3>
        `;
        
        conflicts.staffDoubleBooking.forEach(conflict => {
            const staff = conflict.staff || {};
            const part1 = conflict.shift1.participant || {};
            const part2 = conflict.shift2.participant || {};
            
            html += `
                <div class="conflict-item">
                    <div class="conflict-details">
                        <strong>${staff.first_name} ${staff.last_name}</strong> - 
                        ${formatDateFriendly(conflict.date)}
                        <br>
                        <span style="color: var(--text-secondary);">
                            Shift 1: ${formatTime12Hour(conflict.shift1.start_time)} - ${formatTime12Hour(conflict.shift1.end_time)} 
                            (${part1.first_name || 'Unknown'} ${part1.last_name || ''})
                        </span>
                        <br>
                        <span style="color: var(--text-secondary);">
                            Shift 2: ${formatTime12Hour(conflict.shift2.start_time)} - ${formatTime12Hour(conflict.shift2.end_time)} 
                            (${part2.first_name || 'Unknown'} ${part2.last_name || ''})
                        </span>
                        <span class="overlap-visual">
                            Overlap: ${conflict.overlapPeriod.start} - ${conflict.overlapPeriod.end} (${conflict.overlapPeriod.hours}h)
                        </span>
                    </div>
                    <div class="conflict-actions">
                        <button class="btn btn-sm btn-outline" onclick="editShift(${conflict.shift1.id})">
                            Edit Shift 1
                        </button>
                        <button class="btn btn-sm btn-outline" onclick="editShift(${conflict.shift2.id})">
                            Edit Shift 2
                        </button>
                        <button class="btn btn-sm btn-danger" onclick="deleteShift(${conflict.shift2.id})">
                            Delete Shift 2
                        </button>
                    </div>
                </div>
            `;
        });
        
        html += '</div>';
    }
    
    // Sleepover Violations Section
    if (conflicts.sleepoverViolations.length > 0) {
        html += `
            <div class="conflict-section">
                <h3>
                    <span style="color: var(--danger-color);">‚ö†Ô∏è</span>
                    Sleepover Violations (${conflicts.sleepoverViolations.length})
                </h3>
        `;
        
        conflicts.sleepoverViolations.forEach(conflict => {
            const staff = conflict.staff || {};
            
            html += `
                <div class="conflict-item">
                    <div class="conflict-details">
                        <strong>${staff.first_name} ${staff.last_name}</strong> - 
                        ${formatDateFriendly(conflict.date)}
                        <br>
                        <span style="color: var(--danger-color);">${conflict.reason}</span>
                        <br>
                        <span style="color: var(--text-secondary);">
                            Sleepover + ${formatTime12Hour(conflict.conflictingShift.start_time)} - 
                            ${formatTime12Hour(conflict.conflictingShift.end_time)}
                        </span>
                    </div>
                    <div class="conflict-actions">
                        <button class="btn btn-sm btn-outline" onclick="editShift(${conflict.conflictingShift.id})">
                            Reschedule Shift
                        </button>
                        <button class="btn btn-sm btn-danger" onclick="deleteShift(${conflict.sleepoverShift.id})">
                            Remove Sleepover
                        </button>
                    </div>
                </div>
            `;
        });
        
        html += '</div>';
    }
    
    // Excessive Hours Section
    if (conflicts.excessiveHours.length > 0) {
        html += `
            <div class="conflict-section">
                <h3>
                    <span style="color: var(--warning-color);">‚è∞</span>
                    Excessive Hours (${conflicts.excessiveHours.length})
                </h3>
        `;
        
        conflicts.excessiveHours.forEach(conflict => {
            const staff = conflict.staff || {};
            
            html += `
                <div class="conflict-item">
                    <div class="conflict-details">
                        <strong>${staff.first_name} ${staff.last_name}</strong>
                        <br>
                        Week of ${formatDateFriendly(conflict.weekStart.toISOString().split('T')[0])}
                        <br>
                        <span style="color: var(--warning-color);">
                            ${conflict.totalHours.toFixed(1)}h / ${conflict.limit}h limit 
                            (${conflict.excess.toFixed(1)}h over)
                        </span>
                    </div>
                    <div class="conflict-actions">
                        <button class="btn btn-sm btn-outline" 
                                onclick="viewStaffWeek('${staff.id}', '${conflict.weekStart.toISOString().split('T')[0]}')">
                            View Week
                        </button>
                        <button class="btn btn-sm btn-warning" 
                                onclick="redistributeHours('${staff.id}', '${conflict.weekStart.toISOString().split('T')[0]}')">
                            Redistribute
                        </button>
                    </div>
                </div>
            `;
        });
        
        html += '</div>';
    }
    
    // Missing Times Section
    if (conflicts.missingTimes.length > 0) {
        html += `
            <div class="conflict-section">
                <h3>
                    <span style="color: var(--warning-color);">üïê</span>
                    Missing Times (${conflicts.missingTimes.length})
                </h3>
        `;
        
        conflicts.missingTimes.forEach(conflict => {
            const staff = conflict.staff || {};
            const participant = conflict.participant || {};
            
            html += `
                <div class="conflict-item">
                    <div class="conflict-details">
                        <strong>${formatDateFriendly(conflict.date)}</strong> - 
                        ${staff.first_name} ${staff.last_name}
                        <br>
                        <span style="color: var(--text-secondary);">
                            ${participant.first_name || 'Unknown'} ${participant.last_name || ''}
                        </span>
                        <br>
                        <span style="color: var(--warning-color);">Missing: ${conflict.missing}</span>
                    </div>
                    <div class="conflict-actions">
                        <button class="btn btn-sm btn-primary" onclick="editShift(${conflict.shift.id})">
                            Add Times
                        </button>
                    </div>
                </div>
            `;
        });
        
        html += '</div>';
    }
    
    if (Object.values(conflicts).every(arr => arr.length === 0)) {
        html = `
            <div style="text-align: center; padding: 60px 20px;">
                <div style="font-size: 64px; margin-bottom: 16px;">‚úÖ</div>
                <h3>No Conflicts Found!</h3>
                <p style="color: var(--text-secondary);">All shifts are properly scheduled with no overlaps or violations.</p>
            </div>
        `;
    }
    
    conflictsContent.innerHTML = html;
}

// Helper function to view a specific staff member's week
function viewStaffWeek(staffId, weekStart) {
    // Set filters
    document.getElementById('staffFilterInput').value = 
        staff.find(s => s.id === staffId)?.first_name + ' ' + 
        staff.find(s => s.id === staffId)?.last_name;
    updateStaffFilter();
    
    // Set week
    currentWeekStart = new Date(weekStart);
    updateWeekDisplay();
    loadShifts();
    
    // Switch to roster view
    switchView('table');
}

// Export conflicts report
function exportConflictsReport() {
    // Similar to renderConflicts but generates CSV
    let csv = 'Type,Staff,Date,Details,Action Required\n';
    
    // Add all conflicts to CSV...
    // (implementation similar to above but formatted for CSV)
    
    downloadCSV(csv, `conflicts_report_${new Date().toISOString().split('T')[0]}.csv`);
    showNotification('Conflicts report exported', 'success');
}

// Call initialization when document is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeEnhancements);
} else {
    initializeEnhancements();
}

    </script>
</body>
</html>
